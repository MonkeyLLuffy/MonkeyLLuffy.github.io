<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|oboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="日常,笔试," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="进程间通信：方式一：访问其他应用程序的ActivityActivity既可以在进程内（同一个应用程序）访问，也可以跨进程访问。Activity的跨进程访问与进程内访问略有不同。虽然它们都需要Intent对象，但跨进程访问并不需要指定Context对象和Activity的 Class对象，而需要指定的是要访问的Activity所对应的Action（一个字符串）。有些Activity还需要指定一个Ur">
<meta property="og:type" content="article">
<meta property="og:title" content="常用笔试题">
<meta property="og:url" content="http://monkeylluffy.github.io/2016/常用笔试题/index.html">
<meta property="og:site_name" content="MonkeyLLuffy">
<meta property="og:description" content="进程间通信：方式一：访问其他应用程序的ActivityActivity既可以在进程内（同一个应用程序）访问，也可以跨进程访问。Activity的跨进程访问与进程内访问略有不同。虽然它们都需要Intent对象，但跨进程访问并不需要指定Context对象和Activity的 Class对象，而需要指定的是要访问的Activity所对应的Action（一个字符串）。有些Activity还需要指定一个Ur">
<meta property="og:image" content="http://my.csdn.net/uploads/201204/17/1334628691_7836.png">
<meta property="og:image" content="http://my.csdn.net/uploads/201204/17/1334628702_9553.png">
<meta property="og:image" content="http://img.my.csdn.net/uploads/201211/29/1354170699_6619.png">
<meta property="og:updated_time" content="2016-09-27T08:52:22.410Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常用笔试题">
<meta name="twitter:description" content="进程间通信：方式一：访问其他应用程序的ActivityActivity既可以在进程内（同一个应用程序）访问，也可以跨进程访问。Activity的跨进程访问与进程内访问略有不同。虽然它们都需要Intent对象，但跨进程访问并不需要指定Context对象和Activity的 Class对象，而需要指定的是要访问的Activity所对应的Action（一个字符串）。有些Activity还需要指定一个Ur">
<meta name="twitter:image" content="http://my.csdn.net/uploads/201204/17/1334628691_7836.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://monkeylluffy.github.io/2016/常用笔试题/"/>

  <title> 常用笔试题 | MonkeyLLuffy </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">MonkeyLLuffy</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">http://monkeylluffy.github.io/</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                常用笔试题
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T11:15:26+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/复习记录/" itemprop="url" rel="index">
                    <span itemprop="name">复习记录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="进程间通信："><a href="#进程间通信：" class="headerlink" title="进程间通信："></a>进程间通信：</h2><p><strong>方式一：访问其他应用程序的Activity</strong><br>Activity既可以在进程内（同一个应用程序）访问，也可以跨进程访问。Activity的跨进程访问与进程内访问略有不同。虽然它们都需要Intent对象，但跨进程访问并不需要指定Context对象和Activity的 Class对象，而需要指定的是要访问的Activity所对应的Action（一个字符串）。有些Activity还需要指定一个Uri（通过 Intent构造方法的第2个参数指定）。  </p>
<a id="more"></a>
<p><strong>方式二：Content Provider </strong><br>Android应用程序可以使用文件或SqlLite数据库来存储数据。Content Provider提供了一种在多个应用程序之间数据共享的方式（跨进程共享数据）。应用程序可以利用Content Provider完成下面的工作：  </p>
<ol>
<li>查询数据</li>
<li>修改数据</li>
<li>添加数据</li>
<li>删除数据</li>
</ol>
<p><strong>方式三：广播（Broadcast）</strong>  </p>
<p>在应用程序中发送广播比较简单。只需要调用sendBroadcast方法即可。该方法需要一个Intent对象。通过Intent对象可以发送需要广播的数据。发送广播并不需要在AndroidManifest.xml文件中注册，但接收广播必须在AndroidManifest.xml文件中注册 receiver（或者动态注册）。  </p>
<p><strong>方式四：AIDL服务</strong>  </p>
<p>服务（Service）是android系统中非常重要的组件。android系统中的Service主要有两个作用：后台运行和跨进程通讯。<br>AIDL的全称是Android Interface Definition Language，也就是说，AIDL实际上是一种接口定义语言。通过这种语言定义接口后，Eclipse插件（ODT）会自动生成相应的Java代码接 口代码。下面来看一下编写一个AIDL服务的基本步骤。</p>
<ol>
<li>在Eclipse工程的package目录中建立一个扩展名为aidl的文件。package目录就是Java类所在的目录。该文件的语法类似于Java代码。aidl文件中定义的是AIDL服务的接口。这个接口需要在调用AIDL服务的程序中访问。</li>
<li>如果aidl文件的内容是正确的，Eclipse插件会自动生成一个Java接口文件（*.java）。</li>
<li>建立一个服务类（Service的子类）。</li>
<li>实现由aidl文件生成的Java接口。</li>
<li>在AndroidManifest.xml文件中配置AIDL服务，尤其要注意的是，<action>标签的android:name属性值就是客户端要引用该服务的ID，也就是Intent类构造方法的参数值。</action></li>
</ol>
<h2 id="Android-Service与Activity之间通信的几种方式"><a href="#Android-Service与Activity之间通信的几种方式" class="headerlink" title="Android Service与Activity之间通信的几种方式"></a>Android Service与Activity之间通信的几种方式</h2><p><strong>方式一：通过Binder对象</strong><br>Activity调用bindService (Intent service, ServiceConnection conn, int flags)方法，得到Service对象的一个引用，这样Activity可以直接调用到Service中的方法，如果要主动通知Activity，我们可以利用回调方法。   </p>
<p><strong>方式二：通过broadcast(广播)的形式</strong><br>Service向Activity发送消息，可以使用广播，当然Activity要注册相应的接收器。比如Service要向多个Activity发送同样的消息的话，用这种方法就更好。  </p>
<h2 id="Activity-Service-Fragment生命周期"><a href="#Activity-Service-Fragment生命周期" class="headerlink" title="Activity Service Fragment生命周期"></a>Activity Service Fragment生命周期</h2><p><strong>Activity</strong><br><img src="http://my.csdn.net/uploads/201204/17/1334628691_7836.png" alt="">  </p>
<p><strong>Service</strong><br><img src="http://my.csdn.net/uploads/201204/17/1334628702_9553.png" alt=""></p>
<p><strong>Fragment</strong><br><img src="http://img.my.csdn.net/uploads/201211/29/1354170699_6619.png" alt=""></p>
<h2 id="Android中view和surfaceview的区别"><a href="#Android中view和surfaceview的区别" class="headerlink" title="Android中view和surfaceview的区别"></a>Android中view和surfaceview的区别</h2><p>使用的SurfaceView的时候，一般情况下要对其进行创建，销毁，改变时的情况进行监视，这就要用到 SurfaceHolder.Callback.   </p>
<p>对于Surface相关的，Android底层还提供了GPU加速功能，所以一般实时性很强的应用中主要使用SurfaceView而不是直接从View构建，同时后来做android 3d OpenGL中的GLSurfaceView也是从该类实现。  </p>
<p>SurfaceView和View最本质的区别在于，surfaceView是在一个新起的单独线程中可以重新绘制画面而View必须在UI的主线程中更新画面。   </p>
<p>那么在UI的主线程中更新画面 可能会引发问题，比如你更新画面的时间过长，那么你的主UI线程会被你正在画的函数阻塞。那么将无法响应按键，触屏等消息。   </p>
<p>当使用surfaceView 由于是在新的线程中更新画面所以不会阻塞你的UI主线程。但这也带来了另外一个问题，就是事件同步。比如你触屏了一下，你需要surfaceView中thread处理，一般就需要有一个event queue的设计来保存touch event，这会稍稍复杂一点，因为涉及到线程同步。 </p>
<p>所以基于以上，根据游戏特点，一般分成两类。 </p>
<p>1 被动更新画面的。比如棋类，这种用view就好了。因为画面的更新是依赖于 onTouch 来更新，可以直接使用 invalidate。 因为这种情况下，这一次Touch和下一次的Touch需要的时间比较长些，不会产生影响。 </p>
<p>2 主动更新。比如一个人在一直跑动。这就需要一个单独的thread不停的重绘人的状态，避免阻塞main UI thread。所以显然view不合适，需要surfaceView来控制。</p>
<p>3.Android中的SurfaceView类就是双缓冲机制。因此，开发游戏时尽量使用SurfaceView而不要使用View，这样的话效率较高，而且SurfaceView的功能也更加完善。</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><a href="http://www.cnblogs.com/dolphin0520/archive/2011/04/16/2017737.html" target="_blank" rel="external">什么是拓扑排序</a></p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。<br>步骤<br>用回溯算法解决问题的一般步骤为：<br>一、定义一个解空间，它包含问题的解。<br>二、利用适于搜索的方法组织解空间。<br>三、利用深度优先法搜索解空间。<br>四、利用限界函数避免移动到不可能产生解的子空间。<br>问题的解空间通常是在搜索问题的解的过程中动态产生的，这是回溯算法的一个重要特性。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WolfQueen</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 一共有多少个皇后（此时设置为8皇后在8X8棋盘，可以修改此值来设置N皇后问题）</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> max = <span class="number">8</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 该数组保存结果，第一个皇后摆在array[0]列，第二个摆在array[1]列</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> WolfQueen().check(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * n代表当前是第几个皇后</div><div class="line">     * <span class="doctag">@param</span> n</div><div class="line">     * 皇后n在array[n]列</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="comment">//终止条件是最后一行已经摆完，由于每摆一步都会校验是否有冲突，所以只要最后一行摆完，说明已经得到了一个正确解</span></div><div class="line">        <span class="keyword">if</span> (n == max) &#123;</div><div class="line">            print();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//从第一列开始放值，然后判断是否和本行本列本斜线有冲突，如果OK，就进入下一行的逻辑</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</div><div class="line">            array[n] = i;</div><div class="line">            <span class="keyword">if</span> (judge(n)) &#123;</div><div class="line">                check(n + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span>  </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            System.out.print(array[i] + <span class="number">1</span> + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>参见贪婪算法的Prime算法和Kruscal算法：  </p>
<ol>
<li>Prime算法的思想是不断找出边缘中最短的；  </li>
<li>Kruscal算法的思想是排序所有边，然后将没有形成回路的最小边加入树中，知道加n-1条边。<br>Prime  </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> unReach = <span class="number">1000</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[][] G = &#123; &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">10</span> &#125;, </div><div class="line">			&#123; <span class="number">4</span>, <span class="number">0</span>, <span class="number">10</span>, unReach &#125;, </div><div class="line">			&#123; <span class="number">15</span>, <span class="number">10</span>, <span class="number">0</span>, unReach &#125;, </div><div class="line">			&#123; <span class="number">10</span>, unReach, unReach, <span class="number">0</span> &#125; &#125;;</div><div class="line"></div><div class="line">	<span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</div><div class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">	<span class="comment">// 清空生成树，任取一个顶点加入生成树</span></div><div class="line">	initVisit(visit);</div><div class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">	visit[index] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">		dist[i] = G[index][i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; visit.length; i++) &#123;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> min = unReach;</div><div class="line"><span class="comment">// 在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">			</div><div class="line">			<span class="keyword">if</span> (!visit[j] &amp;&amp; (min &gt; dist[j])) &#123;</div><div class="line">				min = dist[j];</div><div class="line">				index = j;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		visit[index] = <span class="keyword">true</span>;</div><div class="line">		sum += min;</div><div class="line"></div><div class="line">		<span class="comment">// 重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">			<span class="keyword">if</span> (!visit[j] &amp;&amp; dist[j] &gt; G[index][j]) &#123;</div><div class="line">				dist[j] = G[index][j];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	System.out.println(sum);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initVisit</span><span class="params">(<span class="keyword">boolean</span>[] visit)</span> </span>&#123;</div><div class="line">	<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visit.length; i++) &#123;</div><div class="line">		visit[i] = <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>kruscal:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> LiuQun</div><div class="line"> * 中心是快速求并法。用一个有根树来表示每一个子集，树中的节点包含子集中的元素；</div><div class="line"> * 根中的元素就被当做该子集的代表树；树中的边从子女指向他们的父母</div><div class="line"> * makeset():创建一颗单节点的树</div><div class="line"> * union(x,y):把Y树的根附加到X上（并把Y树删除）</div><div class="line"> * find(x):从包含x的节点开始找到树的根</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">5</span>;<span class="comment">// 顶点个数</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> edgeNum = <span class="number">7</span>;<span class="comment">// 总边数</span></div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> father[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];<span class="comment">//</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> rank[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];<span class="comment">//树的等级（层数），优化算法用的，层数小的加在层数大的下</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// 边的数组</span></div><div class="line">		Edge[] edges = <span class="keyword">new</span> Edge[edgeNum];</div><div class="line"></div><div class="line">		edges[<span class="number">0</span>] = <span class="keyword">new</span> Edge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>);</div><div class="line">		edges[<span class="number">1</span>] = <span class="keyword">new</span> Edge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">		edges[<span class="number">2</span>] = <span class="keyword">new</span> Edge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>);</div><div class="line">		edges[<span class="number">3</span>] = <span class="keyword">new</span> Edge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>);</div><div class="line">		edges[<span class="number">4</span>] = <span class="keyword">new</span> Edge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>);</div><div class="line">		edges[<span class="number">5</span>] = <span class="keyword">new</span> Edge(<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">		edges[<span class="number">6</span>] = <span class="keyword">new</span> Edge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line">		Edge[] result = <span class="keyword">new</span> Edge[edgeNum];</div><div class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="comment">// 按照权重排序树的边</span></div><div class="line">		srotEdge(edges);</div><div class="line">		printEdge(edges);</div><div class="line">		</div><div class="line">		</div><div class="line">		make_set();</div><div class="line"></div><div class="line">		<span class="comment">// 将图遍历一次，找出权值最小的边，（条件：此次找出的边不能和已加入最小生成树集合的边构成环），</span></div><div class="line">		<span class="comment">// 若符合条件，则加入最小生成树的集合中。不符合条件则继续遍历图，寻找下一个最小权值的边。</span></div><div class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">			<span class="comment">// tree中无回路，使用不相交子集和并查算法</span></div><div class="line">			<span class="keyword">if</span> (find_set(edges[i].getFirst()) != find_set(edges[i].getSecond())) &#123;</div><div class="line">				union(edges[i].first, edges[i].second);</div><div class="line">				sum += edges[i].value;</div><div class="line">				result[count++] = edges[i];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		System.out.println(sum);</div><div class="line">		printEdge(result);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//把每个元素初始化为一个集合 </span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_set</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">			father[i] = i;</div><div class="line">			rank[i] = <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 采用直接插入排序</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">srotEdge</span><span class="params">(Edge[] edges)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; edges.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (edges[i].value &lt; edges[i - <span class="number">1</span>].value) &#123;</div><div class="line">				<span class="keyword">int</span> j = i - <span class="number">1</span>;</div><div class="line">				Edge temp = edges[i];</div><div class="line">				<span class="keyword">while</span> (j &gt; -<span class="number">1</span> &amp;&amp; temp.value &lt; edges[j].value) &#123;</div><div class="line">					edges[j + <span class="number">1</span>] = edges[j];</div><div class="line">					j--;</div><div class="line">				&#125;</div><div class="line">				edges[j + <span class="number">1</span>] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 从包含x的节点开始找到树的根</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> x</div><div class="line">	 *            顶点</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_set</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (x != father[x]) &#123;</div><div class="line">			father[x] = find_set(father[x]);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> father[x];</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 合并x,y所在的两个集合：利用Find_Set找到其中两棵树的根， 并将一棵树的根指向另一棵树的根。</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> first</div><div class="line">	 *            x</div><div class="line">	 * <span class="doctag">@param</span> second</div><div class="line">	 *            y</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		first = find_set(first);</div><div class="line">		second = find_set(second);</div><div class="line">		<span class="keyword">if</span> (first == second) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (rank[first] &lt; rank[second]) &#123;</div><div class="line">			father[first] = find_set(second);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span> (rank[first] == rank[second]) &#123;</div><div class="line">				rank[first]++;</div><div class="line">			&#125;</div><div class="line">			father[second] = find_set(first);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Edge[] edge)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (edge[i] != <span class="keyword">null</span>)</div><div class="line">				System.out.println(edge[i].toString());</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>// 两点之间的加权边</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">int</span> first, second;<span class="comment">// 表示一条边的两个节点</span></div><div class="line">		<span class="keyword">private</span> <span class="keyword">int</span> value;<span class="comment">// 权值</span></div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">			<span class="keyword">this</span>.first = first;</div><div class="line">			<span class="keyword">this</span>.second = second;</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> first;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> second;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> value;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object arg0)</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> value &gt; ((Edge) arg0).value ? <span class="number">0</span> : -<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="string">"Bian[first="</span> + first + <span class="string">",second="</span> + second + <span class="string">",value="</span> + value + <span class="string">"]"</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Android涉及到的设计模式"><a href="#Android涉及到的设计模式" class="headerlink" title="Android涉及到的设计模式"></a>Android涉及到的设计模式</h2><p>1、<strong>适配器模式</strong>：ListView或GridView的Adapter<br>简介：不同的数据提供者使用一个适配器来向一个相同的客户提供服务。  </p>
<p>2、<strong>建造者模式</strong>：AlertDialog.Builder<br>简介：可以分步地构造每一部分。  </p>
<p>3、<strong>命令模式</strong>：Handler.post后Handler.handleMessage<br>简介：把请求封装成一个对象发送出去，方便定制、排队、取消。  </p>
<p>4、<strong>享元模式</strong>：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。<br>简介：运用共享技术有效地支持大量细粒度的对象。    </p>
<p>5、<strong>迭代器模式</strong>：如通过Hashtable.elements方法可以得到一个Enumeration，然后通过这个Enumeration访问Hashtable中的数据，而不用关心Hashtable中的数据存放方式。<br>简介：提供一个方法顺序访问数据集合中的所有数据而又不暴露对象的内部表示。  </p>
<p>6、<strong>备忘录模式</strong>：Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心<br>简介：不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。  </p>
<p>7、<strong>观察者模式</strong>：我们可以通过BaseAdapter.registerDataSetObserver和BaseAdapter.unregisterDataSetObserver两方法来向BaseAdater注册、注销一个DataSetObserver。这个过程中，DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。事件通知也是观察者模式<br>简介：一个对象发生改变时，所有信赖于它的对象自动做相应改变。  </p>
<p>8、<strong>原型模式</strong>：比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了<br>简介：在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。  </p>
<p>9、<strong>代理模式</strong>：类似于ios开发的delegate委托模式，所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。<br>简介：为其他对象提供一种代理以控制对这个对象的访问。  </p>
<p>10、<strong>状态模式</strong>：View.onVisibilityChanged方法，就是提供了一个状态模式的实现，允许在View的visibility发生改变时，引发执行onVisibilityChanged方法中的动作。<br>简介：状态发生改变时，行为改变。  </p>
<p>11、<strong>策略模式</strong>：<br>举例：Java.util.List就是定义了一个增（add）、删（remove）、改（set）、查（indexOf）策略，至于实现这个策略的ArrayList、LinkedList等类，只是在具体实现时采用了不同的算法。但因为它们策略一样，不考虑速度的情况下，使用时完全可以互相替换使用。<br>简介：定义了一系列封装了算法、行为的对象，他们可以相互替换。</p>
<p>12、<strong>调解者模式</strong><br>简介：一个对象的某个操作需要调用N个对象的M个方法来完成时，把这些调用过程封装起来，就成了一个调解者<br>举例：如Resource.getDrawable方法的实现逻辑是这样的：创建一个缓存来存放所有已经加载过的，如果getDrawable中传入的id所对应的Drawable以前没有被加载过，那么它就会根据id所对应的资源类型，分别调用XML解析器生成，或者通过读取包中的图片资源文件来创建Drawable。而Resource.getDrawable把涉及到多个对象、多个逻辑的操作封装成一个方法，就实现了一个调解者的角色。   </p>
<p>13、<strong>抽象工厂模式</strong><br>DAO与Service的使用  </p>
<h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><p>在Android艺术探索中看到一句话：绝大多数情况下，硬件加速都可以解决莫名其妙的卡顿问题。通过设置android:hardwareAccelerated = “true”即可为Activity开启硬件加速。那么问题来了：什么叫硬件加速？它的原理是什么？  </p>
<p>Android从3.0（API Level 11）开始，在绘制View的时候支持硬件加速，充分利用GPU的特性，使得绘制更加平滑，但是会多消耗一些内存。</p>
<p> 理解View的绘制模型：invalidate（）重绘</p>
<ol>
<li><p>没有硬件加速：步骤如下：<br> Invalidate the hierarchy（注：hierarchy怎么翻译？）<br>  Draw the hierarchy  </p>
<p> 应用程序调用invalidate()更新UI的某一部分，失效(invalidation)消息将会在整个视图层中传递，计算每个需要重绘的区域（即脏区域）。然后Android系统将会重绘所有和脏区域有交集的view。很明显，这种绘图模式存在缺点：  </p>
<p>  每个绘制操作中会执行不必要的代码。比如如果应用程序调用invalidate()重绘button，而button又位于另一个view之上，即使该view没有变化，也会进行重绘。  </p>
<p>  可能会掩盖一些应用程序的bug。因为android系统会重绘与脏区域有交集的view，所以view的内容可能会在没有调用invalidate()的情况下重绘。这可能会导致一个view依赖于其它view的失效才得到正确的行为。  </p>
</li>
<li><p>有硬件加速：<br> Android系统仍然使用invalidate()和draw()来绘制view，但在处理绘制上有所不同。Android系统记录绘制命令到显示列表，而不是立即执行绘制命令。另一个优化就是Android系统只需记录和更新标记为脏（通过invalidate()）的view。新的绘制模型包含三个步骤：  </p>
<p>  Invalidate the hierarchy  </p>
<p>  记录和更新显示列表  </p>
<p>  绘制显示列表  </p>
</li>
</ol>
<h2 id="线程和进程的区别联系"><a href="#线程和进程的区别联系" class="headerlink" title="线程和进程的区别联系"></a>线程和进程的区别联系</h2><ol>
<li>进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。</li>
<li>线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。   </li>
</ol>
<p>两者都可以提高程序的并发度，提高程序运行效率和响应时间。<br>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。  </p>
<p>根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的：<br>    1、速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。<br>    2、资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。<br>    3、同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内  </p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/日常/" rel="tag">#日常</a>
          
            <a href="/tags/笔试/" rel="tag">#笔试</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/阳春白雪与下里巴人/" rel="next" title="阳春白雪与下里巴人">
                <i class="fa fa-chevron-left"></i> 阳春白雪与下里巴人
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/短板/" rel="prev" title="短板">
                短板 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/girl.jpeg"
               alt="MonkeyLLuffy" />
          <p class="site-author-name" itemprop="name">MonkeyLLuffy</p>
          <p class="site-description motion-element" itemprop="description">刘群的博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">37</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/MonkeyLLuffy" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2450166183/profile?topnav=1&wvr=6" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信："><span class="nav-number">1.</span> <span class="nav-text">进程间通信：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-Service与Activity之间通信的几种方式"><span class="nav-number">2.</span> <span class="nav-text">Android Service与Activity之间通信的几种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity-Service-Fragment生命周期"><span class="nav-number">3.</span> <span class="nav-text">Activity Service Fragment生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android中view和surfaceview的区别"><span class="nav-number">4.</span> <span class="nav-text">Android中view和surfaceview的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓扑排序"><span class="nav-number">5.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回溯"><span class="nav-number">6.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小生成树"><span class="nav-number">7.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android涉及到的设计模式"><span class="nav-number">8.</span> <span class="nav-text">Android涉及到的设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件加速"><span class="nav-number">9.</span> <span class="nav-text">硬件加速</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程和进程的区别联系"><span class="nav-number">10.</span> <span class="nav-text">线程和进程的区别联系</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MonkeyLLuffy</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
