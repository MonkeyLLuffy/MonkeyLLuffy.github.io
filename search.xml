<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[2018年第一篇博客]]></title>
      <url>%2F2018%2F2018%E5%B9%B4%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[这段时间过得（从减肥开始，就是从2017.11）真的太废了，没有学习什么东西，也没有写博客，今天在小窝里突然把电脑拿出来了，决定还是做点正事，今天写一篇总结自己的博客。总结自己这小半年以来的作为，反思以及规划。 2017.11-至今这段时间对我来说，最大的改变是交友。在10月18号的时候，刘鑫去合肥出差了，我的圈子开始缩小，然后我开始了减肥，在这段时间，和罗道军还有潘林成为了好朋友，同时，因为和鑫哥拉了距离，所以我俩的友情到达了前所未有的高度，前所未有的思念。这段时间，我有点飘，感觉自己很自信，和谁都能成为好朋友。 时间过得飞快，和杨艳秋跑到合肥去给刘鑫还有我自己过生日。这个时候，我和刘鑫应该是最好的时候。一切巅峰都会衰落，大概是从刘鑫成为程瑞女朋友开始，我哭了，这一天，因为我知道我们的友情注定要衰落了。原因大概在于我和杨艳秋合不来，然后在我那天晚上唱歌回去，杨艳秋跟我讲程瑞怎么问她怎么问她我就知道，我大概知道到这儿了，不能陪她更多了。 前面这一截还只是一部分，更重要的事情在我把小胖和熊陪童的事情说给刘鑫之后，刘鑫回来上海这边转个身就告诉了杨艳秋。如果说之前我只是知道，第一亲近的人是我该退为第二位了，现在我就是知道我的第一亲近的人也不应该是她了。也就是这种想法，导致我和她越来越远，而她和杨艳秋越来越近。 我永远都理智的知道我没有理由要求别人离谁远一点，但是朋友间吃醋也是很正常的事情。环惠清和我说话，我没怎么搭理她时她会生气，然后得我去哄她，然后我因为杨艳秋生气了，她没做任何调节，这是我很失望的点，她不会为贴近你的心做点什么，如果只是物质上的，回想起来，连物质上的也不知道做了什么呢？ 前面的事情已经做足了铺垫，年后，我和刘鑫越来越亲近不起来了，她也顺理成章的和杨艳秋越来越近，我说实话，看起来十分碍眼睛。但是最生气的还是因为一点小事（苑苑请吃饭，她去吃杨艳秋的做的饭，问了我好几遍可不可以不去，然后我就叫她不要去了，并且我是生气的），她直接周一就和杨艳秋去上班了。那时，我决定不和她俩一起住了，眼不见心不烦。然后~~~现在已经沦为普通朋友。 不是说单方面的，而是双方都沦为了普通朋友。 现在已经是一个人住的我，我可以在我的房间铺上小地毯，在这深夜12点的时候写博客，不用担心有人跟我学，有人对我使小心思。晚上回来不用看谁的脸色，不用在累极了的时候还要哄一下谁，这日子不能更自由了，棒呆！ 反思这半年，吃了很多苦，减肥成功了。至少，我觉得再努力一把，我能达到我想要达到的目标。所以，真的下定决心做一件事，无论什么情况下都想要完成的事情的话，肯定是可以完成的。现在想想那一阵一天就只吃早饭的自己都很佩服，下定决心，就没有做不到的事情。 就情感上而言，去年有很多甜蜜，也受了些伤，最主要的是心太累。今年解放了自己，也不知道做得对不对，至少就现在的我觉得，我做得对，之前一段时间还想她俩什么时候闹不和，到时候刘鑫会想起我的好，再一想，也许我只是自己觉得对她好，她却是不以为然呢？她也是松了口气呢？ 规划对于新的一年，我打算再递拎宝好好学习技术，努力成为一个全栈工程师。钱也许重要，但不是最重要的，学到东西，努力在明年春天来换工作能获得15K的工资，这是一个非达到不可的目标。为此，我要为接下来的生活做一个规划： 1 PHP：花俩周时间，把我桌子上那本书全部看了《php入门到精通》。然后再花俩周把海淘和淘喵喵的后台代码搞清楚，努力能自己搭建项目。然后再进行进一步的学习。 2 安卓： 将PDA扫码的代码搞懂。然后将现在的流行框架做个统计，学习源码。 3 JAVA： 从普通的spring,spring mvc,hibernate等框架从源码角度学习。 4 学习方法： 学习是要留脚印才会有意思的事情，学习到一个点，更新一篇博客。 结束今年一定能充实自己！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个王朝的兴衰——明朝那些事儿]]></title>
      <url>%2F2017%2F%E4%B8%80%E4%B8%AA%E7%8E%8B%E6%9C%9D%E7%9A%84%E5%85%B4%E8%A1%B0%E2%80%94%E2%80%94%E6%98%8E%E6%9C%9D%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
      <content type="text"><![CDATA[从知乎上，看见很多地方推荐了这本《明朝那些事儿》，终于买了一套这个书，在阅读器上看到149万字的时候，我的内心大概是崩溃的~~ 不得不说这本书写得确实不错，至少从打开这本书到读完为止，没有哪一个时刻我想弃掉这本书换另外的书看。 幽默的语言是作者的特色，但也有那么几个时刻看着看着眼泪就下来了，比如于谦，比如黄道周…… 我对很多朝代都不是很熟悉，就算是看了易中天的历史系列我还是很模糊。但是看了这本书，看了一遍，我知道了朱元璋如何从一个贫穷子弟到一个开国皇帝，当然，历史文本不是纯小说，他不把朱元璋作为一个人剖析，而是把他作为一个皇帝作为一个开国皇帝进行分析。 不仅仅是皇帝，这本书里基本立场都是基于历史，基本以公正的眼光对待每一个历史人物，会以评价历史的眼光评价，但又不是传统的评价方式，给我很多共鸣。 当然，他书中描写是否属实这种事情我没有去查，但我觉得他没必要作假。 字数很多，故事很多，人很多，连经历的皇帝都很多，所以感慨也比较多。给我最深的感觉还是作为一个普通人，是极为容易被历史的尘土淹没的，人生在世几十年，去世后什么都留不下，后人说起来也不会了解这个人，只是知道这个人是我的谁谁谁，要说外人，就什么都留不下了~ 在历史学家或者书籍中，我们只会被描写为十几亿人口之一，过了几十年之后，什么都留不下了~ 我也不知道想表达的是什么，是想要大作为一番还是享受当下，我也不知道，我也还在困惑…… 2017-10-24更新]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[格非江南三部曲有感]]></title>
      <url>%2F2017%2F%E6%A0%BC%E9%9D%9E%E6%B1%9F%E5%8D%97%E4%B8%89%E9%83%A8%E6%9B%B2%E6%9C%89%E6%84%9F%2F</url>
      <content type="text"><![CDATA[概述这三本书看了很长一段时间才看完，第一部是《人面桃花》，第二部是《山河入梦》，第三部是《春尽江南》。没有三本同时看，按着顺序看的。 从主人公的角度看，第一部第一主角是秀米（陆），第二部第一主角是谭功达，是陆秀米的儿子，第三部的第一主角是谭端午，谭功达的儿子。 人面桃花陆秀米是深闺中的女子，直到她父亲离家才逐渐对世事有了好奇之心，或者说从她父亲离家、张季元的出现才对她进行了刺激，才逐渐的接触这个世界，随着听说张季元等革命党人想要建立的世界、然后见到花家舍，最后回到普济试图自己建立一个乌托邦。 但事实上，这样的乌托邦仅仅是幻想罢了，不管是她父亲想要建立的家家通的长廊；还是张季元等革命党试图使得人人共有所有财产，但人人都没有这个财产；亦或是花家舍那样的家家同面貌都是不可能实现的，确实，小说里花家舍还是建设成功了，家家户户的房子都一样，院子一样，衣服样式一样，但是现实中是不可能建设成功的。不过另一方面来说，这个世界现在是这样的，房子是同样的，没有院子，衣服是爆款~ 衣服、房子、院子只是表面，他更想描述的是人人都要一样，就像借秀莲的嘴巴表述的那样：“她想把普济的人都变成同一个人，穿同样的颜色、样式的衣裳；村里每户人家的房子都一样，大小、格式都一样。村里的所有地不贵任何人所有，但同时有属于每一个人。全村的人一起下地干活，一起吃饭，一起熄灯睡觉，每个人的财产都一样多，照到屋子里的阳光一样多，落到每户人家屋顶的雨雪一样多，甚至就连做的梦都是一样的……” 作为一个读者，你我知道这个想法多么荒谬，但沉浸在阅读中时，你会相信陆秀米这个人真的存在，她真的拥有这些想法，而且是真的在实践这些想法……每每到此时，我就佩服作者，他是真的让这个人、这些人存在了。 山河入梦谭功达的故事已经到第一个五年计划那个时候了，他参与战争，战后当个县长，顶头有老虎（秀米家里仆人的儿子）给他兜着，他极尽的理想化，建水库、建沼气池、最后还想建一个长廊，在当时饿殍遍地的情况下，他做这些真的是让人想不通。 我看完我也没想通，谭功达为什么会有这样超前的想法，作为一个县长，而且没什么威信的县长，有人在写匿名信的情况下，为什么还会被蒙蔽了想法。不过这一部里的男主，我个人觉得是不喜欢的，他是个花痴，喜欢所有的漂亮小姑娘，如果不是白晓娴抛弃他，他就愿意和白晓娴结婚，但是白晓娴走了，他对女主姚佩佩的感觉又上来了，然后和姚佩佩几乎算是表明了，而他明明知道姚佩佩喜欢他；而就在姚佩佩打算辞职时（那时谭功达被罢官了），他却和一个张金花的寡妇睡了，被缠上了……在爱情上，他终其一生都是悲剧，而且是他自己酿成的。 文章从姚佩佩逃亡开始，谭功达辗转到了花家舍。在这里，他要找郭从年，那里有个办事员说的一句话我记忆深刻，“这里，人人都是郭从年”，后面佩佩写信回来，谭功达对她的思念又用了一个话，“姚佩佩是无处不在的”一草一木都是姚佩佩，我个人觉得这两处应该是可以联想到一起的，表达的意思难以描述，但只要把这两处联想到一起，每次都应该有所收获。 这个年代的花家舍有1984的“老大哥”的气质了，每个人都是监视着，而且还有一种比1984更残忍的刑罚，道德审判，所以篮球队长被逼疯，每个人都表情麻木、每个人都监视着其他人，初看花家舍是个天堂，是社会主义的里程碑，近看却是到处都彰显着人性的丑恶，这不是乌托邦，这是瘴气弥漫的迷宫。 春尽江南第三部的谭端午是比较当代的人物了，起码小说的年代是九十年代了。他的人设其实比较平庸，一个诗人，看不出有什么理想，但全文都比较消极，这一点上，其实风格跟太宰治的大庭叶藏有点像，但又没那么深刻，所以说他平庸。 值得一提的是，这一部里面的家玉（秀容）和绿珠描写得还算特别，两个人设都是铺面而来的忧郁，家玉是爱情得不到满足的忧郁，绿珠则是年轻人对社会觉得不对劲而萌生的忧郁。 可能是我阅历太少，我实在是没搞懂这本书到底讲的什么东西。整个人设都很普通，结局家玉一下子变弱，然后癌症，最后自杀，都透着一股莫名其妙的感觉，如果说有什么比较出色的话，那是描述了当代的一种生活状态，不得志、假清高、而实质上胸无大志（谭功达），年轻人浮躁不安，知道社会不对劲，但不知道为什么不对劲，折腾一阵之后还是归于平静（绿珠），爱情的不满足、功利也不满足整个人都透着不满足，明显是强撑着，一旦跨一点就会全部都塌了的人（家玉）…… 结束写读后感的时候，差不多又把这三部曲再次在脑中过了一下这三本书。不说情节，不说配角，主角的形象在心中更是深刻，各自的高低也许不同时候看有不同的评价，所以不做比较。 谈谈这套书表达的东西吧，最主要的还是人性，第一部花家舍的破碎，秀米革命的失败都是人性的贪婪导致，所以，要相信没有利益驱动不了的人类；第二部谭功达的失败、花家舍的阴森夜晚，无不让我对天真这两个字感到心疼，花家舍没有天真，谭功达的天真导致了他的失败；相比于前两部，第三部（其实并没有看懂）则更注重的是感情了，但相比前两部，总觉得没有连起来，差不多是同一片土地上另一辈人的故事。 今天略累了，就写到这了，如有第二遍阅读体验再补充 2017-10-12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[国庆一二三事]]></title>
      <url>%2F2017%2F%E5%9B%BD%E5%BA%86%E4%B8%80%E4%BA%8C%E4%B8%89%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[早就知道国庆人多得一比，但没想到居然有这么多。在出豫园地铁站去城隍庙的时候，出站都要排超级长的队伍。天公作美，下大雨了，这撑伞都撑不怎么开，我的鞋子在半个小时内打湿完了，不过幸运的是天还不算特别冷，鞋子打湿了也不算多大的事情。 终于，和丁君禄见到了，她还是那么瘦，见着还是那么亲切。但其实有种莫名的尬聊，有时候就是一起笑，其实我也不知道在笑什么，但就是很开心。 人很多，但也很开心，大家拍拍照，聊聊天再意淫下兵哥哥（这些怕有些是刚成年），一路笑得很开心。 晚上在一家川湘菜馆吃菜，丁君禄付的钱。我其实有点不好意思，但我又不好表达，只是说下次一定让我请回来。 这一天，街角的兵哥哥们带给我很大的安全感，在街上堵人的时候，甚至有些开心，心情没有受任何一丝影响。不得不提的是，上海的夜景讲真惊艳，特别是白渡桥那边的时候看东方明珠，人民纪念碑，棒极了。 城隍庙一般，值得一提的大概是这里的兵哥哥吧。 第二日，我们跟团去苏州，国定假日去这种小景点真是受罪，人很多，路很小。简直损去了这园林唯一的兴致。等什么时候周末，有兴趣了再去一次吧，不过我觉得估计难，这次受伤太深。但是，接近傍晚做了那个画舫游船，讲真不错，棒极了。 这一天给我最深刻的感受是，景色对人的影响还是比较大的，反正我在景点里面一直兴致缺缺的，在拙政园的时候，保安一直说桥上的动一动，走动起来，完全是伤害园林的韵味。 这一天已经到尾声，在游览人文景观的时候，还是觉得要有点文化才更有感觉呢。 明天去嘉兴走亲戚，7号再更新。 今天已经是7号了。10点15左右到家的，尽管有点点疲惫了，我还是坐下来决定把这几天的玩乐先记录下来，不然后面就忘了。 4号是中秋节，这一日先去嘉兴，然后去台州，因为我和赵梅两个人去，所以幺舅他们是开车来接我的，其实在这异地他乡的，幺舅与幺舅母的热情固然让我感动，但是也有点让我为难。因为我着实不知道带什么礼物去，空手去总是不好的，在中秋节之前，我就提出要去超市，结果每天都玩太晚，超市都快关门了，这教训就是要准备礼物提前准备。 总之，还是到了幺舅娘家里，他们的热情很感人，但相处不知道说些什么，亲人之间也要慢慢熟悉起来呢~ 饭后一个多小时，两点钟。我们就坐上了去嘉兴站的车（幺舅开的），在路上还和另外一辆迎面开来的车堵上了（路太窄了），幺舅都快忍不住自己上手指导那个和我们堵上的那个车了。 终于，经过一个多小时的睡眠，到达了台州，这里的公交居然是3块起步，真是第一次见。那天到赵梅爸妈家里已经7，8点了，听到赵梅第二天要走，她爸妈的脸上都是挂不住的失望。我那会儿有点愧疚，感觉我带着赵梅到处玩，却没有考虑到父母的心情，他的妈妈专门把她的年假放了，准备陪我们玩，但是…… 那一天晚上，我和没有和妈妈打电话，然而到现在我妈妈也没给我打电话，唉，人和人之间的羁绊其实很少的呢，如果我不维护，和谁之间的羁绊都会降得比较低 言归正传，那天晚上从坐下开始，她爸爸就递给我们各种吃的，然后就是一直各种吃，我看得出来，她爸爸是想把他拥有的都给赵梅，赵梅也能感觉到这种心情，然后她和她爸爸之间也有一些互动，真是令人羡慕。 第二天，5点钟就起来了，起来她爸爸已经去上班了，他4点半就去的，我不知道他是怀着怎么样的舍不得去上班的，但是他那浓重的父爱，以及对我爱屋及乌的子侄女之爱让我很感动。感动是一回事，大人的不会表达也是一回事，他的语气貌似有足够的权威…… 到了杭州，飞快的放了行李到了马塍路的外婆家吃的午饭，不得不说，我们和本地人是有很大的口味差别的，比如，这红烧肉甜腻过了，茶香鸡过于油腻了，肉质略柴，还有一个汤也是很难下口的那种，最后，居然只有一个蛋黄黄瓜还可以，一顿饭吃得真是，然后骑自行车去了西湖断桥残雪。不得不说，骑自行车上路其实就是一个克服自己恐惧的一个过程，我会骑车的，只是害怕上路，这一天克服自己的害怕然后上路了，我觉得以后我也能继续努力呢~ 到了断桥残雪，人如预料中的多，我们走到了白堤的一处，赵梅说要上厕所，然后我拐进了孤山的景区，这里人烟稀少（在国庆节的西湖是十分少见的），我们走走停停，那里风光独好，湖边长椅或是石头并没有多少人坐着，我随处挑了一个椅子坐下看着荷叶随风优雅的或弯腰或仰首，惬意极了。 赵梅上完厕所回来，我们绕着湖边继续朝着孤山那边走着，景色依然美丽，有绿油油的草坪，有垂下的柳树，还有纪念像，如果仅仅如此的话，我不会重点写这里的，在陈英士的纪念碑那里，我听到一阵二胡的声音，我和赵梅相视一眼，决定寻找这个声音，走啊走，我们爬上了孤山，山上树木茂密，见不着一个人影，我想，发出这声音的不会是音响吧，继续走，终于见到了这个人，大叔很普通，拉二胡的表情很专注，我和赵梅坐在一个椅子上听了一会儿走了…… 我们走了一段路之后，决定看看方向（大体是要朝着坐船的方向才算走对了），结果发现走反了，决定再绕回去，结果发现那个大叔蹲在草丛里，具体在干什么我就不知道了，不过可以大胆的猜想一下…… 孤山的美景不可言说，十分幽静，我很喜欢，那一天之后的游览都比不上那里，就算是坐船，三潭映月也就那样，可能是我们去的时候不是晚上…… 下岸之后，里天黑有点远，看了会儿大妈们跳舞，有个大妈跳舞很有气质，两个年轻的穿西装裤的女人跳的就更别说了，之后去看了下音乐喷泉的位置，椅子已经坐满了人，我们决定去湖滨路那边先把饭吃了，熔鱼餐厅是我在美团随意看到的一家川湘菜，东坡肉、麻婆豆腐、手撕包草等简直美味极了，我和赵梅去吃了两次！！！ 然后就是看音乐喷泉了，其实我没怎么看到，只是陪赵梅看的，看完之后还去逛街！！陪赵梅在HM买了两样东西，那会儿我已经很累很不耐烦了，耐着逛完了之后，终于回酒店了，那里打车很不好打。空车很多，但基本不载人，等了20分钟最后还是滴滴打车的。 那天回到酒店浑身都只有一个字，累，坚持洗完澡，敷个面膜，看会书就睡了…… 第二天又是西湖，早上在酒店附近吃了个早餐，然后找车去西湖那边，赵梅一直劝我骑自行车，我这个人逆反心一向很重，她越劝，我越不想骑，于是决定坐车去，公交把我们带到了植物园站，那里马路旁边的景色就十分好，明明是人多的马路，却有一种很幽静的感觉。我们过马路的时候，有个阿姨听到我们聊天，跟我们搭讪，大概是让我们不要去杨公堤，去九溪十八涧，玩了之后再坐车去个什么塔，然后去哪里看钱塘江，然后再回雷峰塔这边，听她说起来路线十分完美，比我们自己搞的路线好多了，她说她也要去坐车，我们也心动了，就说跟着她走，但是走着走着，那阿姨就试探的问我们喝不喝茶，有没有需要买茶送人的，我和赵梅都说不喝茶，也没什么人需要送茶，然后那个阿姨借口说要上厕所，就让我们自己走了…… 这阿姨是想干嘛的，我觉得后面可以大胆猜想一下，如果觉得仅仅这样还不够的，可以百度“九溪十八涧骗局”。 最后我们还是决定继续之前的路线，走着走着，发现岳飞庙在马路的另外一边，而且过马路的都被拦住了，先其他的不管，我们就决定买冰淇淋（哈哈哈哈，那几天几乎每天一个冰淇淋……赵梅昨天说了好几遍，“今天的冰淇淋还没吃呢”）吃！ KFC的冰淇淋全国统一价，我在南方商城买的和在景区门口买的价格居然是一样的，觉得略庆幸！ 买了冰淇淋，随便走走，拐进了旁边的一个池子里看荷叶（赵梅有一张坐在围栏上，周围都包围着荷叶的就是在那里拍的），一池塘的荷叶，水中央还有一个房子，虽然只有一层，但门窗都很高，可以用想象力猜想一下里面的布局、设计。我们都是哪里人少去哪里，虽然这个园子人本来就很少，然后走着走着发现这里真的很棒。人少、树多、景美、近湖，如果可以，我希望带一本书，在里面找一个长椅，安安静静的看一本书，到了中午随意吃些自带的干粮，再在长椅上睡个午觉……在里面呆一天也不会觉得无聊。 在里面拍了很多照片，也深度的游览了这个地方，看着时间才决定还是往苏堤的方向走。过了玉带桥，到了苏堤上，人果然一下子就多起来了，有种赶集的感觉，体验倒也没多差，至少比苏州棒多了！ 我们沿着湖边，忽左忽右的，有时也走中间的大道，时间已经11点过了，肚子很饿了，但苏堤还很长，看不到吃饭的地方，正好那天带了月饼和好多水果，于是在湖边找个一处石头，对着大概花港观鱼那边吃了起来，吃完了觉得还没歇够，居然还自拍了好久…… 肚子填饱了，惬意感溢了出来，站起来又有兴致继续东看西看了，顺着苏堤走着，随处可见在长椅上打盹的，估计是上午游累了。 我们终于走到了花港观鱼的那一段，吃了根烤肠就进去仔细的看，老实来说，我并没有看到什么鱼，什么花，但也得承认，这里也是个很惬意的地方…… 沿着湖边走着，越往里走越幽静，人越发的少，但也还有那么几个，太阳不小，但大树提供了天然的庇荫，走到一个木地板做的观景台的地方，为了更方便的观景，直接就席地而坐了，我们在这里又吃了苹果和梨子，觉得又想到处看看了，然后继续走着走着，一片片草坪出现在眼前，比在孤山看到的更大更多，人一样的很少，我们找了一处坐下晒着太阳，困意袭上来，我们在草坪上躺下了，躺下来之后就更想睡了，于是决定睡觉，那会已经1点半了，睡到了1点50多，太阳一下子猛烈起来，突然一下子就醒了，睡觉真的是最佳的修养方式，本来中午就疲惫的身躯，睡醒之后又恢复了…… 如果我对花港观鱼的赞叹仅仅是因为睡午觉的话，那是公平的，我们睡醒之后，继续往里走，走到了佳凝、芍药圃这些地方，幽静不能言说，草坪更是一片片，上面还有一处在拍婚纱照，安静而人迹稀少，在里面有很多风景与友好公园（早上去的那边）类似的风景，但是很美，而且很多柿子…… 每次到这种地方，我几乎都舍不得出来，赵梅提醒我们还有后面的行程，然后我们慢悠悠的还是从里面出来了，出来旁边没多远就有个太子湾公园，里面有个大风车的建筑物，一片大草原，个人觉得适合烧烤，可惜我们不是去烧烤的，所以觉得没多大意思，稍微看看就出去了…… 沿着南山路继续走，走到了雷峰塔，之前听说爬雷峰塔是要买门票的，原来爬山那里就需要门票了，那个坝子里太多的人坐在那里休息，买票的地方也挤了很多人，决定不看了，直接去柳浪闻莺，西湖旁边在哪都人多（苏堤那里还好），我们本来打算坐在一个亭子（卖东西的旁边）看夕阳，奈何时间还太早（3点半），天气不给力（太阳被乌云挡住了），坐了一会儿之后还是决定继续往柳浪闻莺的方向走，我记得这一节的湖边在清明节是很美丽的，花儿很多，太阳也很美好，在傍晚顺着河边走，可以拍到很多夕阳的照片…… 走着走着，偏离了湖边，我们走着偶尔人多偶尔很少人，有时候有旅行团。 但是在柳浪闻莺的那个标志（一个门，上面写的柳浪闻莺）附近那里人不算多，天也快黑了，游玩的兴致没有了，打算去河坊街找吃的，就沿着对面的那条街进去，走个几百米就到了。 表示这里的小吃的太难吃了（上次去的时候还可以的），夜景也没清明节的时候好看，决定还是去吃正餐，查了下，离昨晚去的那里有一公里多远，就决定就近找了一家，美团评价特别好的小娟杭州菜馆，味道之难吃超乎想象，点的套餐，唯一能吃的就只有土豆丝，两个人花一百块吃了一盘土豆丝，西湖醋鱼、东坡肉、叫花鸡什么的，难吃到一种地步，武侠小说害我不浅啊…… 无论多难吃，强迫自己吃饱了，回酒店爬上床就睡着了，然后迷迷糊糊又起来洗脸敷面膜，清醒了些，看了会儿书，11点就睡了。值得一提的是，西湖附近酒店国庆价格几乎都涨了一半，隔音差、房间小、厕所门关不上的房间居然338一晚，凌晨4点钟的时候，一阵敲门声把我们敲醒了，没起身开门，过一会儿他进去了才发现是敲的其他房间的门……十分醉了 第二天，原计划是先在西溪湿地公园游览一圈之后，再去京杭大运河的，结果，简直惊喜…… 早上睡到7点才起床收拾东西寄放酒店并退房之后，然后去西溪，我们坐车去的是高庄入口，一路上人几乎没有，怀疑我是不是进错了地方，买了80块的票，里面福堤上的景色就像路况比较好的农村，流水绿油油的，看起来有点脏，我们一直在找坐车的点，也在找坐船的地方，本来以为西溪就是这样的风景了，然后我们进入了高庄，高庄是个园林，经过苏州的摧残，到这个园林几乎一个人都没有，偶尔有那么几个人也不妨事的…… 高庄这个地方，就像滕王阁序写的“五步一楼，十步一阁”，一个莲池分成了几部分，也有供小孩子玩乐的假山，真的值得一去，我和赵梅都很喜欢这里，但这只是西溪的一小部分，我们只是一个游客，能想象高士奇与他的家人如何在里面生活的，但我们不能在这里生活。 我们走出来遇到一个红学陈列馆，还以为是革命的，有点兴致缺缺的（不是说不爱国，只是觉得这个地方搭配起来怪怪的），但还是走进去看看，结果发现是讲红楼梦的，之后才觉得自己真是白读书了，红学不就是指的红楼梦么？ 看了这些才知道，红楼梦是有原型的，诗社是真正存在过的……如果说看了这个对我的影响的话，是我决定好好看一遍红楼梦了…… 看完出来路还很长，而且很懵逼，不知道要怎么搞，又不想倒回去，只有继续往前走，然后遇到了岔路，茭芦田庄那一圈和绿地的交叉路，我们明明去了两个庵，但还是没找到那个码头（而且那会儿我并不知道那里有个上船码头），于是我们继续回福堤上，此时已经10点半了，看地图上绿堤好远，两个人脚都有点累了，而且没吃早餐。 没办法，还是只有走到绿堤。河渚街附近这里是绿堤，绿堤这段路走了三遍，真的很漂亮，有些地方我们并没有玩，比如采摘柿子，西溪里面柿子树很多，花30块，应该可以在，某个地方采摘的，但是我们没去；比如水下观光长廊，长廊那里可以观鱼，跟在动物园看起来完全不一样，感觉很特别，除了观鱼那里，就是绕那个地方一圈的风景也很美，我个人觉得对得起她这个门票的；还有进入绿堤那一片芦苇，穂子已经黄了，拍照美极了，看起来也美极了，还有很多花儿，很多其他风情就不一一描述了，因为疲惫，并没有那么用心看…… 游玩绿堤出来去河渚街吃饭，那一条街居然是个小吃街，有特产有现吃的，比河坊街好多了。我们在一个豆腐坊一人吃了一碗豆腐脑，30块，在外面可能觉得贵，在景区觉得还能接受。不得不提的是这个豆腐着实可以，我点的川味，赵梅点的五谷，川味辣辣的，爽极了，赵梅那个甜甜的，我吃了辣的再尝了尝她的，觉得还可以，挺温和，她却觉得太甜了。 在河渚街吃了豆腐脑，就着在那个街买的一口酥，吃得有点饱了，但还是没有太饱，又买了柿子，10块8个，我们坐在一个椅子上一会儿就吃了7个，还剩一个没吃完，这柿子太好吃了…… 吃完柿子去做电瓶船，其实我觉得要是一开始游园就来做还可以的，像我们为了观光坐的一圈是不划算的，但是太疲惫了，而且也累了就没下船了，类似观光一样的就用坐船结束了我们的游玩。 下船才3点钟，但是京杭大运河是去不了了，赵梅晚上要回重庆，我回上海了，我还是想我们好好吃一顿再散伙，怕又遇到不好吃的，即使远，我们还是去了熔鱼餐厅（湖滨店）。又一人吃了一份东坡肉，真是好吃！西湖醋鱼，其实味道还可以，清蒸鱼，然后淋上特制的醋汁，但其实闻着略酸，而且不是我爱吃的味道，我还是喜欢酸菜鱼（5号晚吃的）。 之后就是回酒店拿行李，然后各自坐地铁，然后坐火车回家了……行程太急，没来得及和赵梅好好道别，但其实也没什么，路还很长，我们的未来还很多…… 我这个人脾气不好，相处久了赵梅也发现了，她也很迁就我，有时候还会直接指出我，我面子上挂不住就喜欢顶嘴……此去一别，又是小半年才能见面，偶尔也后悔没有见面的时候好好收敛我自己的脾气，又想，本来就是最好的朋友，什么样的脾气她知道的，如果我特意收敛，倒显得我像是跟她客气了……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[认识自己]]></title>
      <url>%2F2017%2F%E8%AE%A4%E8%AF%86%E8%87%AA%E5%B7%B1%2F</url>
      <content type="text"><![CDATA[很多时候，我们不知道怎么表达我们的内心。 但更多时候，我羞于表达自己的内心，因为除了火热的那一部分，还有更多的是充斥的是我们内心的反抗和黑暗。 其实，从前一阵他们动不动要晚上一起看电影开始，我就疲于应付了。 不是讨厌，只是觉得很累。 很多时候，晚上我都有自己的安排，学习，看电影、写文章、写博客。 但是为了不浇他们冷水，我勉强应付几次，但我其实毫无热情。不论是看书还是看电影都是很私密的事情，我喜欢哪本书，说明这本书能描写到我的内心里。分享一本书，相当于把我内心的一部分暴露给别人。 当然，我的这段矛盾很容易得到了解决。 这源于一次旅行，提议的人是A，答应最快的是B，因为资金的原因犹豫不去的人是我。但为了维持友情，我还是妥协了。 这一次的旅行并不愉快，去之前找攻略没有人，预定房间没人。这都是杂事不说了，去的时候我穿了一双新鞋，十分磨脚，这是行程不愉快的一个原因，还有一个原因是这个地方并不适合一次玩完，在行程上的不合理，直接导致了不尽兴。所以，这一次旅行是，钱花了，却感觉什么都玩到。 回程的时候，终于爆发了一场矛盾。我羞于启齿，但我并不是因为后悔。 在轮渡上（本来打算去森林公园，被门票吓回，然后打算早点回去做好吃的），我一直在各种食谱上找，看做什么菜，买什么原料，然后把截图发到了我们的小群里。本来想叫他们看的，看到他们睡着了，就到船停了再叫的，结果，遭遇了两个冷脸。 真是不好意思，我知道你才睡醒，但是我也生气了（其实并不只有这个原因，做轮渡之前，她们都不想挨着我做，也许她们是开玩笑，但我本人就是这么敏感；还有一件就是，坐下之后，我果然没和她们一起，我坐后面，默默A的头，她说，我都离你这么远了还弄我）。 之后我就没理他们直接回家了，很多时候，人们以开玩笑的名义说着伤害人的话，被伤害了还要被说小气。 回到家，我自己做了水煮肉片，虽然只有一个人吃，但其实感觉不差。我做好了不用到处求夸奖，做差了不用觉得羞愧，下次改进便好。 三个人的友情很累，我算是懂了。而且是交往这么频繁的三个人，同吃同住同工作。我累，A累，B也累。 正好附上昨天看书看到的一段话： 也不知道是有意识的还是无意识的限制自己的需要，总之，一种新的保持自给自足的方式出现了，只是这种方式更不靠谱。 为了不危害到远离群体的状态，那就最好都不和任何人或者事物发生太过密切的联系，以防我们离不开他或者她，当然，最好也不要去管别人，这是患者掩盖起来的规则，必须要记住这一点，才能更好地理解出现不靠谱的自给自足方式的原因。 比如，一个人在疏远自我之后，或许会感受到真正的快乐，但是他绝对不允许这种快乐来自于别人；他不喜欢社交活动，但是偶尔和几个朋友共同度过一个夜晚，还是挺快乐的；对于争斗、生育和成功，他总是会选择逃避；对于自己的饮食和生活习惯，他觉得必须要保持一个“度”，这样做既能控制自己的花费，也能控制住对于时间和精力的浪费；生病是他最痛恨的事情，因为这个时候他需要别人的照顾，觉得这对自己来说是一种羞辱；他相信自己的亲眼所见和亲耳所闻，所以，对于某些知识，他总会坚持亲自去学习和理解，而不听信别人说的和写的东西；这种态度确实能帮助他形成珍贵的独立的性格，前提是绝对不能让它发展到荒唐的程度（比如，从来都不向别人问路，就算是在陌生的地方也是如此）。 我觉得这确实是我真实的描写，表达了最真实的我自己，要不说出来，我都不知道我自己是这么自私的人，但是，我这种自私也没害人，也没碍着别人，我觉得这也没什么不好，怪不得这类书籍的意义就是认识自己。 这几天在考虑一个问题，我还要这么无意识的依赖这友情么？ 我想起毕淑敏说的一句话，“ 我喜欢深存感恩之心又独自远行的女人。知道谢父母，却不盲从。知道谢天地，却不畏惧。知道谢自己，却不自恋。知道谢朋友，却不依赖。知道谢每一粒种子每一缕清风，也知道要早起播种和御风而行”。 我到现在也很迷茫想成为什么样的人。总是和A开玩笑说“等挣够钱就回老家种田”，可是我真想回家么？并不，我是并不想在父母身边的。但是不论要成为什么样的人，都不能依赖别人，总是要自己默默努力的，现阶段没找到非做不可的事情，就基于现在的工作目标努力。 没有理想，有很多钱也是可以的。 如果说，朋友之间相处不愉快还要强求，欺骗自己。我觉得这是在对自己的不负责，也是把别人当傻子看。 ，]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查询统计12个月 要有12条结果]]></title>
      <url>%2F2017%2F%E6%9F%A5%E8%AF%A2%E7%BB%9F%E8%AE%A112%E4%B8%AA%E6%9C%88-%E8%A6%81%E6%9C%8912%E6%9D%A1%E7%BB%93%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[最近在做合同管理的相关需求的时候，有按年查询类型进行统计的，也有按年然后还有类型还有月还有公司进行查询，维度有点多。 通过分解之后，每条的sql说起来也不是很复杂。 要实现的折线图是这样子的：//插入一个图 思路是根据公司查询这一年每个月签订的合同数，这个月没有的时候也要显示为0 就像合同类型的统计一样，用合同类型的常量表进行左链接，可以得到这样类似的结果：//插入一张图 然后我通过我的sql：//插入sql代码 得到的结果是这样的：//插入一张图 这不是我想要的结果，所以我开始天马行空的想了几下解决方案： 建一个表专门存1，2，3，4，5，6，7，8，9，10，11，12这样几条数据，然后跟我的合同表进行左链接，这样可以达到效果。 然后我请教了组长，组长说是没有必要的。说要给我想解决方案，然后他给我了一条sql(真是辛苦他了，我下班就跑了，他一个人在那写的)：//插入一段代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[下站实习感想]]></title>
      <url>%2F2017%2F%E4%B8%8B%E7%AB%99%E5%AE%9E%E4%B9%A0%E6%84%9F%E6%83%B3%2F</url>
      <content type="text"><![CDATA[7月18号去下站点了，就是昨天，我见到了以前故意没有看见的苦涩。 6点整，起床收拾。6点半在楼下等杨亚鹏（站点负责人，之前打电话的时候约好的）来接。后面在2号门，见到了这个人以及他的车。老实来说我有点哭笑不得，我以为像家乡那样的摩托，坐上去就可以。但没有想到是送快递的那种，电动车屁股的那部分是钢筋弄的，上面放了个纸板给我坐（我默默庆幸没穿什么短裤裙子之类的）。 经过20几分钟的电动车程，终于我们到了站点（那站点离家不远，所以其实也是平常我收快递的点）。 到了站点，听说我是递拎宝的，好多人给我说这APP越来越差了，然而没卵用，我没用过这APP，甚至我干的活儿跟APP没半点关系（虽然我也是写代码的），我默默的听他们说，然后把这些记在手机上。 然后又被主管叫进去吃早餐了，那是他提前买好的。我有点左立不安，因为快递员们在外面的呢，他们吃早餐了吗之类的，我慢吞吞的吃了几口稀饭，吃了两口饼，然后就早会了！ 负责人打开录像机开始讲话，后面换了个方向站，我以为该我说了（事实上不太能听懂杨亚鹏说的话，瞎蒙），我特么误会了，他换了个方向又开始说，替站长说，好尴尬。 然后终于轮到我了，杨亚鹏叫他们解散了，让我随便说，我就说了下当面付，后面又开始讨论APP的垃圾之处了（很无奈）。 在那里闲聊了会儿，感觉还挺开心。早上的快递车来了，8点过了。（怎么越说越成流水站了~~） 他们在扫码，分拣。我搭不上手（矮，力气也不多），就坐在外面的看他们搬，不给他们添乱是我最大的帮助。 搬完之后就要开始送了吧，负责人问我和什么水，我叫了矿泉水，然后他又开着接我的车去买水了，快递员们喜欢和脉动，也有的喜欢和康师傅的茶，还有一个师傅要喝冰啤。 喝了水，他们又是开始扫码，准备派送。我进屋吹风扇去了，看了会儿。 中午派送完一趟回来装快递的人回来了，有个师傅（喝冰啤那个）拿着饭在吃，问怎么用冰啤吃饭，“不喝啤酒吃不下啊，吃不下就没力气啊”，他边说边吃，旁边还有人开玩笑，感觉很有生机。 走到门外，有两个人也在说话，那个老一点的说，“不怕苦，就怕苦不到钱”。在快递员这个有老有少的群体里，年轻人好奇我的工资，中年人喜欢开玩笑。 他们是很苦的人，但是是城市必不可缺的一群人。我不知道自己是不是这个城市必不可缺的一群人。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[毕业了]]></title>
      <url>%2F2017%2F%E6%AF%95%E4%B8%9A%E4%BA%86%2F</url>
      <content type="text"><![CDATA[2017年7月18日记2017年6月28日领到了我人生中第四本毕业证，大学本科毕业证，也就是说我大学毕业了！ 临近毕业的时候，我感觉到一种平静，一种解脱的平静。我们宿舍的关系一直不好，也就是今年5、6月份临近毕业的时候，大家相互忍耐，终于要毕业了。 现在是2018年7月18日。刚好毕业20天的日子，领了毕业证就马不停蹄的往上海走，不是为了其他，仅仅就是为了钱罢了（毕业之前做手术，出去玩用了比较多的钱，临走之前还问我妈妈要了几千块，家里打算弄卫生间，所以还是希望自己能早日独立）。找好房子之后就上班，下班就懒下来了，整日整日的看看小说，或者看些博客。所以，本该毕业就写的博客嫩生生的拖了20天。 言归正传，刚毕业的感受如下几点： 首先是毕业之后同学的联系：跟班级同学、实验室同学的联系几乎没有，跟室友，断了联系的李乐不说，张苑苑偶尔联系下微信，郑阳不联系（追求不同）。 其次是和大人的沟通，可能是因为我妈知道我是下个月底才发工资的原因，我妈妈我叔叔还会时不时问我需不需要钱。 然后是自己的心理状态，毕业了，听的歌还是那些，爱好还是那些，甚至到之前的单位上干的活儿还是那些，甚至还觉得我应该有个暑假的，但是清醒过来知道自己已经没有了，没有暑假了，在离家几百上千公里的上海上班，住在两人间，吃的大多是自己家里烧的东西。 朋友之前的关系，几乎还是之前的关系网，住一起的人还是那些，玩儿得好的也还是那些。 工作能力：太久没写代码，好多东西都忘了。之前为面试准备的一些东西，几乎记不得了（更主要的原因是复习的是Android，做的却是Java）。现在正在慢慢拾起来，技术是我这样的人安生立命的资本，在以后的新项目中或者是以后跳槽都是实践新技术的最佳经验。 现在的目标：之前看了全栈工程师，说全栈几乎都是为了创业。我只是为了满足自己的好奇心，我对所有的技术都好奇。好奇爬虫、好奇搜索殷勤、好奇浏览器、好奇android系统、好奇spring架构。现在的目标就是好好把java Web做好，android不要忘记，学一些C++/c的语法，并且寻找实践。最近期的目标就是希望自己做出一个产品。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记5月22晚做的一个梦]]></title>
      <url>%2F2017%2F%E8%AE%B05%E6%9C%8822%E6%99%9A%E5%81%9A%E7%9A%84%E4%B8%80%E4%B8%AA%E6%A2%A6%2F</url>
      <content type="text"><![CDATA[昨晚做了一个梦，梦的男主角是个大概很有范的厨师，我大概死缠烂打了很久才追上他。后面居然意外发展到李乐出现了（大概是昨天李乐回来了，所以会梦到她），为什么出现我也不知道。梦的结尾处，那天下雪了，我们要出去吃饭，我先出去探路，遇到了男主他爷爷，他爷爷似乎很衰弱了，我撑着他走着，走着突然他就没有力气了，然后两个人一起摔倒地上了。给男主打了个电话~然后就醒了。 梦的内容很长，但说起来却感觉很短，我还记得初醒时我内心澎湃的那种感觉，羡慕又甜蜜。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[养伤两周整]]></title>
      <url>%2F2017%2F%E5%85%BB%E4%BC%A4%E4%B8%A4%E5%91%A8%E6%95%B4%2F</url>
      <content type="text"><![CDATA[回重庆之后都没写过博客，不是没时间，而是太多情绪涌上心头，造成的就是无尽的空虚，然后就是懒惰。 回重庆之后的前两天，各种吃喝，然后去了姨妈那里，然后就是收文件，再然后就是去医院挂了个号，再然后就是回家待了两天，其实我妈妈住那里环境真的不好，睡的两天都没睡好。然后就是回綦江去见了赵梅。 吃了午饭基本又直接回重庆了，重庆要说有什么特别吸引我的话，那就是宿舍，我的宿舍感觉像我的家一样，其他的任何地方都不能带给我这种感觉。 有的人，平时感觉有多好，但真的有事的时候，她躲得远远的；而有的人平时感觉悄无声息的，但听说有事的时候，就是一言不发的站到你身旁。 李萍明显是后者，她从我在花溪医院照核磁共振开始，之后几乎每次去医院都有她陪着。在住院那段时间，我还没动手术的时候就陪着我，讲真的，如果这件事落在别人身上，我是做不到这样的，更让我感动的是她在我出院之后还被我随叫随到，我不善于表达，不知道要怎么表达我的感动于感激，希望她一生平安顺遂，让我只有送红包来表达这种感激。 离我做完手术已经整整两周，劳动节的时候，做了一个梦，梦到梅青松了，我心里很久以前的小心思又开始萌芽。 有的时候，刻意做某件事给某人看的时候，有可能别人根本看不到，你要直接的告诉他才行。我刚回重庆就发了说说，为什么？还不是因为我想说他刷下空间就能看到我回来了的消息。我发了好多条说说，别人都没看到。 劳动节的时候用那个梦壮了胆子之后早上起来就给梅青松发QQ，说的什么忘了，反正就是胡乱搭上了一句话，然后接下来都主动的找他聊天什么的……几天都是春心萌动的那种状态。 我很早就大概知道自己是喜欢他的，因为有人找我的时候，我总是想起他，我如果不是单身了，我就没资格了，我大概是在等他吧。但其实他只是我一个最普通的同学。 前两天聊天的时候，他说要来找我耍，我希望他来，但我并不希望别人来。我没问太多，怕暴露了什么。那天我从早上起来等到下午都睡着了都没找我。下午快晚饭的时候来了，我心里一喜，但是我去接的时候，邓伟也来了……我很感激邓伟来看我，但是我心里还是有点失落，因为希望是他一个人来。希望落空了总是有些难过的，那天我整个人表现得差极了，看见他们的水果我也不知道说什么，我脚不方便，不能给他们倒杯水，好多好多都不能表现好。 离他来看我已经是两天之后了，中间找他聊了一次天，他在实验室配试剂，不好打扰，之后就找不到话题去找他了。 而且，找他做什么呢？他毕业在重庆，我毕业要去上海，所以我能做什么呢？我不应该再打扰他了。]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F%E8%AE%B02017-3-24%E6%97%A5%2F</url>
      <content type="text"><![CDATA[title: 记2017-3-24日date: 2017-03-24 15:29:11 tags:还有一周就要回学校进行毕业设计了。留在手上的任务还有一个！比起其他一起进来的同事，我的任务太少了，我知道这种时候应该感叹有了自己学习的时间。但是我不是项目经验极为丰富的人。所以我的意思是我想要我的工作更饱和一点。 以前还是在下班前都有活儿干的，现在有活儿来找组长，组长也说没人了，不要活儿。我其实想说我能做，但是我要这样吗？ 我闲着没事的时候就在想，我来上海是因为想要学习更加前卫的知识，托福，来了之后学了点flex，但我本人觉得这个东西要是真的那么好的话不会到现在为止几乎没什么人用了。我想要更多的活儿，想要成为核心的成员。 今天和他聊天，说起想要回重庆了。其实我想回去的理由很多。比如我可以在重庆上班带我弟弟上学，比如我可以去找他玩，然后培养下感情，比如我有很多朋友都在重庆，我如果在重庆，不会错过我妈妈的生日，不会错过每个朋友的生日。 在这边，除了同一间屋子的那四个人，再也没有其他朋友了。是，我喜欢看书，书籍是我的朋友。 还有几天就要回重庆了，我希望回到重庆再去找一下工作。 今晚带电脑回去打算开始投简历了，不管是android还是java都可以。但复习还是复习android吧。毕竟这个是我喜欢的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[追风筝的人]]></title>
      <url>%2F2017%2F%E8%BF%BD%E9%A3%8E%E7%AD%9D%E7%9A%84%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[第一遍22号的时候，我上班都不是很专心，边看这本书边做一些无关紧要的事情。这本书一遍只能懂最皮毛的东西，就像《摆渡人》那本一样，昨晚随意读读才知道其实前面已经很多伏笔。 嫉妒是毒药。阿米尔对哈桑的嫉妒，嫉妒他得他的父亲的爱。所以在哈桑承受耻辱的时候更快的说服了自己不去救他。 阶级是一堵墙。因为哈桑是扎哈拉人，所以阿米尔在有其他人一起玩的时候从来都不叫上哈桑，他的内心也还是看不起他，在看着哈桑遭受暴行时告诉自己：他只是个扎哈拉人。 死，所以感情更美好。哈桑死了，伴随着阿米尔对他的愧疚死了。然后再知道哈桑是他弟弟的时候似乎也没那么不可接受，因为哈桑已经死了，所以对他的愧疚也敢于面对，也敢把最丑陋的自己说给妻子听。死亡也是有滤镜的，因为这个滤镜，死去的哈桑变得格外的美好。 为你，千千万万遍。这句话总共有三个人说过，这句话到底是什么意思，表达深沉的爱，还是仅仅属于哈桑和阿米尔的话还是阿富汗的通俗的话。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[要张记性]]></title>
      <url>%2F2017%2F%E8%A6%81%E5%BC%A0%E8%AE%B0%E6%80%A7%2F</url>
      <content type="text"><![CDATA[我大概是个很玻璃心的人，所以，别人稍微语气重一点，或者说什么扎心的话我就受不了极了。但是我不是小公举，就算是小公举也还有很多其他的小公举扎心，所以其实没什么人会不被扎心（像我这样的人在古代当皇帝就是一代昏君呀）。扎心的话不可避免，但自己的不开心可以避免。 越是觉得重要的人说话伤害值越高，这是很明显的，所以我要做的就是把别人在我这儿的重要值降低，或者他们依然还是有点重要性，但是她们已经吸引不到我的注意力。 对的，我的招就是转移注意力。如果把注意力转移到不会说话的东西，比如书，比如音乐，比如偶像再比如其他的东西身上，这样渐渐地就不会受到伤害了吧。 girl,给自己长点记性，为什么人有两个耳朵两只手，而只有一张嘴，就是说要多做多听，少说，要说就说在点子上。又问谁不会讨巧呢？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[同时运行两个tomcat]]></title>
      <url>%2F2017%2F%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E4%B8%A4%E4%B8%AAtomcat%2F</url>
      <content type="text"><![CDATA[修改端口等操作要到tomcat的conf目录下的server.xml去进行：如果只是修改tomcat端口的话只需要修改这个节点：1234567891011 &lt;Connector port="8282" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;``` 但是要是同时跑了两个tomcat的话必须看两个tomcat是不是在同一个端口上的，这个说的是服务器的端口，看这个节点：```xml &lt;Server port="8009" shutdown="SHUTDOWN"&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JFinal学习之——Demo2]]></title>
      <url>%2F2017%2FJFinal%E5%AD%A6%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Demo2%2F</url>
      <content type="text"><![CDATA[概述今天是美妙的星期天，然后下着雨，然后去买药了，感觉人生十分萧索，然后我觉得只有学习才能让自己充实一点，然后我就下定决心今天JFinal这个东西全部弄完，所以这一篇是十分粗长的一篇。 话不多说，进入学习，目录如下： 路径说明 路径说明finalView = baseViewPath + viewPath + view上面的公式是指整个Jfinal路径需要三个值来决定，首先说明三个值：baseViewPath是图上的那个： 然后是viewPath: 当Route.add方法只有两个参数时，第一个参数为ViewPath,三个参数时认为第三个参数是viewPath; 最后是view：this.render(view); 需要说明的是：当View以/开头时，是绝对路径，就是说整个的Final路径只由view决定。 然后分为两种种情况： controller中的方法访问路径由方法名与controllerKey决定；或者在方法上加上注释：@ActionKey(“/login”) congtroller中的方法中this.render(view)是指跳转到某个路径，不论是绝对路径还是组合路径，都要在WebRoot【并不是webInfo下】目录下有相应的路径的文件， 总结： JFinal的文件路径配置这一块十分的灵活，不依靠注解；基本路径，controller路径，文件路径分明，但我想使用习惯了之后反而会更加喜欢直接用绝对路径； JFinal虽然无配置文件但是必须要继承一个JFinalConfig的类，这有点像监听器一般；而且Config的配置新手必须对照着文档来，有时能很快看懂是干啥的，是否必要等。 java中Render对应的路径是WebRoot下而不是在webInfo下，这导致一个问题，文件的安全性，通过文件路径也能访问到对应文件，而不是spring那样把页面文件放在WEBINFO下，在java中跳转，获得安全性； ————-这是今天没写完的分割线——————– Jfinal的路径是十分方便的，index方法是]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我不是我觉得最亲近的人的最亲近的人]]></title>
      <url>%2F2017%2F%E6%88%91%E4%B8%8D%E6%98%AF%E6%88%91%E8%A7%89%E5%BE%97%E6%9C%80%E4%BA%B2%E8%BF%91%E7%9A%84%E4%BA%BA%E7%9A%84%E6%9C%80%E4%BA%B2%E8%BF%91%E7%9A%84%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[以前在看小说的时候，最是喜欢看男主喜欢上了女主，而女主却是感觉一般般。 有时候朋友之间也是如此，你把她当最好的朋友，然而你其实只是和别人一样而已，她不会因为你的喜好有所忌讳，说得遮羞一点叫不体贴，说得真实一点其实就是泯然众人，甚至还比不上别人。 这种努力有用吗？ 我也不知道，只是努力太久了也没什么差别的时候，还是算了吧，并不需要太多亲近的朋友，反正整个大学就那么浑浑噩噩的过了，最后一两年交的朋友有什么要紧呢？ 反正从大一的时候就最亲近的朋友不也没把你当最亲近的么？时间是最残酷的东西，会教你看清所有，看清所谓的朋友这种关系，看清人与人为什么而连结在一起？ 昨晚跑步的时候我一直在想，我是否强求了别人？我为什么要负气暴走？ 大概我觉得我真的不需要太亲近的人，越亲近就越有占有欲。如果当做最普通的室友的话，其实就会好很多吧，对整个宿舍的人都好。 然后什么叫最普通的室友关系呢？ 做饭严格执勤 上下班碰巧就一起走，不碰巧也不必等 减少肢体接触 减少思想交流 但要怎么不着痕迹的疏远呢？ 有意识的一个人走一排，不和别人排着走，不会有肢体接触 晚上睡觉的时候靠边上睡 在聊关于内心的时候不要说话，拿着手机自己玩，不听不说]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JFinal学习之——Demo1]]></title>
      <url>%2F2017%2FJFinal%E5%AD%A6%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Demo1%2F</url>
      <content type="text"><![CDATA[正文之前许久没有学习新知识了，之前是做安卓的，对java后端其实也没那么了解，只是算是会用，今天任务差不多做完了，在下班之后学习JFinal新框架。 百度百科以及官网首页的那些优点我就不说了。直接开启代码人的第一课，配置第一个Demo; 正文目录： 新建项目 配置web.xml 第一个Controller 配置Config类 运行 新建项目myeclipse中新建一个web Project项目，没有自动生成web.xml文件的点击两次next之后勾选生成web.xml; 将jfinal-3.0-bin-with-src.jar放入lib文件夹下。 第一个Controller新建的controller一定要继承Controller类，然后index方法里面的内容可以省略方法名就可以访问。 12345678910111213141516public class HelloController extends Controller&#123; public void index() &#123;// renderText("Hello JFinal world"); this.render("/index.jsp"); &#125; public void sayHello() &#123; String userName = this.getPara("userName"); String sayHello = "Hello " + userName + "，welcome to JFinal world."; System.out.println(sayHello); this.setAttr("sayHello", sayHello); this.render("/hello.jsp"); &#125;&#125; index.jsp:1234567891011head略&lt;body&gt; &lt;form action=&quot;hello/sayHello&quot; method=&quot;post&quot;&gt; 请输入您的名字： &lt;input type=&quot;text&quot; name=&quot;userName&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;确定&quot; /&gt; &lt;/form&gt;&lt;/body&gt; hello.jsp:123456head略 &lt;body&gt; &lt;p&gt;$&#123;sayHello&#125;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;$&#123;basePath&#125;/&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 配置Config类me.add(“hello”,HelloController.class)这句的意思就是把HelloController映射为hello。 me.setViewType(ViewType.JSP);这个不设置的话会被当做普通文本来输出； 12345678910111213141516171819202122232425262728public class DemoConfig extends JFinalConfig&#123; @Override public void configConstant(Constants me) &#123; // TODO Auto-generated method stub me.setDevMode(true); me.setEncoding(&quot;utf-8&quot;); me.setViewType(ViewType.JSP); &#125; @Override public void configRoute(Routes me) &#123; // TODO Auto-generated method stub me.add(&quot;hello&quot;,HelloController.class); /* 将”/hello”映射到 HelloController 这个控制器 通过以下的配置， http://localhost/hello将访问HelloController.index()方 法 而http://localhost/hello/methodName 将访问到 HelloController.methodName()方法 */ &#125; //其他不重写的方法略 @Override public void configHandler(Handlers me) &#123; // TODO Auto-generated method stub me.add(new ContextPathHandler(&quot;basePath&quot;)); &#125;&#125; 配置web.xmlweb.xml中的要把之前的Config类配置进去： 12345678910111213&lt;filter&gt; &lt;filter-name&gt;jfinal&lt;/filter-name&gt; &lt;filter-class&gt;com.jfinal.core.JFinalFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;configClass&lt;/param-name&gt; &lt;param-value&gt;demo.DemoConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;jfinal&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 运行放入tomcat中运行即可。 总结学习的时候，有人说直接给我一个项目看着学得快点，然而并没有直接给我；还有人说不要花时间学，要用的时候再去学就行。 我不喜欢在我学东西的时候有这些言论，所以一直学东西就是悄悄的学。 不管怎么，学习都是自己的东西，等东西不够的时候去学，那我何不一切了然于胸，等用的时候得心应手呢？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何用一个辅助键值对map将一个Map转为另一个Map]]></title>
      <url>%2F2017%2F%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E4%B8%AA%E8%BE%85%E5%8A%A9%E9%94%AE%E5%80%BC%E5%AF%B9map%E5%B0%86%E4%B8%80%E4%B8%AAMap%E8%BD%AC%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AAMap%2F</url>
      <content type="text"><![CDATA[在拉单的时候遇到这么一种情况，我们拉取的一个Map里面，好多的建和值，但基本和我们的键值对应不上，这个时候必须一个一个转换，显得代码很长，很不利于阅读； 然后我们组长就跟我提是不是能写一个工具类来做一个统一的转换； 暂且我只考虑Map与Map有嵌套，不考虑List的嵌套： 整个代码的流程如下： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 package com.ewin.util;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;/** * @author liuqun * 把不同Map里面的值用辅助键值对Map转移到一个固定的map中 */public class LaDanUtil &#123; /** * 方法简述： * @param keyMap * @param data * @param resultMap * @param parentKey * 时间：2017-3-7 * 作者：刘群 */ public static void deal(Map keyMap,Map data,Map resultMap,String parentKey) &#123; Iterable&lt;String&gt; keyIterable = keyMap.keySet(); for(String key:keyIterable)&#123; //data.get(key);这个值是List类型 //data.get(key);这个值是Map类型,循环这个map的key:dataMap-key,然后获取KeyMap中的dataMap+key Object obj = data.get(key); if (obj instanceof Map) &#123; //map中的map Map datakeyMap = (Map) data.get(key); Map newKeyMap = new HashMap(); for(String filterKey:keyIterable)&#123; if (filterKey.startsWith(key+"-")) &#123; newKeyMap.put(filterKey, keyMap.get(filterKey)); &#125; &#125; Iterable&lt;String&gt; datakeyIterable = keyMap.keySet(); //map中的map的key for(String datakey:datakeyIterable) &#123; deal(newKeyMap,datakeyMap,resultMap,key+"-");// resultMap.put(key+"-"+datakey, datakeyMap.get(datakey)); &#125; &#125; else &#123; resultMap.put(keyMap.get(key), data.get(key)); &#125; &#125; &#125; public static void main(String[] args) &#123; Map keyMap = new HashMap(); Map data = new HashMap(); Map resultMap = new HashMap(); keyMap.put("ID", "BILL_NO"); keyMap.put("Name", "BILL_NAME"); keyMap.put("contact", null); keyMap.put("contact-RECEIVE_ID", "RECEIVE_ID"); keyMap.put("contact-RECEIVE_Name", "RECEIVE_Name"); keyMap.put("contact-addr",null); keyMap.put("contact-addr-province","RECEIVE_Prov"); keyMap.put("contact-addr-city","RECEIVE_City"); data.put("ID", "11111111"); data.put("Name", "张三"); Map map1 = new HashMap(); map1.put("RECEIVE_ID", "222222222"); map1.put("RECEIVE_Name", "李四"); Map map2 = new HashMap(); map2.put("province", "浙江"); map2.put("city", "杭州"); map1.put("addr", map2); data.put("contact", map1); String parentKey = ""; deal(keyMap,data,resultMap,parentKey); System.out.println(resultMap); &#125;&#125; 输出的结果为： 12 &#123;RECEIVE_Prov=浙江, BILL_NAME=张三, RECEIVE_City=杭州, RECEIVE_Name=李四, BILL_NO=11111111, RECEIVE_ID=222222222&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sql优先级]]></title>
      <url>%2F2017%2Fsql%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
      <content type="text"><![CDATA[年前的时候就被分配改了一个bug，导致出库交运出现“第一目的公司错误，请重新导入”，一步一步发现是sql语句没有写完善，然后组长跟我说是因为没有对类型进行筛选为公司。然后就辣么酸爽的升级了3次都没成功。 升级第一版本之后sql语句的方法是这样的： public static String isCompanyInfo(Map newMap) { StringBuffer sql = new StringBuffer(); sql.append("select O.OFFICE_NAME MATCHING_COMPANY, O.OFFICE_ID COMPANYID"); sql.append(" from P_ORGANIZATION O "); sql.append(" where O.ABBREVIATION = '" + newMap.get("COMPANYINFO") + "'"); sql.append(" OR O.OFFICE_NAME = '" + newMap.get("COMPANYINFO") + "' "); sql.append(" and O.B_ENABLE = 1 "); sql.append(" and O.TYPE_CODE = 0 "); logger.info(sql.toString()); return sql.toString(); } 这个应该的结果是【简写或者全名为某某公司enable为1，TYPE_CODE为0】，但结果查出来的结果是【只要简写为某某公司的】和【全称是某某公司并且enable为1，TYPE_CODE为0】的所有数据。 当然，很多优先级情况都是可以避免的，只要自己记得加括号，不管需不需要，加上就最优先级了。 这是因为AND的优先级比OR的优先级高一些，所以在OR的那个地方被截成了两个条件。通过这个问题来学习SQL操作符。 优先级不同的情况下，优先级高的并且在同一层的会先结合在一起，然后再去连接优先级低的。所以想要跨优先级操作比如先OR再AND,就要加个括号了。 (BINARY,COLLATE) &gt; (!) &gt; (-,~) &gt; (^) &gt; (*,/,DIV,%,MOD) &gt; (+,-) &gt; (&lt;&lt;,&gt;&gt;)&gt; (&amp;) &gt; (|) &gt; (=,&lt;=&gt;,&gt;=,&lt;=,&lt;,&lt;&gt;,!=,IS,LIKE,REGEXP,IN) &gt; (BETWEEN,CASE,WHEN,THEN,ELSE) &gt; (NOT) &gt; ( &amp;&amp;,AND ) &gt; ( ||,OR,XOR ) &gt; ( := ) 操作符优先级由低到高，排列在同一行的操作符具有相同的优先级。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开年勿忘]]></title>
      <url>%2F2017%2F%E5%BC%80%E5%B9%B4%E5%8B%BF%E5%BF%98%2F</url>
      <content type="text"><![CDATA[晟邦物流接口 easyPM上自己接任务 评级职业规划]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring配置解析]]></title>
      <url>%2F2017%2Fspring%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[spring框架用了起码两年了，但是之前一直研究的是安卓那方面，对后台技术就没有做很多了解。现在仅以这篇博客顺便记录学习的过程。目录：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[log4j配置解析]]></title>
      <url>%2F2017%2Flog4j%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[这两日有些无聊，然后又搭了一遍SSM框架，就是spring+spring mvc+mybatis框架，上次搭过一次，与上次不同，这次不是通过一个教程按部就班，而是一点一点的自己构建的。 可能是因为另外学了spring的缘故，然后稍微对整个框架也有了些了解。 这篇文章不是为了搭建框架，而是为了log4j的配置； 这篇文章的目录如下： log4j概述 我的配置例子 配置信息分析 结语 其他相关链接 log4j概述Log4j中有三个主要的组件，它们分别是 Logger、Appender和Layout。 Log4j 允许开发人员定义多个Logger，每个Logger拥有自己的名字，Logger之间通过名字来表明隶属关系。有一个Logger称为Root，它永远 存在，且不能通过名字检索或引用，可以通过Logger.getRootLogger()方法获得，其它Logger通过 Logger.getLogger(String name)方法。 Appender则是用来指明将所有的log信息存放到什么地方，Log4j中支持多种appender，如 console、files、GUI components、NT Event Loggers等，一个Logger可以拥有多个Appender，也就是你既可以将Log信息输出到屏幕，同时存储到一个文件中。 Layout的作用是控制Log信息的输出方式，也就是格式化输出的信息。Log4j中将要输出的Log信息定义了5种级别，依次为DEBUG、INFO、WARN、ERROR和FATAL，当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码，这点实在是方便啊。 我的配置例子1234567891011### set log levels ###log4j.rootLogger =INFO,stdout ### export Console ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.errlog4j.appender.stdout.layout=org.apache.log4j.SimpleLayout#config own packagelog4j.logger.test.springmvc.dao = DEBUG 配置信息分析log4j.rootLoggerlog4j.rootLogger = [ level ] , appenderName, appenderName, … level 是日志记录的优先级,Log4j建议只使用四个级别，优 先级从高到低分别是ERROR、WARN、INFO、DEBUG。 appenderName就是指B日志信息输出到哪个地方。您可以同时指定多个输出目的地。 log4j.appender语法为：12345log4j.appender.appenderName = appender log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.option = valueN 配置日志信息输出目的地Appender,Log4j提供的appender有以下几种： org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 1234[main] INFO com.toogen.log4j.HelloLog4JToogen - This is a info message. [main] WARN com.toogen.log4j.HelloLog4JToogen - This is a warn message. [main] ERROR com.toogen.log4j.HelloLog4JToogen - This is a error message..... 使用log4j.appender.stdout.Target作为输出,可选择普通输出或者作为错误信息输出 log4j.appender.stdout.Target=System.out,意味着控制台输出标准信息 log4j.appender.stdout.Target=System.err输出错误信息 log4j.appender.appenderName.layout org.apache.log4j.HTMLLayout（以HTML表格形式布局） org.apache.log4j.PatternLayout（可以灵活地指定布局模式） org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） PatternLayout采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： %m 输出代码中指定的消息设置方式：12log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - &lt;%m&gt;%n %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n” %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) log4j.logger设置package输出级别,可以设置不同package的日志输出级别，语法为：123log4j.logger.packageName=levellog4j.logger.test.springmvc.dao = DEBUG 其中，packageName为实际的包名，level为日志级别与根rootLogger的类似，只是这个只是设置这个包里面的日志显示的级别。就像案例中test.springmvc.dao包里的DEBUG级别以上都能打印 结语毕竟不是一个API文件，更多的属性运用到的时候百度起来也很容易，到时候补充。平时要多总结，多记录，不然有时候稍稍忘掉就全都忘掉了。 其他相关链接log4j2 使用详解 log4j的使用详细解析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[王伟--81192]]></title>
      <url>%2F2017%2F%E7%8E%8B%E4%BC%9F-81192%2F</url>
      <content type="text"><![CDATA[偶然听音乐，在评论区看见这样一段对话： 81192，这里是辽宁舰，前方空域已清空，我舰将派552.553号双机编队接替你执行海岸巡航任务，15年了，该回家了，81192收到请回答，完毕！ 呼叫81192，这里是海航552.553双机编队，我编队奉命接替你执行海岸巡航任务，请返航，81192收到请回答，完毕！ 81192收到，我已无法返航，你们继续前进！重复，你们继续前进！ 81192并不是王伟的座机，但这已经成为一种保卫国家的精神象征。 我不知道我为什么要流眼泪，机子并没有美机的重，明知不可为而为之是为不智，家中尚有妻儿的他，说下‘我已无法返航’这句话内心在想什么，生命的最后都奉献给了国家。这种家国情怀，可能现在只在军队这样的地方才显得十分明显，我们这样普普通通的学生或者白领或者工人，几乎连国际形势也没关注过，我并不是说这类人不爱国，我们看抗日神剧的时候会不自觉的讨厌日本人，我们看见台独会排斥，我们会在国家有喜事时献上祝福，而我们的国家没让我们这样的工人学生感觉到祖国的危险，我们被保护得太好了，偶尔我也会想，有没有一个时候我能给祖国长点脸，或者有没有一个时候，我能给祖国做点什么。 81192，你在哪里？请立即返航！大家在等你]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记2017年第一周]]></title>
      <url>%2F2017%2F%E8%AE%B02017%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%91%A8%2F</url>
      <content type="text"><![CDATA[2017年的第一周，丢了我的手机，而且组长没有给我安排什么事情，然后我几乎就是自己学习或者说自己玩。 老实来说，这一周没做什么事情，也没学习什么，就是对着新手机玩一玩，看一看小说。我不喜欢这样过，我觉得很无聊。其实我喜欢饱满的工作安排，像前一段时间那样，时不时加个班，虽然辛苦点，但是很充实。 组长现在是太忙了，没空管我们，但是我自己一个人学习其实也是可以有事情做的，这一周没有安排就好好学习spring吧。android也是好久没碰了，慢慢的熟悉顺便把宿舍那个APP写了吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex_java学习]]></title>
      <url>%2F2016%2Fflex-java%2F</url>
      <content type="text"><![CDATA[进入bug项目组，组长说要我们做个小测试，用flex做一个列表显示省市的。后台代码本身并没有什么难度，但是因为是使用flex来做前端，这是完全没接触过的语言，心里有点发憷，但还是硬着头皮研究学习做了一个demo. 学flex对于学过java的人来说没什么难度，对于学过android的人来说更没什么难度；唯一不是很了解的是他的API，然而我们组长很贴心的教我使用myeclipse中的基础使用工具，然后感觉根本不需要API了，哈哈哈，组长万岁！ 首先是我的demo,一个简单的省市的代码,当然，从代码里就可以看出，很多功能并没有实现，只是做了简单的列表展示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;mx:Module xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%" xmlns:ns1="views.common.*" creationComplete="init()"&gt; &lt;mx:Style source="city.css"/&gt; &lt;mx:Script&gt; &lt;![CDATA[ import mx.controls.Alert; import mx.rpc.events.ResultEvent; import mx.rpc.events.FaultEvent; import mx.events.CloseEvent; import mx.collections.ArrayCollection; import com.common.ActionAlert; import com.common.PubFunction; import mx.rpc.http.HTTPService; import com.adobe.serialization.json.JSON; import mx.modules.ModuleLoader; private var objUserInfo:Object=&#123;&#125;; private var loginObj:Object=&#123;&#125;; //可绑定变量 [Bindable] private var serverResponse:String=""; //可绑定变量 [Bindable] public var provinceDataArray:ArrayCollection=new ArrayCollection(); //初始化UI权限 private function init():void &#123; //获取登录用户信息 objUserInfo=this.parentApplication.userLogInInfo; sear(); &#125; private function sear():void &#123; loginObj.USER_NAME=objUserInfo.USER.USER_CODE; loginObj.PASSWORD=objUserInfo.USER.USER_PWD; var srv:HTTPService=new HTTPService(); var params:Object=&#123;&#125;; var obj:Object=new Object(); obj["PROVINCE_NAME"]="重庆"; srv.method="POST"; srv.resultFormat="text"; srv.url="http://localhost:8080/A1_BILL/City/getPrivinceList.do"; params.USER_NAME=loginObj.USER_NAME; params.PASSWORD=loginObj.PASSWORD; params["JSONDATA"]=JSON.encode(obj); srv.send(params); //事件绑定 srv.addEventListener(ResultEvent.RESULT, successHandler); srv.addEventListener(FaultEvent.FAULT, errorHandler); &#125; private function successHandler(evt:ResultEvent):void &#123; var srv:HTTPService=evt.target as HTTPService; var resultObj=JSON.decode(srv.lastResult.toString()); var returnValue=resultObj.returnValue; //刷新角色列表 结果成功或失败情况 if (resultObj.returnType == "ERROR") &#123; ActionAlert.errorInfo("刷新列表失败"); return; &#125; provinceDataArray=new ArrayCollection(returnValue); &#125; private function errorHandler(event:FaultEvent):void &#123; serverResponse=event.message.toString(); ActionAlert.errorInfo("加载列表失败"); trace(event.message); &#125; ]]&gt; &lt;/mx:Script&gt; &lt;mx:VBox left="2" right="2" top="30" bottom="2" width="100%" height="100%"&gt; &lt;mx:HBox width="100%" height="5%"&gt; &lt;mx:ApplicationControlBar styleName="ModAppCtrlBar" dock="true" width="100%" height="100%" color="#000000"&gt; &lt;mx:HBox width="100%" horizontalAlign="right"&gt; &lt;ns1:title_menu id="title_menu" listFlag="true" listLength = "&#123;this.provinceDataArray.length&#125;" barColor="#FA3E3E"/&gt; &lt;/mx:HBox&gt; &lt;/mx:ApplicationControlBar&gt; &lt;/mx:HBox&gt; &lt;mx:HBox width="100%" height="5%"&gt; &lt;mx:VBox height="100%" width="15%" verticalAlign="middle"&gt; &lt;mx:FormItem label="城市" width="100%" fontWeight="normal" horizontalCenter="center"&gt; &lt;mx:TextInput width="100%" id="edtUserCode"/&gt; &lt;/mx:FormItem&gt; &lt;/mx:VBox&gt; &lt;mx:VBox height="100%" width="15%" verticalAlign="middle"&gt; &lt;mx:FormItem label="省" width="100%" fontWeight="normal"&gt; &lt;mx:TextInput width="100%" id="edtUserName"/&gt; &lt;/mx:FormItem&gt; &lt;/mx:VBox&gt; &lt;mx:HBox height="100%" width="15%" verticalAlign="middle"&gt; &lt;mx:Button label="检索" id="btnSearch" click="sear()"/&gt; &lt;mx:Button label="重置" id="btnReset" click="returnReset()"/&gt; &lt;ns1:site_str_search id="siteid"/&gt; &lt;/mx:HBox&gt; &lt;/mx:HBox&gt; &lt;mx:VBox height="100%" width="100%"&gt; &lt;mx:DataGrid id="gdProvince" dataProvider="&#123;provinceDataArray&#125;" width="100%" height="100%"&gt; &lt;mx:columns&gt; &lt;mx:DataGridColumn headerText="编号" dataField="PROVINCE_ID"/&gt; &lt;mx:DataGridColumn headerText="名字" dataField="PROVINCE_NAME"/&gt; &lt;mx:DataGridColumn headerText="拼音" dataField="PROVINCE_PINYIN" editable="false"/&gt; &lt;mx:DataGridColumn headerText="简称" dataField="PROVINCE_SHORT" editable="false"/&gt; &lt;/mx:columns&gt; &lt;/mx:DataGrid&gt; &lt;/mx:VBox&gt; &lt;/mx:VBox&gt;&lt;/mx:Module&gt; 在网络链接的模块 123456789101112131415var srv:HTTPService=new HTTPService();var params:Object=&#123;&#125;;var obj:Object=new Object();obj["PROVINCE_NAME"]="重庆";srv.method="POST";srv.resultFormat="text";srv.url="http://localhost:8080/A1_BILL/City/getPrivinceList.do";params.USER_NAME=loginObj.USER_NAME;params.PASSWORD=loginObj.PASSWORD;params["JSONDATA"]=JSON.encode(obj);srv.send(params);//事件绑定srv.addEventListener(ResultEvent.RESULT, successHandler);srv.addEventListener(FaultEvent.FAULT, errorHandler); 这里面的网络模块与android的网络链接几乎一模一样，实例化，配置地址，配置参数，然后回调，成功或是失败的函数，然后对成功之后或者失败之后进行对应的处理； actionScript对于mxml就像js对于html，然而actionScript是一种介于java和js的语言，java通过import,js通过引入js文件；里面的很多控件像是包装了的easyUi一样，自动装载json数据，在dataGrid中，自动解析json数据，都不需要像之前html一样一点一点拼接。 而其他的代码因为和android太像，根本没什么好说的，更多的就是对控件的熟悉了。 开发的界面如图，与VS开发C#类似的：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于实习项目（合同管理系统）感想]]></title>
      <url>%2F2016%2F%E5%85%B3%E4%BA%8E%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%90%88%E5%90%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89%E6%84%9F%E6%83%B3%2F</url>
      <content type="text"><![CDATA[来上海已经是一个月有余了，在这一个月中有不开心的时候，有想离开的时候，但终究还是坚持下来，成就感还是棒棒的。这一个月对我来说最值得一提的应该是前后整个周期大概20天的这个合同管理系统了。 对于我来说，这个系统就像是我的亲女儿一样，从项目的选定，项目的需求，产品的设计，最终的实现我都有参与。以前在实验室不是没有参与过项目，但是参与度这么高的，让我这么有使命感的还是第一个。 这个项目是作为测试项目还是实际项目，到现在也不是很清楚，但是我们都尽了我们的全力做了我们能做的事情。 前期带着产品运营们走上正轨的那些时间没什么好说的，从开始准备做开发工作的时候，我没有正确的估量到每个人的实力，导致路遥的工作量不饱满，而李开拓的工作因为有难度，导致她根本不会。【tip:正确估量每个人的实力】 准备工作完成得差不多了，中间去浙江出差了一趟，然后回来继续做项目，这时已经要开始设计数据库开始开发了。这一段时间就一直都比较的被动，我已经没办法放心把任务交给李开拓了，大家一起设计了数据库，然后我进行任务的分配，我这时候大概对路遥也了解了，但是要怎么才能让开拓觉得我不是不相信他呢，这就是作为组长的难点了。 才分配任务没多久，李开拓受伤了，然后任务交到了路遥和我的头上。 由于我给自己弄了挺多任务，还有就是李思浩和李洁都还不成熟。导致我事情也比较多，中间经过了两个通宵，终于在展示的时候没有出现大问题。 但是因为李思浩没有准备好，我们组的评分很低。我有自信我们的系统，但是很多时候并不只依靠产品本身就能获得认可。我们的产品没有获得认可是没准备好。 现在是12-30号，已经是过了评比快一个月的时间，我们的系统也试用了好久，也会正式上线。这是比较好的一点。其后又发现了很多的bug也逐步的完善，但还是不健壮。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记一个周六2016年12月3日]]></title>
      <url>%2F2016%2F%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%91%A8%E5%85%AD2016%E5%B9%B412%E6%9C%883%E6%97%A5%2F</url>
      <content type="text"><![CDATA[尽早做了一个梦，很甜蜜很少女的梦，在这个梦里，有个我认不得的少年，他温文尔雅，似乎有着宠溺的眼神，有着包容的心态，有着纵容的行为，我似乎能感觉到他看我的眼神是充满着爱的，似乎我做什么都可以的那种眼神。 早上醒来之后，又想快进入那个梦，但是又害怕梦的风格急转直下，不敢继续睡。 本来是个挺开心的梦，但写着写着又忍不住说到我自己的现状，我不能相信似乎世界上有爱这种东西，因为我本人是如此的冷漠，在内心中一次又一次的计算。 说起来，现在是几乎快要吃饭的中午，我感觉很恶心，也可以说是伤心，因为这种伤心让我感觉很恶心。 原因大概在于一盘饺子吧，我不喜欢别人用我吃饭的饭碗，秋贪图便宜买了几毛钱一个的塑料碗，但是拿我吃饭的碗来做调料碗，我感觉十分不开心。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[遇到的问题]]></title>
      <url>%2F2016%2F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[2016-11-06 GridView的Adapter怎么设置？（GridAdapter继承BaseAdapter,最普通的adapter,还可以试试SimpleAdapter） GridView怎么获取坐标？（得到每个item的宽和高，然后getX和getY，最后通过除法得到X,Y的坐标） 连连看怎么保证绝对有解的？(1.最简单就是一次创建两个,图标,这样可以同时检查他们是否可消去,保证游戏有解.2.) 连连看的难度设置（关卡） 刷新页面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大冰作品]]></title>
      <url>%2F2016%2F%E5%A4%A7%E5%86%B0%E4%BD%9C%E5%93%81%2F</url>
      <content type="text"><![CDATA[从一个人的文字中，其实最能够了解一个人，要是几十万几百万的字都撒谎的话也太难了。 他不是正统的文学人士，他的江湖气息很浓重，身份也是很多重的。 从几本书的文字中可以看到，他对主持这个身份颇不以为然，但让一众读者不理解的是为什么他还要维持这个身份？我猜想了几种可能，也行他希望不要过着一种生活（他说过最多在丽江也只呆15天），若是少了一重身份，也就意味着他的生活相对来说更单调了；也许是他虽然对那个圈子不以为然，但是他对主持这个职业还是喜欢的。 现在很多人骑行拉萨，或者青藏地旅行，我今年坐了几趟青藏线的火车，听到的都是骑行路上的事情，提西藏的反而很少，从他们的只言片语中，几乎都是说各种坑爹的事情。从大冰的大片的文字中，我能感觉到他对拉萨的深深的怀念。 现在有句话叫“因为一个人，爱上一座城”，但我想很多事情不是那么简单的，在一个地方呆得久了，似乎这个地方也成为了一个朋友，一个永远不会离开的朋友。我想，很多老年人的家乡情结应该也是这样吧。 在他笔下更加浓墨重彩描写的是丽江，丽江这个地方哦，被称为艳遇之都，大冰一遍又一遍的说，丽江并不是只有艳遇，而酒吧街的酒吧并不是真正的丽江特色酒吧，在他的故事里，路平、大军、大树都开了酒吧，在我们心中，泡酒吧的孩子都不是好孩子，但是在大冰的小屋里只有啤酒，只有民谣，只有吉他和手鼓，其他的什么艳遇都与它无关。 我还是一个实用主义者，每次看到书中的浪漫主义者一遍一遍犯傻的时候，我都想如果是我怎么怎么，但终究只是如果。我终究还是是个实用主义者，甚至连看书的目的我都不知道是否单纯。 这个世上还是需要很多傻子的，看着看着我甚至是羡慕这些傻子的，连大冰都是羡慕的吧，因为傻，才能纯粹的热爱，因为傻，在被爱或者爱的时候都能百分百的付出，大军卖唱超过150就给妻子买一条裙子，直到衣柜装不下也继续买，她的妻子甚至是在炫耀幸福的让大冰去交大军不要买了，或者买点其他也行，她为他放弃学业，一心跟着他，傻不傻？我认为傻透了，明明可以完成学业之后再爱，但是她是那么义无反顾，最终得到的爱人人羡慕。 这些傻子啊，都是得到了傻福的人。我最终也还是做不到傻傻的过的吧，就算是蠢笨如我，也还是实用主义者。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[first job]]></title>
      <url>%2F2016%2Ffirst-job%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[找工作之后]]></title>
      <url>%2F2016%2F%E6%89%BE%E5%B7%A5%E4%BD%9C%E4%B9%8B%E5%90%8E%2F</url>
      <content type="text"><![CDATA[离找工作开始已经两个月，其实这里面还是得到不少教训。但至少除了拒绝了thoughtworks的面试稍微有点遗憾，其他的真的没什么遗憾了。确实我复习的力度不过，虽说认真看书但也是走马观花，看得不够深入是一回事，看了之后没有融入自己的思考也是一个重要的原因。 不得不说的是，自己到现在为止只有一个offer，弄得自己失去了斗志，书不想看，代码没怎么写，整天就看着动漫，然后心里一片茫然，我记得刚开始的时候，我对自己说，不要管别人，跟着自己的节奏就行。但讲真，我确实是被别人的节奏影响着的。BAT一个不想放过，但一个都没有过，然后慢慢的笔试成绩变好之后，面试也一个不想放过，这种就是完全的广撒网捞鱼，所以到现在一条大鱼都没钓到。 到这会儿，我想问自己，我是想得到明年的大鱼，还是一条鱼都不想放过呢？明年的湖里还会不会有大鱼呢？ 现在是10月22号，我到底该如何做呢？ 恭喜我，我又茫然了，本来以为是已经得到答案才来写博客，但我发现自己终究还是不甘心，所以我要放弃和刘鑫她们一起去上海还是放弃找工作然后安心准备明年的春招呢？ 写在2016-12-30 现在我在上海，在上海递拎宝实习中。有时候找工作跟真正工作真是完全不同的体验，当时信誓旦旦的一定要做安卓（在中国航信面试中问我是否一定做安卓，不惜再面试一次都说的要），但在这里实习时，不是安卓也做了。 其实只要能学到东西，做什么都无所谓，毕竟我不可能过这种生活，做这种工作一辈子，毕竟不是做学生了，以后具体会是什么样，谁都不知道了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读《黑白》有感]]></title>
      <url>%2F2016%2F%E8%AF%BB%E3%80%8A%E9%BB%91%E7%99%BD%E3%80%8B%E6%9C%89%E6%84%9F%2F</url>
      <content type="text"><![CDATA[《黑白》这本书从情节上来看，是讲述陶羊子的从一个小孩，然后爱上围棋并逐步成为棋王的故事。他自小失去双亲，对白有着一种执着，当他把白棋下得极好，收到总督府上照拂的时候被他的老乡齐天勤一举打败并且把他送入他的人生第一个底端，然后他的舅舅也出事了……随后还有几次的大起大落，当他的人生最终归于平静的时候，他还是爱着棋，尽管中间有恨过棋，但最终还是爱的。 当然，一般人不会有这般境遇的。 我大概也喜欢上下围棋了吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[再见，成都]]></title>
      <url>%2F2016%2F%E5%86%8D%E8%A7%81%EF%BC%8C%E6%88%90%E9%83%BD%2F</url>
      <content type="text"><![CDATA[找工作已经接近一个月，从9月5号开始做京东的第一个笔试开始。这最开始的20天（24号以前），基本没有接到任何的面试电话，我知道是我太弱了，原因什么的我已经不想分析了，因为了然于心。 最开始到成都，住在刘鑫的朋友（小兰）家里，在青羊区512成飞小区，这里是成飞集团的地盘，最开始那几天几乎没出过他们的势力范围。其实这个地方还比较好，离得不远的地方有地铁。在这里住的几天，我们买了盆子，买了垃圾桶，买了电饭煲。小兰家里有网络，有电磁炉……很方便，很想好好谢谢她。 这一段日子，回想起来一片模糊，除了复习，除了做笔试，除了做饭吃饭，除了看了一部进击的巨人，我几乎已经想不起来我爱做了什么事情。 在成都，才知道重庆好得让我想念。这里的三轮让我很不习惯，他们不惧任何交通规则，除了穿绿色衣服的交通管制能让他们收敛下；这些三轮有时候会让你觉得很方便，但那天那个阿姨大晚上不认识路带着我乱走，而且还没送我到最终的目的地；但那天早上有个三轮也很让我感谢，那天是去西南财大笔试的一天，自前一天晚上被一个阿姨开的三轮在路上丢下了之后我心里十分的不情愿，但是为了不迟到还是坐的三轮去，这个大叔路上偶尔和我聊聊天，答应送我到财经大学东门5块钱，没出门在异乡的人不会知道一两块钱对你有什么意义。即使就是免了我两块钱，我还是十分感谢。以致于我笔试发挥好得出奇。 面试的详情，我后面再总结。我记得那是18号，微店的宣讲会加笔试，在四川大学江安校区，这个地方离我们住的地方很远，我们三点钟出门，先去项俊超家里拿东西然后再去，打滴滴，走路，坐公交车，打印简历，一路觉得很远很远，终于到达之后（向俊超的伞一下子就被吹坏了……路边卖的真让人的有点不放心呐），有个美女带我们走到了楼下（PS：他们学校真的太大了），晚上回来的时候，饿极了，找个门出去，结果发现校门都关了，下着大雨我们居然是从一个小栏里爬出去的，等到了打的滴滴车上，我觉得我半边都打湿了，但是还是十分的兴奋，因为第一次参加现场笔试。回家做饭吃了已经10点过了。 第二天又接着要去成都电子科大参加经纬中国的联合招聘，是挺多的创业公司，笔试过了就能直接选三家进行面试。路途很遥远，那天放弃了乐视和完美世界的笔试，坐了将近2个小时的车到达了目的地，然后又花了好长时间去找地方（PS：电子科大真的好大啊）；回去的时候比较急，因为想要参加完美世界的笔试，我真贪心呐，我这么说自己。可是啊，不把笔试做了那就没机会参加面试的，可是回来还是晚了，在下了公交等滴滴的时候，我们买了几个馒头那吃，我太多年没觉得吃馒头都是那么幸福的事情了。那时候觉得自己既凄凉又搞；；；；；；；；；笑；；；；；；；；。然后又去买了泡面和速冻饺子晚饭吃得很开心。 这住别人家的时候不觉得什么，后面自己住旅馆的时候才知道生活还可以更糟，然后发现一个人住旅馆才是最遭的。 24号我们回重庆了，因为猪八戒的面试，可是待了一天我又回成都来了，因为小米和越秀集团的面试。 一个人住旅馆真的糟糕透了，因为一个人住，所以要买最最便宜的，最便宜的倒也不是很差，只是觉得很没有安全感。 昨天面试失败，我身体上的疲惫一下子爆发出来，坐过了站都没发现，即使是现在的我，也是极为疲惫，但是前路还很迷茫，我暂时还不能放弃，我只能继续加油。 借用灰太狼的一句话，成都，我还会再回来的，再见！ 写在2016-12-30 没过多久之后，我又去了一趟成都，那是YY的面试，那天上午面试了递拎宝之后坐高铁过去，然后还笔试thoughtworks(思特沃克中国),然后还视频面试了一次今日头条。我其实面试真的挺多了，但没有抓住机会。成都，我回来了又去，但终究什么都没抓住。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[短板]]></title>
      <url>%2F2016%2F%E7%9F%AD%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[硬件加速：什么叫硬件加速？它的原理是什么？ 同步锁和互斥锁。各自分别是什么？在java中怎么使用的？要怎么考虑相关的？ 单例模式的两种模式的优缺点？在考虑多线程时使用哪一个？（饿汉式和懒汉式） 按层遍历二叉树]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用笔试题]]></title>
      <url>%2F2016%2F%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
      <content type="text"><![CDATA[进程间通信：方式一：访问其他应用程序的ActivityActivity既可以在进程内（同一个应用程序）访问，也可以跨进程访问。Activity的跨进程访问与进程内访问略有不同。虽然它们都需要Intent对象，但跨进程访问并不需要指定Context对象和Activity的 Class对象，而需要指定的是要访问的Activity所对应的Action（一个字符串）。有些Activity还需要指定一个Uri（通过 Intent构造方法的第2个参数指定）。 方式二：Content Provider Android应用程序可以使用文件或SqlLite数据库来存储数据。Content Provider提供了一种在多个应用程序之间数据共享的方式（跨进程共享数据）。应用程序可以利用Content Provider完成下面的工作： 查询数据 修改数据 添加数据 删除数据 方式三：广播（Broadcast） 在应用程序中发送广播比较简单。只需要调用sendBroadcast方法即可。该方法需要一个Intent对象。通过Intent对象可以发送需要广播的数据。发送广播并不需要在AndroidManifest.xml文件中注册，但接收广播必须在AndroidManifest.xml文件中注册 receiver（或者动态注册）。 方式四：AIDL服务 服务（Service）是android系统中非常重要的组件。android系统中的Service主要有两个作用：后台运行和跨进程通讯。AIDL的全称是Android Interface Definition Language，也就是说，AIDL实际上是一种接口定义语言。通过这种语言定义接口后，Eclipse插件（ODT）会自动生成相应的Java代码接 口代码。下面来看一下编写一个AIDL服务的基本步骤。 在Eclipse工程的package目录中建立一个扩展名为aidl的文件。package目录就是Java类所在的目录。该文件的语法类似于Java代码。aidl文件中定义的是AIDL服务的接口。这个接口需要在调用AIDL服务的程序中访问。 如果aidl文件的内容是正确的，Eclipse插件会自动生成一个Java接口文件（*.java）。 建立一个服务类（Service的子类）。 实现由aidl文件生成的Java接口。 在AndroidManifest.xml文件中配置AIDL服务，尤其要注意的是，标签的android:name属性值就是客户端要引用该服务的ID，也就是Intent类构造方法的参数值。 Android Service与Activity之间通信的几种方式方式一：通过Binder对象Activity调用bindService (Intent service, ServiceConnection conn, int flags)方法，得到Service对象的一个引用，这样Activity可以直接调用到Service中的方法，如果要主动通知Activity，我们可以利用回调方法。 方式二：通过broadcast(广播)的形式Service向Activity发送消息，可以使用广播，当然Activity要注册相应的接收器。比如Service要向多个Activity发送同样的消息的话，用这种方法就更好。 Activity Service Fragment生命周期Activity Service Fragment Android中view和surfaceview的区别使用的SurfaceView的时候，一般情况下要对其进行创建，销毁，改变时的情况进行监视，这就要用到 SurfaceHolder.Callback. 对于Surface相关的，Android底层还提供了GPU加速功能，所以一般实时性很强的应用中主要使用SurfaceView而不是直接从View构建，同时后来做android 3d OpenGL中的GLSurfaceView也是从该类实现。 SurfaceView和View最本质的区别在于，surfaceView是在一个新起的单独线程中可以重新绘制画面而View必须在UI的主线程中更新画面。 那么在UI的主线程中更新画面 可能会引发问题，比如你更新画面的时间过长，那么你的主UI线程会被你正在画的函数阻塞。那么将无法响应按键，触屏等消息。 当使用surfaceView 由于是在新的线程中更新画面所以不会阻塞你的UI主线程。但这也带来了另外一个问题，就是事件同步。比如你触屏了一下，你需要surfaceView中thread处理，一般就需要有一个event queue的设计来保存touch event，这会稍稍复杂一点，因为涉及到线程同步。 所以基于以上，根据游戏特点，一般分成两类。 1 被动更新画面的。比如棋类，这种用view就好了。因为画面的更新是依赖于 onTouch 来更新，可以直接使用 invalidate。 因为这种情况下，这一次Touch和下一次的Touch需要的时间比较长些，不会产生影响。 2 主动更新。比如一个人在一直跑动。这就需要一个单独的thread不停的重绘人的状态，避免阻塞main UI thread。所以显然view不合适，需要surfaceView来控制。 3.Android中的SurfaceView类就是双缓冲机制。因此，开发游戏时尽量使用SurfaceView而不要使用View，这样的话效率较高，而且SurfaceView的功能也更加完善。 拓扑排序什么是拓扑排序 回溯基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。步骤用回溯算法解决问题的一般步骤为：一、定义一个解空间，它包含问题的解。二、利用适于搜索的方法组织解空间。三、利用深度优先法搜索解空间。四、利用限界函数避免移动到不可能产生解的子空间。问题的解空间通常是在搜索问题的解的过程中动态产生的，这是回溯算法的一个重要特性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class WolfQueen &#123; /** * 一共有多少个皇后（此时设置为8皇后在8X8棋盘，可以修改此值来设置N皇后问题） */ int max = 8; /** * 该数组保存结果，第一个皇后摆在array[0]列，第二个摆在array[1]列 */ int[] array = new int[max]; public static void main(String[] args) &#123; new WolfQueen().check(0); &#125; /** * n代表当前是第几个皇后 * @param n * 皇后n在array[n]列 */ private void check(int n) &#123; //终止条件是最后一行已经摆完，由于每摆一步都会校验是否有冲突，所以只要最后一行摆完，说明已经得到了一个正确解 if (n == max) &#123; print(); return; &#125; //从第一列开始放值，然后判断是否和本行本列本斜线有冲突，如果OK，就进入下一行的逻辑 for (int i = 0; i &lt; max; i++) &#123; array[n] = i; if (judge(n)) &#123; check(n + 1); &#125; &#125; &#125; private boolean judge(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123; return false; &#125; &#125; return true; &#125; private void print() &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + 1 + " "); &#125; System.out.println(); &#125;&#125; 最小生成树参见贪婪算法的Prime算法和Kruscal算法： Prime算法的思想是不断找出边缘中最短的； Kruscal算法的思想是排序所有边，然后将没有形成回路的最小边加入树中，知道加n-1条边。Prime 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static int unReach = 1000;public static int n = 4;public static void main(String[] args) &#123; int[][] G = &#123; &#123; 0, 4, 15, 10 &#125;, &#123; 4, 0, 10, unReach &#125;, &#123; 15, 10, 0, unReach &#125;, &#123; 10, unReach, unReach, 0 &#125; &#125;; boolean[] visit = new boolean[n]; int sum = 0; int[] dist = new int[n]; // 清空生成树，任取一个顶点加入生成树 initVisit(visit); int index = 0; visit[index] = true; for (int i = 0; i &lt; n; i++) &#123; dist[i] = G[index][i]; &#125; for (int i = 1; i &lt; visit.length; i++) &#123; int min = unReach;// 在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树 for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; (min &gt; dist[j])) &#123; min = dist[j]; index = j; &#125; &#125; visit[index] = true; sum += min; // 重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树 for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; dist[j] &gt; G[index][j]) &#123; dist[j] = G[index][j]; &#125; &#125; &#125; System.out.println(sum);&#125;private static void initVisit(boolean[] visit) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; visit.length; i++) &#123; visit[i] = false; &#125;&#125; kruscal: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/** * @author LiuQun * 中心是快速求并法。用一个有根树来表示每一个子集，树中的节点包含子集中的元素； * 根中的元素就被当做该子集的代表树；树中的边从子女指向他们的父母 * makeset():创建一颗单节点的树 * union(x,y):把Y树的根附加到X上（并把Y树删除） * find(x):从包含x的节点开始找到树的根 * */public class Kruskal &#123; public static int n = 5;// 顶点个数 public static int edgeNum = 7;// 总边数 public static int father[] = new int[128];// public static int rank[] = new int[128];//树的等级（层数），优化算法用的，层数小的加在层数大的下 public static void main(String[] args) &#123; // 边的数组 Edge[] edges = new Edge[edgeNum]; edges[0] = new Edge(0, 1, 5); edges[1] = new Edge(1, 2, 3); edges[2] = new Edge(1, 3, 3); edges[3] = new Edge(3, 4, 8); edges[4] = new Edge(1, 4, 7); edges[5] = new Edge(4, 2, 3); edges[6] = new Edge(0, 2, 4); Edge[] result = new Edge[edgeNum]; int count = 0; // 按照权重排序树的边 srotEdge(edges); printEdge(edges); make_set(); // 将图遍历一次，找出权值最小的边，（条件：此次找出的边不能和已加入最小生成树集合的边构成环）， // 若符合条件，则加入最小生成树的集合中。不符合条件则继续遍历图，寻找下一个最小权值的边。 int sum = 0; for (int i = 0; i &lt; n; i++) &#123; // tree中无回路，使用不相交子集和并查算法 if (find_set(edges[i].getFirst()) != find_set(edges[i].getSecond())) &#123; union(edges[i].first, edges[i].second); sum += edges[i].value; result[count++] = edges[i]; &#125; &#125; System.out.println(sum); printEdge(result); &#125; //把每个元素初始化为一个集合 private static void make_set() &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; n; i++) &#123; father[i] = i; rank[i] = 1; &#125; return; &#125; // 采用直接插入排序 private static void srotEdge(Edge[] edges) &#123; // TODO Auto-generated method stub for (int i = 1; i &lt; edges.length; i++) &#123; if (edges[i].value &lt; edges[i - 1].value) &#123; int j = i - 1; Edge temp = edges[i]; while (j &gt; -1 &amp;&amp; temp.value &lt; edges[j].value) &#123; edges[j + 1] = edges[j]; j--; &#125; edges[j + 1] = temp; &#125; &#125; &#125; /** * 从包含x的节点开始找到树的根 * * @param x * 顶点 * @return */ public static int find_set(int x) &#123; if (x != father[x]) &#123; father[x] = find_set(father[x]); &#125; return father[x]; &#125; /** * 合并x,y所在的两个集合：利用Find_Set找到其中两棵树的根， 并将一棵树的根指向另一棵树的根。 * * @param first * x * @param second * y */ private static void union(int first, int second) &#123; // TODO Auto-generated method stub first = find_set(first); second = find_set(second); if (first == second) &#123; return; &#125; if (rank[first] &lt; rank[second]) &#123; father[first] = find_set(second); &#125; else &#123; if (rank[first] == rank[second]) &#123; rank[first]++; &#125; father[second] = find_set(first); &#125; return; &#125; public static void printEdge(Edge[] edge) &#123; for (int i = 0; i &lt; edge.length; i++) &#123; if (edge[i] != null) System.out.println(edge[i].toString()); &#125; &#125; static class Edge implements Comparable// 两点之间的加权边 &#123; private int first, second;// 表示一条边的两个节点 private int value;// 权值 public Edge(int first, int second, int value) &#123; this.first = first; this.second = second; this.value = value; &#125; public int getFirst() &#123; return first; &#125; public int getSecond() &#123; return second; &#125; public int getValue() &#123; return value; &#125; @Override public int compareTo(Object arg0) &#123; return value &gt; ((Edge) arg0).value ? 0 : -1; &#125; @Override public String toString() &#123; return "Bian[first=" + first + ",second=" + second + ",value=" + value + "]"; &#125; &#125;&#125; Android涉及到的设计模式1、适配器模式：ListView或GridView的Adapter简介：不同的数据提供者使用一个适配器来向一个相同的客户提供服务。 2、建造者模式：AlertDialog.Builder简介：可以分步地构造每一部分。 3、命令模式：Handler.post后Handler.handleMessage简介：把请求封装成一个对象发送出去，方便定制、排队、取消。 4、享元模式：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。简介：运用共享技术有效地支持大量细粒度的对象。 5、迭代器模式：如通过Hashtable.elements方法可以得到一个Enumeration，然后通过这个Enumeration访问Hashtable中的数据，而不用关心Hashtable中的数据存放方式。简介：提供一个方法顺序访问数据集合中的所有数据而又不暴露对象的内部表示。 6、备忘录模式：Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心简介：不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。 7、观察者模式：我们可以通过BaseAdapter.registerDataSetObserver和BaseAdapter.unregisterDataSetObserver两方法来向BaseAdater注册、注销一个DataSetObserver。这个过程中，DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。事件通知也是观察者模式简介：一个对象发生改变时，所有信赖于它的对象自动做相应改变。 8、原型模式：比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了简介：在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。 9、代理模式：类似于ios开发的delegate委托模式，所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。简介：为其他对象提供一种代理以控制对这个对象的访问。 10、状态模式：View.onVisibilityChanged方法，就是提供了一个状态模式的实现，允许在View的visibility发生改变时，引发执行onVisibilityChanged方法中的动作。简介：状态发生改变时，行为改变。 11、策略模式：举例：Java.util.List就是定义了一个增（add）、删（remove）、改（set）、查（indexOf）策略，至于实现这个策略的ArrayList、LinkedList等类，只是在具体实现时采用了不同的算法。但因为它们策略一样，不考虑速度的情况下，使用时完全可以互相替换使用。简介：定义了一系列封装了算法、行为的对象，他们可以相互替换。 12、调解者模式简介：一个对象的某个操作需要调用N个对象的M个方法来完成时，把这些调用过程封装起来，就成了一个调解者举例：如Resource.getDrawable方法的实现逻辑是这样的：创建一个缓存来存放所有已经加载过的，如果getDrawable中传入的id所对应的Drawable以前没有被加载过，那么它就会根据id所对应的资源类型，分别调用XML解析器生成，或者通过读取包中的图片资源文件来创建Drawable。而Resource.getDrawable把涉及到多个对象、多个逻辑的操作封装成一个方法，就实现了一个调解者的角色。 13、抽象工厂模式DAO与Service的使用 硬件加速在Android艺术探索中看到一句话：绝大多数情况下，硬件加速都可以解决莫名其妙的卡顿问题。通过设置android:hardwareAccelerated = “true”即可为Activity开启硬件加速。那么问题来了：什么叫硬件加速？它的原理是什么？ Android从3.0（API Level 11）开始，在绘制View的时候支持硬件加速，充分利用GPU的特性，使得绘制更加平滑，但是会多消耗一些内存。 理解View的绘制模型：invalidate（）重绘 没有硬件加速：步骤如下： Invalidate the hierarchy（注：hierarchy怎么翻译？） Draw the hierarchy 应用程序调用invalidate()更新UI的某一部分，失效(invalidation)消息将会在整个视图层中传递，计算每个需要重绘的区域（即脏区域）。然后Android系统将会重绘所有和脏区域有交集的view。很明显，这种绘图模式存在缺点： 每个绘制操作中会执行不必要的代码。比如如果应用程序调用invalidate()重绘button，而button又位于另一个view之上，即使该view没有变化，也会进行重绘。 可能会掩盖一些应用程序的bug。因为android系统会重绘与脏区域有交集的view，所以view的内容可能会在没有调用invalidate()的情况下重绘。这可能会导致一个view依赖于其它view的失效才得到正确的行为。 有硬件加速： Android系统仍然使用invalidate()和draw()来绘制view，但在处理绘制上有所不同。Android系统记录绘制命令到显示列表，而不是立即执行绘制命令。另一个优化就是Android系统只需记录和更新标记为脏（通过invalidate()）的view。新的绘制模型包含三个步骤： Invalidate the hierarchy 记录和更新显示列表 绘制显示列表 线程和进程的区别联系 进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。 线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 两者都可以提高程序的并发度，提高程序运行效率和响应时间。线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。 根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的： 1、速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。 2、资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。 3、同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阳春白雪与下里巴人]]></title>
      <url>%2F2016%2F%E9%98%B3%E6%98%A5%E7%99%BD%E9%9B%AA%E4%B8%8E%E4%B8%8B%E9%87%8C%E5%B7%B4%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[下午两点的天，白花花的，跟重庆的天应该是一样的吧，但重庆的空气应该没这边这么阴冷。没办法，不论是国家还是个人都得以经济建设为中心。 认识新朋友是很高兴的事情，看了很多与人交往的书，对于我来说大概也就是让我的心变得开朗点儿，让我不那么害怕认识新朋友了。就算是与朋友发生了什么龃龉，我也有信心可以自己调节好（朋友之间的矛盾，大概我也只有干瞪眼旁边看着了）。 到成都认识了一个新朋友，这位朋友很热情很和蔼，以东道主的身份请吃了饭，又邀请到她住的地方吃饭（完全是沾别人光了）。讲真，我不喜欢到别人家厨房去，我也没什么理由。吃了饭，另外两朋友去帮主人洗碗了，但我只是坐着玩手机，那会儿觉得好尴尬啊。 貌似写着写着又快变成日记了……不好不好，言归正传，刚认识一个人，还未成为朋友时，因为不了解，可能觉得这个人是下里巴人的人或是阳春白雪的人。其实都是误解，我天生面瘫脸，表情不丰富，难免觉得难以接近，但我个人觉得就算不是如沐春风那也是热情澎湃啊。 这大概就是距离产生的误解了。 有那么一句话，大家都知道相互是什么样的人。这句话在我看来是十分没有逻辑性而且十分任性的一句话。我或许知道你是什么样的人，你知不知道我什么样的人还另说；而且，就算我知道你是什么样的人，但我没有义务包容你所说的什么样的人。因为你不会说话，我就一直得忍受你各种各样的语气的话，完了还说一句，我以为我们都知道相互是什么样的人，说得我生气就是我自己不够了解你一样。 这便是距离太近产生的误解了。 距离近了，才知道我们既可以下里巴人，也可以阳春白雪。 我一直觉得，不论是男女朋友之间，还是普通朋友之间都是为了更开心，所以才在一起相处，偶尔的龃龉可以调节，我可以问自己，到底是这件微不足道的小事重要，还是你这么朋友重要，但是太多的不开心，我觉得也没什么相处的必要了，因为最初的目的都违背了。 所以不论是最开始看着的阳春白雪下里巴人，到最后，都会剥开还原最真实的你。没有人是完美的，包括你最看重的你自己，朋友包容了我的最难相处的点然后还是喜欢着我，那我怎么能去吹毛求疵？ 看着窗外的柏树（我猜的），听着音乐，做着喜欢做的事情。身边的朋友也是我喜欢的，这样的生活就是完美的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据库]]></title>
      <url>%2F2016%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
      <content type="text"><![CDATA[数据库概述 关系数据库 SQL 数据库概述数据的主要功能：1.数据定义功能；2：数据组织、存储和管理；3：数据操纵功能；4：数据库的事务管理和运行管理；5：数据库的建立和维护功能；6：其他功能。 关系数据库一行即是一个元祖，一列即是一个属性，域为属性的取值范围，分量对应元祖中的一个属性值（一个单元格）； 基本表：实际存在的表，实际存储数据的逻辑表示；查询表：查询结果对应的表；视图：由基本表或者其他视图导出的表，是虚表，不应对应实际存储的数据。 实体完整性：主码不为空，且唯一。参照完整性：外码必须是另一个表的主码，外码值必须在它对应的实体中有对应的主码值。外码可以为空值。用户定义扥完整性：约束条件 SQL]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《第一行代码》]]></title>
      <url>%2F2016%2F%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%2F</url>
      <content type="text"><![CDATA[学习是件愉快的事情。我一直是这么觉得的。因为在学习中所获得的充实感跟在玩乐或者吃完东西的那种满足感完全不同。 昨天状态奇差，我只是在各个网站上做了些笔试题这样，确实难得不知道说什么好，但是莫名有种好刺激的感觉，要是太简单，要在这么多人中被选中也是件难事。 所以今天决定看一本自己相比较更感兴趣的书《第一行代码》，最初乱七八糟的用到哪个控件就看哪个相关的博客，然后有段时间没做项目了就看了小猪（coder-pig）的博客，看了之后觉得自己已经不是初级人员，就没看什么初级的书就奔向了《Android艺术探索》,但是总感觉知识脱节了，有可能是当时看小猪的教程没那么认真，也有可能是因为忘掉了。总之，正好好久没接触Android相关的知识或者代码，重温一下也不错。 申明，在此博客中也仅仅是为了后面懒得翻书，所以仅仅只写了我感兴趣和我确实有些忘了的部分。 启动与关闭活动活动的启动模式：standard,singleTop,singleTask,singleInstance：标准，启动栈顶元素时不重新入栈，任务栈中仅仅存在一个实例，以前有的话，它成为栈顶元素，其他原本在他上面的都出栈，单独一个栈。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络基础]]></title>
      <url>%2F2016%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[物理层###任务### 物理层的任务 信道复用技术 宽带接入技术 物理层的任务数据在计算机中采用并行传输方式，在通信链路中的传输方式一般都是串行传输（处于经济的考虑）。 数据是运送消息的实体，信号是数据的电器或电磁的表现。 基带信号有的频率不能在许多信道中传输，所以需要对基带信号进行调制。这种调制分为两类： 第一类：（基带调制:把数字信号转换为另外一种数字信号）：仅仅对波形进行变换，变换后的信号仍然是基带信号。这种过程也称为编码（归零，不归零，曼切斯特，查分曼切斯特）。 第二类：（带通调制：调频，调相，调幅）：需要使用载波进行调制，即：把基带信号的频率范围搬移到较高的频段，并转为模拟信号。 曼切斯特编码：位中心向上或向下定义为0或1.差分曼切斯特码：位中心处都有跳变，位开始没有跳变代表1，有跳变代表0. 物理层下的传输媒体：数据传输系统中在发送器和接收器之间的物理通路。分为两大类：导引型和非导引型。 导引型传输媒体：电磁波沿着固体媒体（铜线或光纤）传播。 非导引型传输媒体：自由空间，在这里面电磁波的传输称为无线传输。 信道复用宽带接入技术]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构]]></title>
      <url>%2F2016%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[数据：信息的载体，能够被计算机识别、存储、加工，包括整数、实数、字符串、图像、声音等 数据元素：数据的基本单位，也称结点、元素、顶点、记录。一个数据元素可由若干个数据项组成 数据项：是具有独立寒意的最小标识单元，也称字段、域、属性等 数据结构：指数据之间的相互关系，即组织形式，有逻辑结构（一般程序中出现的形式）和物理结构之分（内存中的连续存储形式）；逻辑结构又有线性（非空，仅由一个开始结点和一个终端结点，除首尾结点之外，所有节点均只有一个直接前区和一个直接后继，如一维数组、栈、队列、链表、串等）和非线性之分（一个结点可以有多个直接前区和多个直接后继，如多维数组、广义表、树、图等） 如果两个没有环的链表相交于某个节点，那么在这个节点之后的所有节点都是两个链表所共有的。直接判断两链表的尾节点是否相同即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java编程思想]]></title>
      <url>%2F2016%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F</url>
      <content type="text"><![CDATA[这篇博客全篇都是java的知识点，边看《Java编程思想》边写的，一天两天之内可能无法完成，但是我也肯定会在最近这几天内看完，然后再开始看一些网络知识了。当然我不能照着书全部重新敲一遍，我只是整理我觉得混淆的和以前并不清楚的东西。不全面也是正常了。 目录结构如下： 对象 操作符 控制执行流程 初始化与清理 访问控制权限控制 复用类 多态 接口 内部类 持有对象 通过异常处理处理错误 字符串 类型信息 泛型 数组 容器的深入研究 Java I/O系统 枚举类型 注解 并发 组件 对象对象：将问题空间中的元素及其在解空间中的表示称为对象。也就是说：程序可以通过添加新类型的对象使自身适用于某个特定的问题。对象具有状态，行为和标识。 类：描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。 接口确定了对某一特定对象所能发出的请求。 继承在只重写基类方法与需要添加新方法都是可行，但要根据真实的情况来，区分还是很明显的。 Java完全采用动态分配内存方式，编译器可以确定对象存活的时间，并且可以自动销毁它。这样可以避免暗藏的内存泄漏问题。 在程序中，彼此独立运行的部分称之为线程。 String中每个字符都是16位或者2个字节。null在Java中表示这个引用还没指向某个对象。 当声明一个事物static时，就表示这个域或这个方法不会与包含它的那个类的任何对象实例关联在一起。未创建实例时，也可以直接调用其static的域或方法，而非static关键字的域和方法都必须通过实例化才能引用。多个实例化指向的其实也只是一个static域。 javadoc只能为public,protect成员进行注释。private和包内可访问的注释会被忽略掉。javadoc注释支持嵌入HTML 类名的首字母大写，几个单词组合时不要用下划线隔开，其中每个内部单词的首字母都要大写。 用eclipse导出javadoc为html文件，可以导出整个项目，步骤为：项目右键—&gt;export—&gt;java—&gt;javadoc—&gt;javadoc command为jdk的bin文件的javadoc.exe这个文件，然后选择保存的路径—&gt;finish 就成功了，自动概览整个项目，可以生成目录等。 操作符不能把任何东西赋值给一个常数。 obj1 = obj2;这种叫做别名现象，指向的是同一个引用，改变的值那些都将会相等。方法调用时也是产生了一个别名，改变了方法中的对象，其实改变的是调用方法传入的对象。 前缀递增或者递减都是先执行运算，再进行赋值。而后缀递减或者后缀递增都是先赋值再运算。 在for(int i = 0;i&lt;10;i++)这个语句中，最先初始化i=0，然后判断i&lt;10，执行完之后再进行i++,再判断i&lt;10是否成立来决定是否还要执行循环。 ==和!=适用于所有的基本数据类型，也适用于所有对象，它们比较的是对象的引用是否是同一个。 equals()方法默认的也是比较引用，只有自己覆盖重写之后才会是想要的比较。 短路现象：一旦能够准确无误的确定整个表达式的值，就不会计算表达式的剩余部分了。这种方法可以获得潜在性能的提升。 float类型的常量一定要加f,不然会被认定为double类型，然后就会报错。例如:float aa = 1.2f;(此处不加f时就会报错) 按位操作符用来操作整数基本数据类型中的单个bit,即二进制位。（&amp;，|,^:异或：某一个是1，但不全是1时会输出1,~），&amp;，|,^可与赋值符号连用。 移位操作符的运算对象也是二进制，&lt;&lt;左移，&gt;&gt;（有符号，符号为正高位补0符号为负高位补1），&gt;&gt;&gt;（java特有无符号，无论正负都在高位补0）右移，左移低位补0， 计算机显示二进制是显示的补码，整数就是原码，负数是将数字的反码（如果是正数，则表示方法和原码一样；如果是负数，则保留符号位1，然后将这个数字的原码按照每位取反，则得到这个数字的反码表示形式）加1。 假如a = -1;a是八位的数据。原码为1000 0001，但是计算机中存的是补码，也就是-1 的反码：1111 1111，那么计算机中表示的二进制为：1111 1111。 将a&gt;&gt;&gt;3，就是说以无符号数来右移3位，得到的数为：1111 1，就是说无论有没有符号，将这个补码右移三位就行。 三元操作符：boolean-exp?value0:value1; Math.round();四舍五入取整,参数是float或者double Math.ceil();向上取整 Math.floor();向下取整 控制执行流程while与do-while的区别就是：do-while至少会执行一次。 逗号操作符运用的位置：函数的参数列表用逗号隔开，和for语句中控制表达式for(int j = 0,i = 1=;j&lt;10;j++,i++),用逗号可以定义多个变量，但必须具有相同的类型。 for(int i:arr)是以foreach的方式遍历数组。 初始化与清理为了让方法名相同而形式参数不用的构造器同时存在，所以必须用到方法重载。也可应用于其他方法，且方法同样方便。根据返回值来重载方法是行不通的。在导出类中也可以对基类方法进行重载。 重载接收较小的基本类型（例如参数是int,传入long），如果传入的参数较大，就得通过类型转换来执行窄化转换。如果不这样做就会报错。 this只能在方法内部使用，表示调用那个方法的对象。需要返回对当前对象的引用时，可以直接使用：return this; 通过this对构造函数的调用，只能在构造函数内能调用，调用语句必须是第一句，并且一个构造器内只能调用一个构造函数。 static方法内部不能调用非静态的方法，但是反过来可以。调用static方法时，由于存在this（不需要实例化就可以调用），所以不是通过“向对象发送消息”。 垃圾回收器基本原理就是虚拟机每隔一段时间就会运行一次垃圾回收或是在虚拟机认为需要的时候。主动调用是System.gc()。垃圾回收器运行了当然会收回内在。 两个最基本的java回收算法：复制算法和标记清理算法 复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法 标记清理：一块区域，标记要回收的对象，然后回收，一定会出现碎片，那么引出标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象 两个概念：新生代和年老代 新生代：初始对象，生命周期短的 永久代：长时间存在的对象整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。 P.S： Serial New收集器是针对新生代的收集器，采用的是复制算法 Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理 Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法 Serial Old（串行）收集器，新生代采用复制，老年代采用标记清理 Parallel Old（并行）收集器，针对老年代，标记整理 CMS收集器，基于标记清理 G1收集器：整体上是基于标记清理，局部采用复制 综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。 使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize方法），他们也必须同内存及其回收有关。如果JVM并未面临内存耗尽的情形，它是不会花费时间去执行垃圾回收以恢复内存的。 最好是除了内存之外，不能依赖垃圾回收器做任何事情。如需清理，最好编写自己的清理方法，不要使用finalize()方法 当调用对象太多（我试了调用十万次）时，存储空间满了，会自动调用系统垃圾回收，强制进行终结的代码如下： 12System.gc();//调用系统的垃圾回收 java的所有对象（基本类型除外）都是在堆上分配的方式。每个对象都含有一个引用计数器，当引用的计数值变为0时，立即释放对象。 在类的内部，变量定义的先后顺序决定了初始化的先后顺序，但是变量初始化先于任何方法调用。静态初始化只有在必要的时候才会进行。构造器实际上也是静态方法。 123456789101112131415161718192021222324252627282930313233class Cup&#123; public Cup(int maker) &#123; // TODO Auto-generated constructor stub System.out.println("Cup("+maker+")"); &#125; void f(int maker)&#123; System.out.println("f("+maker+")"); &#125;&#125;class Cups&#123; static Cup cup1; static Cup cup2; static Cup cup4 = new Cup(4); Cup cup3; static&#123; //这个块只调用一次 cup1 = new Cup(1); cup2 = new Cup(2); //cup3不能放到静态块中，因为它不是静态的变量 System.out.println("--------"); &#125;&#125;public class YiWei &#123; public static void main(String[] args) &#123; Cups.cup1.f(1); &#125;&#125; java中指定可变参数实质上是编译器为程序员将参数列表填充为数组。 枚举类型初体验 123456789101112public class YiWei &#123; public static void main(String[] args) &#123; Spiciness howHot = Spiciness.NOT; swtch(howHot)&#123; //可以直接将枚举类型当作常数处理 &#125; &#125; public enum Spiciness&#123; NOT,MILD,MEDIUM,HOT,FLAMING &#125;&#125; 访问控制权限控制java包的命名规则是全部使用小写字母，包括中间的字也是如此。 类既不可以是private的，也不可以是protect。所以类权限只可以是public和包权限。如果不希望其他任何人对类有访问权限，可以对构造器设置权限为private. Java中，关键字package，包的命名模式和关键字import，可以使你对名称完全控制，从而避免命名冲突。 复用类复用类的方法有二：1 组合，2 继承。 toString();方法的调用机制：当编译器需要一个String而你却只有一个对象时，toString()方法就会被调用。 12345678910111213141516171819202122232425262728class Cup&#123; public Cup(int maker) &#123; // TODO Auto-generated constructor stub System.out.println("Cup("+maker+")"); &#125; void f(int maker)&#123; System.out.println("f("+maker+")"); &#125;&#125;class Cups extends Cup&#123; public Cups() &#123; // TODO Auto-generated constructor stub super(0); System.out.println("Cups"); &#125;&#125;public class YiWei extends Cups&#123; public static void main(String[] args) &#123; YiWei yiWei = new YiWei(); &#125;&#125;//输出：Cup(0)// Cups 从上面的输出结果来看，在实例化导出类的构建导出类的对象的时候，在那之前，基类的初始化已经完成了。在继承基类的时候，若是基类没有无参构造器，那么导出类会被编译器强制要求显式调用一个父类的一个构造器。若父类有无参构造器的话，则不会强制要求调用父类构造器，应该编译器隐式调用那么无参构造器。 @override可以防止在不想重载的时候进行了重载。 final修饰的变量必须赋值（在域的定义处或者每个构造器中用表达式对final进行赋值）。final对于基本数值，表示数值恒定不变；对于对象，表示引用恒定不变。无法指向下一块空间。但是对象本身是可以改变的。Java并未提供使对象恒定不变的效果。 带有恒定初始值的final static基本类型全用大写字母命名，并且单词与单词之间用下划线隔开。 final允许在参数列表中使用，表示无法在方法中更改参数引用所指向的对象。 final方法使用的原因有二：一：把方法锁定，不允许任何继承修改它的含义；二是因为效率（已经不需要）。类中所有的private方法都隐式的指定为final,如果试图覆盖一个private方法（隐式指定final），似乎是奏效的，而且编译器不会报错,但显示的final方法会报错。 final类表示不允许继承。 多态向上转型：把对象的引用视为对其基本类型的引用的做法被称作向上转型。 java是通过后期绑定（也叫动态绑定、运行时绑定）的方式，以便在运行的时候能判断对象的类型。 封装通过合并特征和行为来创建新的数据类型。实现隐藏则是通过将细节“私有化”把接口实现分离开来。而多态的作用是消除类型之间的耦合关系，将改变的事物与未变的事物分离开来。 非private，final方法才可以实现覆盖调用，而且只有方法可以是多态。如果一个方法是静态的，那它的行为也不具有多态性。构造方法是隐式的static方法。 构造器中唯一能安全调用的方法是基类的final方法，这些方法不会被覆盖。 接口包含抽象方法的类叫做抽象类。 c++参数列表入栈顺序从右往左，Java的顺序正好相反。 内部类匿名内部类嵌套内部类静态内部类内部类的使用复杂，而且极其容易忘记，内部类可以完成很多不可思议的需求。 持有对象Collection:Map,set,List Set中相同元素只能存储一次，但又不像Map那样以键值对的形式存储。HashSet是最快的元素获取方式，如果强调顺序则可以使用TreeSet(将元素升序存储)或者LinkedHashSet（添加的顺序存储）。TreeSet没有实现Colloction中的所有接口。 Map也是三种Map:HashMap查找最快，TreeMap升序，LinkedHashMap按插入的顺序存。 List分为ArrayList和LinkedList。两者在某些操作的性能不同，而且LinkedList包含的操作也多于ArrayList。 ArrayList:长于随机访问元素，但是在中间进行插入和删除元素比较缓慢。 LinkedList:通过较低的代价在List中间进行插入和删除操作。但是在随机访问方面相对较慢。添加了可以使其用做栈，队列，或双端队列的方法。[element() = getFirst(),offer()：将一个元素插到队尾,peek()：获取栈顶元素,poll(),remove() = removeFirst()] Stack:LinkedList具有能够直接实现栈的所有功能的方法，所以可以直接将LinkedList转换为Stack。[pop():移除并返回栈顶元素，peek(),push(),empty()] Map可以返回他的键的Set，他是值的Collection,或者他的键值对的Set.Map可以通过entrySet()和values()产生Colloction. Queue:队列是一个典型的先进先出的容器。在不需要Collection的方法的情况下，就可以拥有一个可用的Queue.它声明弹出的是等待时间最长的元素。 PriorityQueue:优先队列，它声明下一个弹出的是最需要的元素（最高的优先级）。comparator对象来改变排序（如果想在优先队列中使用自己的类，那么使用者就必须提供自己的Comparator）。 迭代器：遍历选择序列中的对象。通常被称为轻量级对象，创建他的代价小。Java中的Iterator只能单向移动。 ListIterator只能用于List的访问，可以双向移动。 通过异常处理处理错误123456789101112131415161718192021222324252627282930313233343536public class Test &#123;public static void main(String[] args) &#123; String i = null; /*try &#123; if (i == null) &#123; throw new MyException("string is null"); &#125; &#125; catch (MyException e) &#123; // TODO: handle exception e.printStackTrace(System.out);//以控制台输出的方式输出异常信息// for(StackTraceElement element:e.getStackTrace())//输出方法名这些// System.out.println(element.getClassName()+"."+element.getMethodName()+"."+element.getLineNumber()); &#125;*/ f(); System.out.println(4); &#125;static void f()&#123; try &#123; System.out.println(1); throw new MyException("2"); &#125; catch (MyException e) &#123; // TODO: handle exception System.out.println(3); &#125;finally &#123; System.out.println(5); &#125;&#125;&#125;输出：1354//在catch中再次抛出异常不能在外面捕获，应该也有作用域相关的问题。 当覆盖方法的时候，只能抛出基类方法的异常说明列出的那些异常。但这个异常限制对构造方法无用。派生构造器不能捕获基类构造器抛出的异常。一个出现在基类方法说明中的异常，不一定会出现在派生类中。不能通过异常说明来重载方法。 异常抛出之后，异常处理机制将搜寻参数与异常类型匹配的第一个处理程序，然后就不再查找。RuntimeException类型的异常属于错误，将被自动捕获，也称为不受检查异常。 新写一个异常时，抛出这个异常，通过捕获它的父类依然可以捕获到这个异常。catch Exception可以捕获到所有的异常。 所谓的把异常抛到更高层，就是在catch字句中，再次抛出。12345678910try &#123; System.out.println(1); throw new MyException("2"); &#125; catch (MyException e) &#123; // TODO: handle exception System.out.println(3); throw new NullPointerException(); &#125; 字符串String对象是不可变的，String中每一个看起来会修改String值的方法，实际上都是创建了一个新的String。 字符串想加时，编译器自动引入了StringBuilder类。因为它更高效。 append(a+”:”+c)这样的句子，编译器会另外创建一个StringBuilder来处理括号里的字符串操作。 StringBuilder是线程不安全的，StringBuffer线程安全，因此开销也更大。 正则表达式：-？:要找一个数字，可能有个-号在最前面；\d:描述整数，\\:插入一个普通的斜杠；+：一个或多个之前表达式。eg:-？\d+：最前面可能有一个负号，后面跟着一位或者多位数字；[abc]= a|b|c 包含a,b,c的任意字符 [a-zA-Z][abc[ijk]] = a|b|c|i|j|k\s：空白符\S:非空白符\d = [0-9]\D = [^0-9]\w = [a-zA-Z0-9]\W = [^a-zA-Z0-9]XY:X跟在Y的后面X|Y:X或者Y（X）:捕获组\G:一个匹配的结束 Split():将字符串从正则表达式匹配的地方切开。 类型信息事实证明，复习是十分重要的，可以发现很多被忽略掉的事情，例如：昨晚考了一道题，只包含0和1的数，按以前的习惯来讲吧，把数转换为String之后，循环判断这位是不是0或者1，其实还挺麻烦的，但是我想到昨天才看的正则表达式，我觉得这样是不是更简单一点，然后弄了个正则表达式（第一次写不是很熟练，尝试了几下才写出来），少了一层循环（时间复杂度减少，我很自豪，哈哈哈）。 罢了，言归正传。泛型这一大难题又在我眼前。 泛型最常用到是在容器类里面，就是Map,List，Set这样的类里面。例如：12List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 我们也用在自己写的类中：1123456789101112131415161718192021public class Me &lt;T&gt;&#123; T t; public void set(T t) &#123; this.t = t; &#125; public void print()&#123; System.out.println(t); &#125;&#125;//调用public class PuTong &#123; public static void main(String[] args) &#123; Me&lt;String&gt; me = new Me&lt;&gt;(); me.set(&quot;we are Chinese.&quot;); me.print(); &#125;&#125; 当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型，这称为类型参数推断。泛型方法可以存在在不是泛型类中：123456789101112public class PuTong &#123; public static &lt;T&gt; void print(T t) &#123; System.out.println(t); &#125; public static void main(String[] args) &#123; print(1); print("str"); print(0.25f); &#125;&#125; 泛型擦除：在使用泛型时，任何具体的类型信息都被擦除了，唯一知道就是在使用一个对象，在泛型代码内部，无法获得任何有关泛型参数类型的信息。List和List都是相同的类型，这两种形式都被擦除成原生的类型，即List。 边界： :T必须具有类型HasF或是HasF的子类。泛型类型参数将擦除到它的第一个边界。如果是普通的泛型就相当于将它擦除为Object,若是就相当于全部擦除为HasF类。&lt;? super Apple&gt;Apple是下界，可以用Apple的子类加入到类中，但声明最低都要是Apple才行。 泛型数组容器的深入研究Java I/O系统枚举类型注解并发组件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自我评价]]></title>
      <url>%2F2016%2F%E8%87%AA%E6%88%91%E8%AF%84%E4%BB%B7%2F</url>
      <content type="text"><![CDATA[前言：此自我介绍仅仅用于找工作时使用。 &emsp;&emsp;各位面试官，你们好。 &emsp;&emsp;我是刘群，今年21岁，来自重庆理工大学，平时喜欢看书和动漫。 &emsp;&emsp;我想说一下我大学我记忆比较深刻的事情。 &emsp;&emsp;第一件事，大一的时候和同学合伙在学校卖酸奶。当时我负责宣传和销售的部分。除了在我所做的工作所收获的，更收获的对专业的喜爱。室友的男朋友帮我们开发了一个微信订购系统，那时候对自己专业了解不深，觉得这个东西就这么被身边的人做起来了，引起了我对编程的兴趣，现在仍然保有这份兴趣。 &emsp;&emsp;第二件事，进入了我们的iCode团队。在这里我认识了我大学最好的朋友，也参与了人生中第一次真实项目。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统]]></title>
      <url>%2F2016%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[操作系统的复习比较细致，花了一天半边看书边整理框架，把基本的架构和一些我觉得需要注意的写在了框架上，还有一些需要代码实现的。 操作系统框架 基本状态转换 请求分页使用的最近最少未使用算法 操作系统框架 基本状态转换 请求分页使用的最近最少未使用算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 最近最少未使用算法 * * @author LiuQun * */public class LRU &#123; private int theArray[];//内存中的页面 private int back; // 定义队尾 private int currentSize; // 队列中存放元素个数 private int maxSize = 5; // 队列中能存放元素的个数 public LRU() &#123; theArray = new int[maxSize]; back = 0; currentSize = 0; &#125; /** * 挨个入队 * @param a */ public void queue(int sequence[]) &#123; for (int i = 0; i &lt; sequence.length; i++) &#123; enQueue(sequence[i]); &#125; &#125; /** * 将页面加入队列， * @param x 页号 */ public void enQueue(int x) &#123; // 入队 //检查队列中是否已经有了该页，并做另外的处理 beUsed(x); //队列未满的情况下，直接加入新页面（最开始与队列中已存在该页面） if (currentSize &lt; maxSize) &#123; theArray[back] = x; back++; currentSize++; &#125; //队列已满的情况下（队列中没有这个页面并且队列加满），移除第一个页面，其他的往前移动，将队尾的页面为新加入的 else if (currentSize == maxSize) &#123; // 满了 for (int i = 0; i &lt; maxSize - 1; i++) &#123; theArray[i] = theArray[i + 1]; &#125; theArray[maxSize - 1] = x; &#125; //打印队列中的元素 for (int i = 0; i &lt; currentSize; i++) &#123; System.out.print(theArray[i]); &#125; System.out.println(); &#125; /** * 判断是否已存在该页号,若存在，将这页后的页面往前移动，将这个已存在的页面删除 * @param x 页号 */ public void beUsed(int x) &#123; for (int i = 0; i &lt; currentSize; i++) &#123; if (theArray[i] == x) &#123; for (int j = i; j &lt; currentSize - 1; j++) &#123; theArray[j] = theArray[j + 1]; &#125; //当前页面数和队尾坐标都减1 currentSize--; back--; &#125; &#125; &#125; public static void main(String[] args) &#123; LRU lru = new LRU(); int[] sequence = &#123; 1, 2, 3, 4, 2, 1, 5, 6, 2, 1, 2, 3, 7, 6, 3, 2, 1, 2, 3, 6 &#125;; lru.queue(sequence); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于心境的问题]]></title>
      <url>%2F2016%2F%E5%85%B3%E4%BA%8E%E5%BF%83%E5%A2%83%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[有很多时候我都得说，人算不如天算，按照我自己的复习计划，这会儿我应该是高枕无忧才对，但是现在其实大概刚刚把算法复习完。我的网络几乎只复习了很小的一部分，还有Android的知识更是很久没看了，我还说把Parking项目检下来看一遍的也还没开始，我深深意识到我还差得远的。但是我身边的人似乎都开始浮躁了，大概是因为杨艳秋他们要去成都了的原因。到处做面试题不是说不好，但我觉得那样子根本不能好好复习的，这不是高考，刷题就可以，我觉得更多的应该是对知识的掌握吧。 可能是我太天真，我觉得应该是有真材实料才能有公司要的吧，不然的话，再怎么漂亮，我想通过笔试，光明正大的通过面试，就算是我不出色的外表也有公司觉得我值得被选择。 更有主动性地说，我想是我来选择公司而不是公司选择我。 我确实该沉下心好好学习的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查找算法]]></title>
      <url>%2F2016%2F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[贪婪算法]]></title>
      <url>%2F2016%2F%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[贪婪算法通过一系列步骤来构造问题的解，每一步对目前的部分解做一个扩展，直到获得问题的完整解为止。每一步都必须满足以下要求：可行，局部最优，不可取消。分为以下几个： Prime算法 Kruskal算法 Dijskra算法 哈夫曼树及其编码 Prime算法连通图的一颗生成树是包含图的所有顶点的连通无环子图。最小生成树是权重最小的生成树。 把离树近的顶点贪婪的包含进来。 Prime算法通过不断扩张的子树来构造一颗最小生成树。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static int unReach = 1000;public static int n = 4;public static void main(String[] args) &#123; int[][] G = &#123; &#123; 0, 4, 15, 10 &#125;, &#123; 4, 0, 10, unReach &#125;, &#123; 15, 10, 0, unReach &#125;, &#123; 10, unReach, unReach, 0 &#125; &#125;; boolean[] visit = new boolean[n]; int sum = 0; int[] dist = new int[n]; // 清空生成树，任取一个顶点加入生成树 initVisit(visit); int index = 0; visit[index] = true; for (int i = 0; i &lt; n; i++) &#123; dist[i] = G[index][i]; &#125; for (int i = 1; i &lt; visit.length; i++) &#123; int min = unReach;// 在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树 for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; (min &gt; dist[j])) &#123; min = dist[j]; index = j; &#125; &#125; visit[index] = true; sum += min; // 重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树 for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; dist[j] &gt; G[index][j]) &#123; dist[j] = G[index][j]; &#125; &#125; &#125; System.out.println(sum);&#125;private static void initVisit(boolean[] visit) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; visit.length; i++) &#123; visit[i] = false; &#125;&#125; Kruskal算法在Prime算法中在树的生成过程中一直都是连通的，但是克鲁斯卡尔算法 在计算过程中却并不一定是连通的。算法开始的时候，会按照权重的非递减顺序对图中的边进行排序。然后从一个空子图开始，它会扫描这个有序列表，并试图将列表中的下一条边加到当前的子图中，这种添加法不应该产生回路，如果产生了回路就从这个边跳过。 克鲁斯卡尔（Kruskal）算法因为只与边相关，则适合求稀疏图的最小生成树。而prime算法因为只与顶点有关，所以适合求稠密图的最小生成树。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/** * @author LiuQun * 中心是快速求并法。用一个有根树来表示每一个子集，树中的节点包含子集中的元素； * 根中的元素就被当做该子集的代表树；树中的边从子女指向他们的父母 * makeset():创建一颗单节点的树 * union(x,y):把Y树的根附加到X上（并把Y树删除） * find(x):从包含x的节点开始找到树的根 * */public class Kruskal &#123; public static int n = 5;// 顶点个数 public static int edgeNum = 7;// 总边数 public static int father[] = new int[128];// public static int rank[] = new int[128];//树的等级（层数），优化算法用的，层数小的加在层数大的下 public static void main(String[] args) &#123; // 边的数组 Edge[] edges = new Edge[edgeNum]; edges[0] = new Edge(0, 1, 5); edges[1] = new Edge(1, 2, 3); edges[2] = new Edge(1, 3, 3); edges[3] = new Edge(3, 4, 8); edges[4] = new Edge(1, 4, 7); edges[5] = new Edge(4, 2, 3); edges[6] = new Edge(0, 2, 4); Edge[] result = new Edge[edgeNum]; int count = 0; // 按照权重排序树的边 srotEdge(edges); printEdge(edges); make_set(); // 将图遍历一次，找出权值最小的边，（条件：此次找出的边不能和已加入最小生成树集合的边构成环）， // 若符合条件，则加入最小生成树的集合中。不符合条件则继续遍历图，寻找下一个最小权值的边。 int sum = 0; for (int i = 0; i &lt; n; i++) &#123; // tree中无回路，使用不相交子集和并查算法 if (find_set(edges[i].getFirst()) != find_set(edges[i].getSecond())) &#123; union(edges[i].first, edges[i].second); sum += edges[i].value; result[count++] = edges[i]; &#125; &#125; System.out.println(sum); printEdge(result); &#125; //把每个元素初始化为一个集合 private static void make_set() &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; n; i++) &#123; father[i] = i; rank[i] = 1; &#125; return; &#125; // 采用直接插入排序 private static void srotEdge(Edge[] edges) &#123; // TODO Auto-generated method stub for (int i = 1; i &lt; edges.length; i++) &#123; if (edges[i].value &lt; edges[i - 1].value) &#123; int j = i - 1; Edge temp = edges[i]; while (j &gt; -1 &amp;&amp; temp.value &lt; edges[j].value) &#123; edges[j + 1] = edges[j]; j--; &#125; edges[j + 1] = temp; &#125; &#125; &#125; /** * 从包含x的节点开始找到树的根 * * @param x * 顶点 * @return */ public static int find_set(int x) &#123; if (x != father[x]) &#123; father[x] = find_set(father[x]); &#125; return father[x]; &#125; /** * 合并x,y所在的两个集合：利用Find_Set找到其中两棵树的根， 并将一棵树的根指向另一棵树的根。 * * @param first * x * @param second * y */ private static void union(int first, int second) &#123; // TODO Auto-generated method stub first = find_set(first); second = find_set(second); if (first == second) &#123; return; &#125; if (rank[first] &lt; rank[second]) &#123; father[first] = find_set(second); &#125; else &#123; if (rank[first] == rank[second]) &#123; rank[first]++; &#125; father[second] = find_set(first); &#125; return; &#125; public static void printEdge(Edge[] edge) &#123; for (int i = 0; i &lt; edge.length; i++) &#123; if (edge[i] != null) System.out.println(edge[i].toString()); &#125; &#125; static class Edge implements Comparable// 两点之间的加权边 &#123; private int first, second;// 表示一条边的两个节点 private int value;// 权值 public Edge(int first, int second, int value) &#123; this.first = first; this.second = second; this.value = value; &#125; public int getFirst() &#123; return first; &#125; public int getSecond() &#123; return second; &#125; public int getValue() &#123; return value; &#125; @Override public int compareTo(Object arg0) &#123; return value &gt; ((Edge) arg0).value ? 0 : -1; &#125; @Override public String toString() &#123; return "Bian[first=" + first + ",second=" + second + ",value=" + value + "]"; &#125; &#125;&#125; Dijskra算法Dijskra（戴克斯特拉）算法是单起点最短路径问题：指的是从一个起点到其他所有顶点的一系列最短路径。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class Dijkstra &#123; public static final int M = -1; static int[][] map = &#123; &#123; 0, 7, 9, M, M, 14 &#125;, &#123; 7, 0, 10, 15, M, M &#125;, &#123; 9, 10, 0, 11, M, 2 &#125;, &#123; M, 15, 11, 0, 6, M &#125;, &#123; M, M, M, 6, 0, 9 &#125;, &#123; 14, M, 2, M, 9, 0 &#125; &#125;; static int n = map.length; // 顶点个数 static int[] shortest = new int[n]; // 存放从start到其他各点的最短路径 static boolean[] visited = new boolean[n]; // 标记当前该顶点的最短路径是否已经求出，true表示已求出 public static void main(String[] args) &#123; int orig = 0; int[] shortPath = dijkstra_alg(orig); if (shortPath == null) &#123; return; &#125; for (int i = 0; i &lt; shortPath.length; i++) &#123; System.out.println("从" + (orig + 1) + "出发到" + (i + 1) + "的最短距离为：" + shortPath[i]); &#125; &#125; public static int[] dijkstra_alg(int orig) &#123; // 初始化，第一个顶点求出 shortest[orig] = 0; visited[orig] = true; for (int count = 0; count != n - 1; count++) // 要加入n-1个顶点 &#123; // 选出一个距离初始顶点最近的未标记顶点 int k = M; int min = M; for (int i = 0; i &lt; n; i++) &#123; if (!visited[i] &amp;&amp; map[orig][i] != M) &#123; if (min == -1 || min &gt; map[orig][i]) &#123; min = map[orig][i]; k = i; &#125; &#125; &#125; // 正确的图生成的矩阵不可能出现K == M的情况 if (k == M) &#123; System.out.println("the input map matrix is wrong!"); return null; &#125; shortest[k] = min; visited[k] = true; // 以k为中间点，修正从原点到未访问各点的距离 for (int i = 0; i &lt; n; i++) &#123; if (!visited[i] &amp;&amp; map[k][i] != M) &#123; int callen = min + map[k][i]; if (map[orig][i] == M || map[orig][i] &gt; callen) &#123; map[orig][i] = callen; &#125; &#125; &#125; &#125; return shortest; &#125;&#125; 哈夫曼树及其编码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[温柔拯救]]></title>
      <url>%2F2016%2F%E6%B8%A9%E6%9F%94%E6%8B%AF%E6%95%91%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;温柔的人真的是很奇妙的，他能让你也不自觉地变得温柔。一个人和温柔的人吵起来的概率起码低于一般人的50%，我喜欢温柔的人，喜欢温柔的声音，喜欢被温柔的对待。 &emsp;&emsp;温柔不是说话小声小气，动作和缓这样的表面信息，而是更注重内心的东西。一个人内心是温柔的话，即使他的外表粗犷，他说话声音洪亮也是温柔的。他能让你感觉到内心的善良，并且与之同样的会不自觉的变得温柔。 &emsp;&emsp;手冢外表是冰冷的，但即使是我第一次见着他的时候也没觉得他就是冷漠的人，之后不自觉的让人感觉到温柔，大概这也是这个角色这么遭人喜爱的原因了。所以温柔不是外表，不是声音，而是内心。内心的温柔会不自觉的表现在你的外貌，声音上，会让你的脸色变得温和，会让声音变得温柔。 &emsp;&emsp;我以前其实觉得我是温柔的人（即使我的外表看起来并不温柔），但是我会不自觉的开伤人自尊的玩笑，不自觉的有些低俗而粗鲁的行为。我想做个温柔而温暖的人，让这个世界多一点温柔，在我温柔待人的时候也能换来别人的温柔以待。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态规划]]></title>
      <url>%2F2016%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
      <content type="text"><![CDATA[动态规划的思想就是每次都是最优，综合到了最终得到的方案也是最优。是比较常用的算法，归结起来是以下这几个： 背包问题 记忆化 币值最大化问题 找零问题 Warshall算法 Floyd算法 最优二叉查找树（未完成） 背包问题有n个物体有重量和价值两个属性，一个能承重一定重量的背包。问怎么选择物体能实现背包里的价值最大化。 假设有5个物体和一个背包。物体的重量分别是2、2、6、5、4，即W[]={0、2、2、6、5、4}，价值分别是6、3、5、4、6，即V[]={0、6、3、5、4、6}。背包承重为10。问怎么选择，能实现背包所背物体价值的最大化。 背包的状态转换方程 f[i,j] = Max{ f[i-1,j-Wi]+Vi( j &gt;= Wi ), f[i-1,j] }f[i,j]表示在前i件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。Pi表示第i件物品的价值。根据规则填表如下：代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public static int backpackWeight= 11;public static int num = 5;public static void main(String[] args) &#123; int weight[] = new int[]&#123;0,2,2,6,5,4&#125;; int value[] = new int[]&#123;0,6,3,5,4,6&#125;; int flag[] = &#123; 0, 0, 0, 0, 0 &#125;; int table[][] = new int[num][backpackWeight]; initTable(table); createTable(table,weight,value); obj_opt(table,flag,weight); showTable(table);&#125;public static void showTable(int[][] table) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; table.length; i++) &#123; for (int j = 0; j &lt; table[i].length; j++) &#123; System.out.print(table[i][j]+"\t"); &#125; System.out.println(); &#125;&#125;//得到选择了哪些物品//我们从右上角（坐标（1,10））开始，看（1,10）与（2,10）的值是不是一样，//一样，则说明物体1没装进去，不一样，则说明物体1装进去了。public static void obj_opt(int[][] table, int[] flag, int[] weight) &#123; // TODO Auto-generated method stub int n = backpackWeight-1; for (int i = 0; i &lt; num; i++) &#123; if ((i != num-1)&amp;&amp;(table[i][n] == table[i+1][n])) &#123; //这里感觉是有问题的 flag[i] = 0; &#125;else &#123; flag[i] = 1; n = n-weight[i+1]; &#125; &#125; System.out.print("选择的："); printArray(flag); System.out.println();&#125;//打印排序数组public static void printArray(int[] arr) &#123; System.out.println(); for(int i = 0;i&lt; arr.length;i++)&#123; System.out.print(arr[i]+"\t"); &#125;&#125;public static void createTable(int[][] table, int[] weight, int[] value) &#123; // TODO Auto-generated method stub //给最后一行赋初值 for (int i = 0; i &lt; backpackWeight; i++) &#123; if (weight[num] &gt; i) &#123;//物品的重量大于背包可承重能力 table[num-1][i] = 0; &#125;else &#123; table[num-1][i] = value[num]; &#125; &#125; //在最后一行的基础上给每行赋值 for (int i = num-1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; backpackWeight; j++) &#123; if (weight[i]&gt;j) &#123;//i物品的重量大于背包重量 table[i-1][j] = table[i][j]; &#125;else if ((value[i]+table[i][j-weight[i]])&gt;table[i][j]) &#123;//i-1和i个物品的价值大于i之前的物品价值 table[i-1][j] = value[i]+table[i][j-weight[i]]; &#125;else &#123; table[i-1][j] = table[i][j]; &#125; &#125; &#125; &#125;public static void initTable(int[][] table) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; table.length; i++) &#123; for (int j = 0; j &lt; table[i].length; j++) &#123; table[i][j] = 0; &#125; &#125; &#125; 记忆化用递归的方式实现动态规划 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * @author LiuQun 对必要的子问题只解决一次就是以记忆化为基础的 用递归方式 */public static int weight[] = new int[] &#123; 0,2, 2, 6, 5, 4 &#125;;public static int value[] = new int[] &#123;0, 6, 3, 5, 4, 6 &#125;;public static int backpackWeight = 11;public static int num = 5;public static int[][] F = new int[num+1][backpackWeight+1];public static void main(String[] args) &#123; initF(F); mfkNapsack(5, 11); showTable(F);&#125;/** * 初始化F数组，行列0时初始化为0，其他事-1 * * @param f */private static void initF(int[][] f) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; f.length; i++) &#123; for (int j = 0; j &lt; f[i].length; j++) &#123; if (j == 0 || i == 0) &#123; f[i][j] = 0; &#125; else &#123; f[i][j] = -1; &#125; &#125; &#125;&#125;/** * 对背包问题实现记忆化 * * @param i * 先考虑的物品数量 * @param j * 剩余可装入物品重量 */public static int mfkNapsack(int i, int j) &#123; // TODO Auto-generated method stub if (i == 0||j == 0) &#123; return 0; &#125; int Value = -1; if (F[i][j] &lt; 0) &#123; if (j &lt; weight[i]) &#123;// 如果可承重量比物品的重量还小，那么就换下个物品 Value = mfkNapsack(i - 1, j); &#125; else &#123; int fir = mfkNapsack(i - 1, j); int sed = value[i] + mfkNapsack(i - 1, j - weight[i]); if (fir &gt; sed) &#123;//不加入这个物品的价值与加入之后的对比看谁最大，用递归方式 Value = fir; &#125; else &#123; Value = sed; &#125; &#125; &#125; F[i][j] = Value; return F[i][j];&#125;public static void showTable(int[][] table) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; table.length; i++) &#123; for (int j = 0; j &lt; table[i].length; j++) &#123; System.out.print(table[i][j]+"\t"); &#125; System.out.println(); &#125;&#125; 币值最大化所谓币值最大化，就是给定一排的n个硬币。选择硬币使得在其原始位置不相邻的条件，所选的硬币总金额最大，代码如下： 12345678910111213141516171819202122/** * 币值最大化的问题（原始位置不相邻的条件下） * @author LiuQun * 包括最后一枚硬币和不包括最后一枚硬币。公式为：max&#123;F（n-2）+c[i],F[n-1]&#125; */public static void main(String[] args) &#123; int[] coin = &#123;5,1,2,10,6,2&#125;; int res[] = new int[coin.length]; res[0] = 0; res[1] = coin[0]; for(int i = 2;i&lt;coin.length;i++)&#123; if (coin[i]+res[i-2]&gt;res[i-1]) &#123; res[i] = coin[i]+res[i-2]; &#125;else&#123; res[i] = res[i-1]; &#125; &#125; printArray(res);&#125; 找零问题所谓找零问题就是给定一定额度的币值数组，然后通过动态规划，找了需要找零的最大面值的剩余的最小，每次都最小，到最后就到达了最少的币值张数（暂时有点遗憾没把找零的钱是哪几张给找出来）。代码如下 123456789101112131415161718192021222324252627282930313233343536373839/* 找零问题 * F[n] = min&#123;F(n-dj)&#125;+1 * @author LiuQun */public static void main(String[] args) &#123; System.out.println("请输入一个整数："); Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] d = &#123;0,1,2,5,10,20,50,100&#125;; System.out.println(changeMaking(d,n)); &#125;public static int changeMaking(int[] d, int n) &#123; // TODO Auto-generated method stub int[] F = new int[n+1]; F[0] = 0;//不找零的时候0张币 int temp = 1000; for(int i = 1;i&lt;=n;i++)&#123;//1到n块的零钱（遍历F数组） temp = 1000; int j = 1;//第一个币值开始算 while (j &lt; d.length &amp;&amp; i &gt;= d[j]) &#123;//币值范围内，且要找零的钱大于这个币值 //如果只需要找零(i-d[j])块,而且这几块要比之前的中转值小，那就换成新的（i-d[j]）【相当于用20找零之后发现有50这样的，就替换了】 if (F[i-d[j]] &lt; temp) &#123; temp = F[i-d[j]]; &#125; j += 1; &#125; //F[i-d[j]]只比F[i]少了一个d[j]的币，所以+1 F[i] = temp+1; &#125; //printArray(F); return F[n]; &#125; Warshall算法有向图G，求图G中每一对顶点间是否连通的问题。代码与详细注释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author LiuQun * 邻接矩阵-----&gt;有向图传递闭包 * 从不允许中间有任何一点到可以允许更多中间点构建临接矩阵 */public class Warshall &#123; public static void main(String[] args) &#123; //邻接矩阵 int R[][] = &#123; &#123;0,1,0,0&#125;, &#123;0,0,0,1&#125;, &#123;0,0,0,0&#125;, &#123;1,0,1,0&#125;&#125;; int n = 4; //①如果一个元素在R(k-1)中是1，那么在R(k)中也是1 //②如果在R[i][j](k-1)中是0，当且仅当第i行k列的元素与第k行j列的元素都为1时，该元素在R(k)中变为1 //关于第二条其实就是一个十字框，除开十字相交的点，两条轴上都有1时，那么以这两1为顶点（已经有三点），长方形的第四点即在下一次也变为1 for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (R[i][j] == 1||(R[i][k]*R[k][j]==1)) &#123; R[i][j] = 1; &#125; &#125; &#125; &#125; showR(R); &#125; public static void showR(int[][] table) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; table.length; i++) &#123; for (int j = 0; j &lt; table[i].length; j++) &#123; System.out.print(table[i][j]+"\t"); &#125; System.out.println(); &#125; &#125;&#125; Floyd算法Floyd算法 又称为插点法，是一种用于寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。通过一个图的权值矩阵求出它的每两点间的最短路径矩阵。 其状态转移方程如下：map[i,j]:=min{map[i,k]+map[k,j],map[i,j]}：指的是i，与j之间的最小距离是i到k与k到j之间距离之和小于i与j直接距离 之前帮同学做了一个建立医疗站的案例也是用的本算法，设置不可到达的点为一个巨大无比的数字，超过那个数字的都认为亮点之间不可到达。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args) &#123; int[][] arr = new int[][] &#123; &#123; 0, 1, unReach, 1, 5 &#125;, &#123; 1, 0, unReach, 4, 2 &#125;, &#123; unReach, unReach, 0, 2, unReach &#125;, &#123; 1, 4, 2, 0, 7 &#125;, &#123; 5, 2, unReach, 7, 0 &#125; &#125;; printArr(arr, length); //初始化距离数组 int[][] dis = new int[length][length]; for (int i = 0; i &lt; length; i++) &#123; for (int j = 0; j &lt; length; j++) &#123; dis[i][j] = arr[i][j]; &#125; &#125; //floyd算法 for (int k = 0; k &lt; length; k++) &#123; for (int i = 0; i &lt; length; i++) &#123; for (int j = 0; j &lt; length; j++) &#123; //i，与j之间的最小距离是i到k与k到j之间距离之和小于i与j直接距离。 if (dis[i][j] &gt; dis[i][k] + dis[k][j]) &#123; //状态公式 dis[i][j] = dis[i][k] + dis[k][j]; &#125; &#125; &#125; &#125; System.out.println("---------结果是----------"); printArr(dis, length);&#125;/** * 方法简述：打印数组，调用可以在控制台输出最近距离的那个矩阵 * @param arr 数组 * @param n 数组长度 */public static void printArr(int[][] arr, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.print(arr[i][j] + "\t"); &#125; System.out.println(); &#125;&#125; 最优二叉查找树]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c++基础学习]]></title>
      <url>%2F2016%2Fc-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[2016-08-11到今天为止只学习了慕课网的基础课程C++远征之起航篇根据这之前的学习总结下： 多了bool类型变量，表示：true,false 输入输出语句 命名空间 代码编写技能 2016-09-04日补充 const字 引用（指针） 函数特性 2016-09-06日补充 封装类 初始化对象 对象的访问 输入输出语句输出 输出语句比较简单，就是cout&lt;&lt;x&lt;&lt;endl; 更详细的不想细说，输出两个变量时：x后面可以继续&lt;&lt;y再输出其他的这样（cout&lt;&lt;x&lt;&lt;y&lt;&lt;endl）。 endl与回车一个意思，可以不要。 输入 cin&gt;&gt;x 然后这个值就已经在x上了。 命名空间namespace是我在c++中见过的比较独特的东西（java，c中都没见过），可以在里面写方法写属性，感觉跟java中静态类有点像，不需要实例化这些：定义：12345namespace myNum //填写命名空间的关键字&#123; int x = 105;&#125; 使用（在一个文件内不需要using myNum）:1234567using namespace std;//标准命名空间，输入输出那些关键字if (myNum::x % 2 == 0) &#123; //改变状态位的值，使其为false isFlag = false; &#125; 代码编写技能我是用VS来编写代码的，新建项目之后，有个解决方案的东西，一个解决方案对应一个项目对应一个main方法，多个文件里都有main方法会报错。还有就是最后一句一定要加上system(“pause”)；不然看不到运行结果 const字① const int a = 3;② int const a = 3;③ int const p = 3;④ const int p = 3;①，②两句完全等价，不能再对a改变赋值,③，④两句完全等价 但是，int * const p = 3与③，④不等价，也可以两处都加const const p这样不能对p改变赋值 const p不能通过p来改变赋值两处都使用const时，不能通过p,p来改变赋值int const a = 3;指针指向const修饰的变量时，应该是const int const p = &a; 123456789//定义常量countconst int count = 3;const int *p = &amp;count;//打印count次字符串Hello C++for (int i = 0; i &lt; count; i++)&#123; cout &lt;&lt; "Hello imooc" &lt;&lt; endl;&#125; 引用普通类型123int a = 3;int &amp;b = a;//b为a的别名 构造类型： 12345678910111213typedef struct &#123; int x; int y;&#125;Coor;void quoteTest() &#123; Coor c; Coor &amp;c1 = c; c1.x = 10; c1.y = 20; cout &lt;&lt; c.x &lt;&lt; c.y &lt;&lt; endl;&#125; 指针类型： 12345int a =10;int *p = &amp;a;int *&amp;q = p;//指针p指向a;q是p的别名,改变*q的值也会改变a的值 在作为函数参数时： 123456789void fun(int &amp;a,int &amp;b)&#123; //交换 int c = a; a = b; b = c;&#125;int x = 10;int y = 20;fun(x,y)； 别名必须对应一个真实的变量：int &amp;b = NULL;这种写法是错的;引用不能单独存在：int &a;这种写法也是错误的。 函数特性可以在参数列表进行设置默认值。但一定要在最右端；在声明的时候加默认值，在定义的时候不加默认值。实参覆盖默认值 ；名称相同，参数可变。 1234567891011121314151617181920212223//三种都可以调用functionTest(10,2,3); functionTest(10, 2);functionTest(10);functionTest(10,2.2,3.3); functionTest(10, 2.2222);functionTest(10.222);void functionTest(int i, int j = 10,int k = 20);void functionTest(int i, int j, int k ) &#123; cout &lt;&lt; i &lt;&lt; j &lt;&lt; k &lt;&lt; endl;&#125;void functionTest(double i, double j = 10,double k = 2.3333); void functionTest(double i, double j, double k ) &#123; cout &lt;&lt; i &lt;&lt; j &lt;&lt; k &lt;&lt; endl;&#125; 内联函数只是一种编译方式，是建议内联函数，要求逻辑必须简单，不能有递归，不能有循环 1234567891011121314151617181920212223242526272829 inline void change(int &amp;b,int &amp;a)&#123; //交换 &#125;``` ## c++内存管理 ##new 关键字申请内存，delete释放内存； new和delete一定要配套使用 ```cpp int *p = new int; *p = 20; delete p; //在堆中申请100个char类型的内存 char *str = new char[100]; //拷贝Hello C++字符串到分配的堆中的内存中 strcpy(str, "Hello imooc"); //打印字符串 cout &lt;&lt; str &lt;&lt; endl; //释放内存 delete[]str; str = NULL; 申请内存有可能不成功；判断是否申请成功：123456int *p = new int（20）;//同时进行初始化if(p == NULL)&#123;//内存分配失败//异常处理&#125; 封装类c++的类是通过关键字class来表示的。对于类里面的属性和方法的访问控制由private,public,protect来控制的(含义与java里面类似)。 一般把public写在前面，private写在后面。具体实例代码如下。 12 初始化对象c++的对象的初始化对象有两种，一种是在栈上初始化，一种是在堆上初始化。 栈上分配的方式不需要new关键字申请内存，相应的也不需要delete来释放内存，用一个‘.’来访问这个对象内部的数据和方法； 堆上分配的方式就是普通java对象实例化的方式，通过new关键字来在堆上申请内存，同时也必须通过delete来释放申请的内存，通过‘-&gt;’来访问对象内部的数据和方法。 具体的实例代码如下： 12 对象的访问与java类似，数据域如果可以直接访问是不科学的，违背了面向对象的原则，所以要进行访问控制。一般来说就是要将所有的数据域（属性）都要设置为private，而根据需求来确定是否需要编写get/set方法。 代码如下： 12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法]]></title>
      <url>%2F2016%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[排序复习排序算法复习了好久，一直进度缓慢，因为有个叫做堆排序的一直拦着我，强迫症真的不理解这个就没办法做下一个……然后就一直卡在这儿，边写博客边把这个算法攻克了去看其他的算法了。八大排序： 冒泡排序 选择排序 快速排序 归并排序 插入排序 希尔排序 堆排序 桶排序/基数排序 冒泡排序冒牌排序从大一学C语言就已经学了，根据排序规则，前面的与后面的比对，违背了规则的就交换位置，代码如下：1234567 for (int i = 0; i &lt; arr.length; i++) &#123; for(int j = i+1;j&lt;arr.length;j++)&#123; if (arr[i]&lt;arr[j]) &#123; swap(arr, i, j); &#125; &#125;&#125; 选择排序也是大一就是学的，每次找出最大或者最小的，然后与已排序到第几位的那个位置交换，可以二元选择，同时找最大和最小，省时间： 1234567891011121314151617181920for (int i = 0; i &lt; arr.length; i++) &#123; int maxIndex = max(arr,i); if ( maxIndex != i) &#123; swap(arr,maxIndex,i); &#125; &#125;//找最大的索引值 public static int max(int[] arr,int start) &#123; int max = arr[start]; int maxIndex = start; for (int i = start; i &lt; arr.length; i++) &#123; if (arr[i]&gt;max) &#123; max = arr[i]; maxIndex = i; &#125; &#125; return maxIndex; &#125; 快速排序快速排序，要找到 中间的那个元素，通过中间的那个元素把元素分为比基准元素大的，比基准元素小的，两头同时用指针，两边都不符合（头（i）比基准大且尾部（j）比基准小）则交换，直到i&gt;j的时候，i就是那个中间元素，就是基准元素应该待的位置：代码如下 1234567891011121314151617181920212223242526272829public static void quickSort(int[] arr,int low,int high) &#123; if (low &lt; high) &#123; int middle = getMiddle(arr,low,high); quickSort(arr, 0, middle-1); quickSort(arr, middle+1, high); &#125; &#125;public static int getMiddle(int[] arr, int low, int high) &#123; // TODO Auto-generated method stub int temp = arr[low]; while (low&lt;high) &#123; //找到后面半截比基准元素还大的元素就停止 while (low&lt;high&amp;&amp;arr[high] &lt;= temp) &#123; high -- ; &#125; //将后面那个大的赋值到基准元素那里 arr[low] = arr[high]; //找到前面半截比基准元素还小的元素就截止 while (low&lt;high &amp;&amp; arr[low] &gt;= temp) &#123; low ++; &#125; //将前面小于基准的元素和后面大于基准的元素置换 arr[high] = arr[low]; &#125; //low就是基准元素应该呆的位置 arr[low] = temp; return low; &#125; 归并排序所谓归并就是两组两组的合并然后排序。需要一个中转的数组。 12345678910111213141516171819202122232425262728293031323334353637public static void mergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex) &#123; // TODO Auto-generated method stub //递归调用mergeSort来对数组进行排序表 int midIndex; if (startIndex &lt; endIndex) &#123; midIndex = (startIndex + endIndex) / 2; mergeSort(sourceArr, tempArr, startIndex, midIndex); mergeSort(sourceArr, tempArr, midIndex+1, endIndex); merge(sourceArr, tempArr, startIndex, midIndex, endIndex); &#125;&#125;/** * 将B,C数组合并到A数组中 */public static void merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex) &#123; // TODO Auto-generated method stub int i = startIndex, j=midIndex+1, k = startIndex; //交叉的 while(i!=midIndex+1 &amp;&amp; j!=endIndex+1) &#123; if(sourceArr[i] &gt;= sourceArr[j]) tempArr[k++] = sourceArr[j++]; else tempArr[k++] = sourceArr[i++]; &#125; //B数组剩下的 while(i != midIndex+1) tempArr[k++] = sourceArr[i++]; //A数组剩下的 while(j != endIndex+1) tempArr[k++] = sourceArr[j++]; //将中转的数组那段的值赋值到原来的数组里 for(i=startIndex; i&lt;=endIndex; i++) sourceArr[i] = tempArr[i];&#125; 插入排序插入排序就是默认第一个都是已经排序了的，然后后面的元素一个一个插入进去： 12345678910111213//默认第一个是有序的，后面再一个一个插入 for (int i = 1; i &lt; arr.length; i++) &#123; if(arr[i] &gt; arr[i-1])&#123; int j = i-1; int temp = arr[i]; while (j&gt;-1&amp;&amp;temp &gt; arr[j]) &#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = temp; &#125; &#125; 希尔排序希尔排序是先将数组分为几组，每一组有d个，然后慢慢的将d减小为1为止是成功排序（d,d/2,d/4……）先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 12345678910111213141516int d = arr.length/2; if (d%2==0) &#123; d = d+1; &#125; while (d&gt;0) &#123; for(int i = 0;i&lt;arr.length-d;i++)&#123; if (arr[i]&gt;arr[i+d]) &#123; swap(arr, i, i+d); &#125; &#125; d = d/2; if (d&gt;0&amp;&amp;d%2==0) &#123; d = d+1; &#125; printArray(arr); &#125; 堆排序堆排序在我看来的话就是把不规则的堆弄成规则的大顶堆或者小顶堆。因为这个东西对我来说比较抽象，所以更详细的写。思想： 数组当做是无序的堆。 将最大的记录和最后一个记录R[n]交换。所以最后一个记录是有序的，之前的R[1……n]都是无序的。 再将R[1……n]中最大的与它最后一个交换。 重复3直到无序区只有一个元素为止。 操作： 建堆（数组本身） 调整堆（成大顶堆）：思想的2，3 堆排序（不必要。既大顶堆调整为小顶堆） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class HeapSort &#123; public static void main(String[] args) &#123; int[] arr = new int[] &#123; 23, 32, 45, 54, 34, 24, 46, 35, 26 &#125;; buildMaxHeapify(arr); heapSort(arr); System.out.println(Arrays.toString(arr)); &#125; //构造大顶堆 private static void buildMaxHeapify(int[] data) &#123; // 没有子节点的才需要创建最大堆，从最后一个的父节点开始 int startIndex = getParentIndex(data.length - 1); // 从尾端开始创建最大堆，每次都是正确的堆 for (int i = startIndex; i &gt;= 0; i--) &#123; maxHeapify(data, data.length, i); &#125; &#125; /** * 将大顶堆调整为小顶堆 * 排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的 * * @paramdata */ private static void heapSort(int[] data) &#123; // 末尾与头交换，交换后调整最大堆 for (int i = data.length - 1; i &gt; 0; i--) &#123; int temp = data[0]; data[0] = data[i]; data[i] = temp; maxHeapify(data, i, 0); &#125; &#125; /** * 创建最大堆 * * @paramdata * @paramheapSize需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了 * @paramindex当前需要创建最大堆的位置 */ private static void maxHeapify(int[] data, int heapSize, int index) &#123; // 当前点与左右子节点比较 int left = getChildLeftIndex(index); int right = getChildRightIndex(index); int largest = index; //index位置的值比他的左孩子小 if (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) &#123; largest = left; &#125; //index位置的值比它右孩子小 if (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) &#123; largest = right; &#125; // 得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要以被调整的那个子孩子重新调整为父节点继续调整 if (largest != index) &#123; int temp = data[index]; data[index] = data[largest]; data[largest] = temp; maxHeapify(data, heapSize, largest); &#125; &#125; /** * 父节点位置 * &gt;&gt;表示右移 15&gt;&gt;2=3,3&gt;&gt;1=1 * &lt;&lt;表示左移 3&lt;&lt;1 = 6,5&lt;&lt;1 = 10 * @paramcurrent * @return */ private static int getParentIndex(int current) &#123; return (current - 1) &gt;&gt; 1; &#125; /** * 左子节点position注意括号，加法优先级更高 * * @paramcurrent * @return */ private static int getChildLeftIndex(int current) &#123; return (current &lt;&lt; 1) + 1; &#125; /** * 右子节点position * * @paramcurrent * @return */ private static int getChildRightIndex(int current) &#123; return (current &lt;&lt; 1) + 2; &#125;&#125; 桶排序/基数排序对于我来说，这个算法比堆排序还陌生，因为感觉听都没听过…… 对于数组：73, 22, 93, 43, 55, 14, 28, 65, 39, 81 首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中 接下来将这些桶子中的数值重新串接起来，成为以下的数列：81, 22, 73, 93, 43, 14, 55, 65, 28, 39 接着再进行一次分配，这次是根据十位数来分配 接下来将这些桶子中的数值重新串接起来，成为以下的数列：14, 22, 28, 39, 43, 55, 65, 73, 81, 93 这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。 代码听起来不难，自己调整写的代码如下： 12345678910111213141516171819202122232425262728293031323334public static void sort(int[] number, int d) //d表示最大的数有多少位&#123; int m = 1; int n = 1; int k = 0; int[][] temp = new int[10][number.length]; int[] order = new int[10];//order[i]表示该位（个，十）时i的数的个数 while (m&lt;=d) &#123; //归相应的桶中 for (int i = 0; i &lt; number.length; i++) &#123; int lsd = (number[i]/n)%10; temp[lsd][order[lsd]] = number[i]; order[lsd]++; &#125; //从桶里读出来 for (int i = 0; i &lt; 10; i++) &#123; if (order[i] != 0) &#123; for (int j = 0; j &lt; order[i]; j++) &#123; number[k] = temp[i][j]; k++; &#125; order[i] = 0;//恢复为0为下一位做准备 &#125; &#125; n *= 10; k = 0;//恢复为0为下一位做准备 m++;&#125; &#125; 总结排序是很常见的算法，除了对堆排序，其他都很容易理解，时间复杂度各不相同。各种排序的稳定性，时间复杂度和空间复杂度总结： 时间复杂度增长情况]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[复习计划]]></title>
      <url>%2F2016%2F%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
      <content type="text"><![CDATA[反省&emsp;&emsp;今天是几月几号我都不想提醒我自己了，老油条大概说的就是我这种人吧。之前的复习还是乱七八糟复习了些算法的排序算法，接下来应该真正的复习了。 复习目标&emsp;&emsp;所谓复习目标，其实我就是归纳复习的科目。 算法分析 网络 计算机操作系统 Linux c++ 第一行代码 Android 艺术探索 复习安排&emsp;&emsp;接下来到找到工作还有大概4周。 c++在手机慕课网上学习，然后每天下午花一小时左右做一些编程练习。 算法分析：排序，最短路径等。这周之内把它复习完。看书和写代码。 计算机操作系统：看书，看Linux的书，还有慕课网Linux。务必在一周之内完成。 网络还是比较重要的东西，但是20号我得到西宁去一趟，中间大概得耽搁5天左右，这几天就专门看网络，在这耽搁的一周内完成。 剩下的都是Android的东西了。基础控件我忘了挺多了。花3天时间整理下基础控件，然后将小猪的菜鸟博客看了，代码实现部分。 完成上面的东西的话，时间的话应该已经是9月左右了，撇开综合课程设计。这之后都是看Android进阶的东西。首先得把Android艺术探索看完，时间应该在1周左右，完成部分代码。 笔试面试&emsp;&emsp;接下来的时间真的就是做笔试题，投简历的时间了。通过做一些笔试题，完善自己。并且在平常也尽量每天花一小时左右做笔试题。&emsp;&emsp;张这么大没怎么参加过面试，我这个人比较容易紧张，我得怎么克服我自己的紧张呢？&emsp;&emsp;感觉越来越紧张，时间越近越沉不住气，虽然我还没好好复习呢。&emsp;&emsp;既然是复习，我就不要沉迷在看书里面。最多只能看5本书，可以买，但是必须得到offer之后才能看。至于漫画，动漫就先暂停吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[观《钱学森》有感]]></title>
      <url>%2F2016%2F%E8%A7%82%E3%80%8A%E9%92%B1%E5%AD%A6%E6%A3%AE%E3%80%8B%E6%9C%89%E6%84%9F%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;既是因为毛中特课程的作业，也是对钱学森先生的敬佩看了这部电影。关于电影技术，演员演技之类的我就不讨论了，因为我是门外汉。我想讨论的就是电影想要传播给我们的东西。 &emsp;&emsp;钱学森先生在美国加州理工大学任终身教授，接到当时的国内北方的联系就下定决心回国，但此时还在理工大学任教。就在之后不久，他被美国政府怀疑与中国共产党有联系，被监狱拘留审问之后决定驱逐钱学森。 &emsp;&emsp;我相信任何一个人都不能无视这种侮辱，这使他回国的愿望更加迫切。钱学森回家之后安排订了最近时间的一个航班，行李都打包运出去了。没有人能想到的是，倡导民主的美国以怀疑他带走美国机密为由撬了他的行李，一点一点进行检查。这一次被拘留更久，甚至要花钱来保释他。 &emsp;&emsp;其间的详情不必赘述，帝国主义的狭隘我能理解，毕竟钱先生是这么这么的重要，但是理解不代表支持，他们完全的违背他们自己所说的民主。在钱学森先生几乎被软禁在美国时，钱学森先生依然潜心著作，完成了《工程控制理论》。偶然的机会，他在报纸上看到陈叔通站在天安门城楼上，身份是全国人大常委会副委员长，他决定给这位父亲的好朋友写信求救。周恩来总理与毛主席不惜用是战俘的美国飞行员来换钱学森先生安全回国，并且周恩来总理在与美国外交谈判上的不断周旋。终于，1955年，在钱学森同志44岁的时候回国了。 &emsp;&emsp;钱学森先生的一位美国朋友问他，“中国没有航空科技，一点都没有，一个杰出的航空科学家回到农耕社会，能做些什么呢？”&emsp;&emsp;钱先生微笑，眼里带着光，“在我的祖国，我做什么都行，如果我想，我可以去种苹果（之前美国军官嘲讽他回国只能够种苹果）。” 然而钱学森先生在中国种的苹果树终于在原子弹，导弹顺利爆炸时结出了丰硕的果实。 &emsp;&emsp;40多年后，冯·卡门先生与钱先生做最后的告别时，说他是‘你已经是世界知名的科学家’，这样的评价钱学森先森当之无愧。 &emsp;&emsp;钱先生的妻子蒋英女士说，“我们国家可以没有一个叫蒋英的歌唱家，但不能没有钱学森的科学家。”爱国不仅仅是钱学森同志，而蒋英女士的奉献才能使得钱先生能在核事业中完全的奉献自己。 &emsp;&emsp;钱学森先生从发达的美国历经艰辛才回到了中国，那时中国的航空技术几乎还在水平线上，这样大的难度钱先生不是不知道，但还是毫不犹豫的接下，只要了两个东西：人和地。钱学森先生面对组织真诚，毫无保留。他是一代人的偶像，就像影片结尾处很多士兵来看他工作时说的：钱教授，在我入伍时我就知道你了。 &emsp;&emsp;他是一代又一代人的偶像，也是他们的老师。 &emsp;&emsp;钱学森教给我们怎么样爱国，怎么样在重任面前转压力为动力，交给我们热爱科学，一位干部对钱学森先生说：“钱院长，这下我服你了”，钱学森回复说，不是服我，是服科学。 &emsp;&emsp;21世纪，科学技术是第一生产力。热爱科学是每个人应具备的素质，如何用自己掌握的科学技术报效祖国使我们应该从钱先生身上学习到的，而且，现在我们还处在学习的阶段，应该更加专注地学习，要学就要学到最极致。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《沧浪之水》与我的幼稚]]></title>
      <url>%2F2016%2F%E3%80%8A%E6%B2%A7%E6%B5%AA%E4%B9%8B%E6%B0%B4%E3%80%8B%E4%B8%8E%E6%88%91%E7%9A%84%E5%B9%BC%E7%A8%9A%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;看《沧浪之水》这本书之前，我有点害怕打开这本书而写了一些类似读前感想的文字，然而作品与我的想象完全不同，展开了一个我完全无法想象的故事。 &emsp;&emsp;沧浪之水清兮，可以濯吾缨；&emsp;&emsp;沧浪之水浊兮，可以濯吾足。 &emsp;&emsp;读完这本书，这一首沧浪之歌在我的心里回荡，我甚至不用去查它的调子，我自己自然有我的调子。 &emsp;&emsp;池大为，他研究生毕业成为卫生厅的一个办事员，也是这个厅第一个研究生。开始他以为是马厅长器重他这个人，后来才清醒过来——他只是一个门面。所有的知识分子都有通病就是把世界都作为自己责任的病，改变世界是它们的梦想（虽然一般都不得实现）。 &emsp;&emsp;在伪装实事求是的马垂章面前，天真的池大为显得太稚嫩，他以为的有话就说就是有话就说，在会议上提出出去花费太大的时候，池大为注定要出局了，或许更早，在池大为看到父亲的《中国历代文化名人素描》时已经注定他的一生要出局太多次。 &emsp;&emsp;在中医学会的那几年，他完成了娶妻生子的重要大事，这也有了促使他改变的力量。是的，到现在为止我都认为是他的妻子，他的儿子在不断的逼他改变。研究生出身的他看不起丁小槐这样奴颜婢膝的人，当丁小槐升到主任搬离筒子楼的时候他还是个小科员。董柳（池大为妻子）逼得池大为一次又一次的拷问自己的内心，因为董柳说她儿子什么都要最好的，凭什么强强（丁小槐的儿子）有的他们一波（池大为的儿子）没有，我能理解她的母爱，几乎没什么理由来指责她。但她借着儿子这一挡箭牌不断的逼迫池大为，那一阶段，我太心疼池大为，我开始怀疑婚姻的意义是什么。 &emsp;&emsp;董柳这个人，一开始说着什么是为儿子要拥有更好的住房，两间房有了，想要住套间，套间有了住三室一厅，最后还是在说不满足要住新建大楼里面三楼朝西那个房，让她放弃几乎都像是在她身上割肉。我几乎断定，一开始董柳便是这样的人，只是当时没有借口给她发作，她会包容池大为的无能，但是当她有了挡箭牌之后，她开始了不断的冲锋陷阵，而这阵地就是她那无能的丈夫。她丈夫感激他的包容，对儿子的爱不断促使他难受，昨晚看到这样一段的时候我几乎抑制不住那种堵住了内心的感觉：&emsp;&emsp;“为了儿子妻子，我得挣扎，我有不可推卸的责任，活着是硬道理，没有比这个硬道理更硬的道理了。”&emsp;&emsp;“世界这么大，留给自己的空间却这么小，人就是这么可怜。”&emsp;&emsp;“双膝弯了又弯又有什么用？哭都找不到理由。” &emsp;&emsp;挣扎了6、7年除了内心难受妻子指责没有一点收获，决心陷入却只要半年就升了一级。 &emsp;&emsp;挣扎过程中，池大为一次又一次告诉自己要改变，让自己安心沉沦：&emsp;&emsp;“我心有不甘，不甘，但别无选择。”&emsp;&emsp;“权和钱，这是世界的主宰，是怎么也绕不过去的硬道理。”&emsp;&emsp;“为此我得改变自己，我并不比谁傻些。”&emsp;&emsp;“牺牲和坚守都是一种说法的时候，牺牲就变得意义暧昧。”&emsp;&emsp;最后的最后，在儿子受伤见过种种之后，一切都变得开朗起来，他开始找缝来当机会。而机会总是留给有准备的人这句话没错，给马垂章的孙女打针这个机会被他们稳稳抓住，打针守了几天之后，给妻子调换工作岗位，回谢马厅长夫人……池大为的职业生涯这时顺风顺水了:科长——副处长——处长——厅长助理——副厅长——厅长。真的有些事情你放下负担之后就来得很快。 &emsp;&emsp;在看书的时候，我替池大为难受，希望他赶快改变，他改变之后我也替他担心，怕他让我失望。 &emsp;&emsp;他与孟姓女子有过一段情，但他理智的掐断了，他明白自己不可能离婚，也是不想耽搁24岁的女子自己寻找幸福，更怕她毁了自己官路，所以他放弃了那女子（虽然那个女子纯粹真心的可能性也小）。当他与这女子产生些感情时，我替他担心，害怕他走上传统官员的腐败之路。 &emsp;&emsp;池大为说：毕竟，我是迟永昶（chang）的儿子。 &emsp;&emsp;他的底线还是有的，不敢接受贪污，不敢包养情妇。希望做个好官，于是，六十万的贿赂退回，虽然他也心动；孟女士被拒绝，虽然他也说过喜欢这个女子；他让小龚去中医学会历练几年，虽然他看重他。 &emsp;&emsp;说到小龚，当年的马厅长是这样想的么？池大为在大会上提意见之后也被派到了中医学会，历史的必然性也有巧合性，若干年后的小龚，会成为有些底线的池大为还是没有底线的丁小槐？ &emsp;&emsp;在同学会上，池大为不断的出局，在与屈姓女子的恋情中出局，在工作中不断的出局。池大为想要证明自己是个能干的人，但是时代不给他机会，于是他扭曲自己找了机会，成了后来的池大为。在成为厅长之后还是想要证明自己，整理小金库，让群众提意见……打算大干一番的时候，他的兵跟他唱反调了，而且他发现如果要这样改，他的利益也会被不断截肢，于是不了了之，做了些细小的改变便罢了。那时候我既心痛他，又开始怀疑这个池大为还是不是之前的池大为？我忘了我自己当时也在多么希望他改变。 &emsp;&emsp;当池大为在父亲坟前将那本《中国历史人物素描》这本书烧了的时候，我似乎意识到池大为真的不是池大为了，也许他会变成与马垂章一模一样的人。这便是中国官场了……&emsp;&emsp;“父亲，现在是我，你的儿子，站在这里。也许，在这个世界上，我是唯一能够理解你的人。虽然我没有以你的方式面对世界。你相信人性的善良，相信时间的公正，把信念和原则置于生命之上。你对世界的理解有着浪漫的崇高，而没有显示的庸人气息。我理解你以知其不可为而为之的姿态，那样从容不迫地走向了牺牲的意义。在我看来，你是大智若愚。……而我，你的儿子，却在大势所趋别无选择的口实之中随波逐流地走上了另一道路。”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[害怕悲剧]]></title>
      <url>%2F2016%2F%E5%AE%B3%E6%80%95%E6%82%B2%E5%89%A7%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;昨晚费劲的在网站的推荐上整理了最近想要看的书，然后我在当当上买了一本《沧浪之水》。这本书推荐者写的是一个医生想要做正直的人，却最终在利益与良心之间找到平衡。我没经历社会，我不知道这里面会是多么的黑暗，我真正在今天可以看的时候我却不敢翻开这本书。 &emsp;&emsp;我害怕看到悲剧，害怕看到人受苦，更痛恨的是自己无法帮到他们。不论是我叔叔和哥哥那样的在工地上的民工，还是泰山挑水工那样的人，或是学校静湖那里推石头的大叔们。他们在烈日下工作，手都被烫起泡，肩膀被打起茧也还是在工作，因为要养活家里人。这样的人生当然不是悲剧，依着自己的劳动获得报酬，只是这样的生活很苦。但是有的人劳动已经很辛苦，但却在某日放假的时候和工友打牌而把钱给输了，导致自己抱怨社会抱怨家人抱怨其他，那这就是悲剧了。 &emsp;&emsp;人生都是一次又一次的选择，选择错了不要紧，但是自己知道选择错了但却坚持一条道走到黑的人，迟早都是悲剧。还有一些人，命运给他们安排了太多的坎坷，不得不成为悲剧。我不敢说什么坚持，什么原则，在那样一个境遇下，我大概更坚持不住就会妥协。 &emsp;&emsp;某些层面来说，书中的悲剧更让人记忆深刻，之前看《无声告白》的时候，那个女孩最终还是死了。这么久我还能清晰的记得这个女孩是怎么一步一步踏上那条路，也能记得她心里的矛盾挣扎。但相反的另外一本同一时段看的一本《孤独小说家》，青田先生最终还是获得了直本奖，但我对他的日常的生活怎么度过，他在第一次错过直本奖的时候压下嫉妒大方祝贺的这些经历记不太清了。 &emsp;&emsp;当然，我相信，让人记忆深刻写悲剧不是作家的目的。 &emsp;&emsp;往往不是发生在自己身上的我们都能淡然面对，但看书的时候我会不自觉的代入，想象受苦的那人是我，只有他们做出了和我自己不一样选择的时候才会意识到我还是我，但是之后就是惭愧，我不如他。有的悲剧是让你在发笑的时候不自觉戛然而止，我害怕这种笑着笑着眼泪就出来的境况；有的悲剧让人在读的时候心都要绷紧了，我害怕在那时候呼吸困难无法解脱的感觉。 &emsp;&emsp;说了这么多，其实书还没看。我想等书看了再写一个读后感。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记大三的最后一堂考试]]></title>
      <url>%2F2016%2F%E8%AE%B0%E5%A4%A7%E4%B8%89%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A0%82%E8%80%83%E8%AF%95%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;毛泽东概论与中国特色社会主义理论。这是最后一门考试的内容，这是一堂开卷的考试，我不知道怎么样才能表达我内心的惆怅，因为这是读书生涯中最后一次坐在教室考试了。我相信这一次考试不仅仅对我，对他们自己应该也是特别的。&emsp;&emsp;一个半小时的考试，我用尽全力的写，写完就要求交卷了，这也只是平常的考试罢了，考完了，我走在去实验室的路上，回想了我这十几年经历的大大小小的考试。或因为很重要所以很紧张，或因为是要排名次所以很认真，或因为没什么关系所以掉以轻心；但是所有的考试都是考完就轻松，而没有哪次考试是觉得这次考试完了就不会再有这样的考试了。 &emsp;&emsp;最后一次的考试完了意味着是准大四的人了（过不过这种问题应该不用说吧），意味着要开始复习找工作了，意味着再过不久就要成为社会人了，没有学校的保护伞，我不知道我会成为什么样的人，但是我很期待。&emsp;&emsp;昨晚和室友（郑阳）聊天，说到梦想这个话题，一个20岁的人没有明确的梦想大概是不可能的。&emsp;&emsp;郑阳说她的梦想以前是做一个女强人，但后面改变了，想做一个有工作，但能很顾着家里的女人，要经常旅行，想做老板娘。梦想这东西没什么好笑的，即使那样，那也是她要为之奋斗的生活。&emsp;&emsp;我的梦想呢？我的梦想是什么呢？&emsp;&emsp;我想到很久以前和爸爸相处的片段（去世七八年，其实忘了很多了）。那是国庆节，领导人在天安门还是车上什么的阅兵，那时候，我说我也想成为阅兵的那个人（记不得是爸爸问的还是我自己说的了）。那大概就是儿时的想法了，随着长大，想法慢慢的变化。&emsp;&emsp;我爸爸过世的时候我读初二，去得太突然，平时生龙活虎的人突然就倒下了，半小时就过世了，那时候我很庆幸我奶奶早几年过世了，不然老了还得经历一场伤心。但我的妈妈那个时候真的太难过了，我第一次看见这个坚强的人一只手撑在强上哭（后面这个人就变得常哭了）。那是我人生中第一次面临这样大的变故，我大概懂了疾病的可怕，先带走了我的奶奶，后面又带走了我的爸爸。那时候我懵懵懂懂的就想当医生了。&emsp;&emsp;高考的失败，我并没有强迫自己读医科。选了一个风马牛不相及的专业，因为内心丰富，而且一个人的生活实在是充满了诉说，那时候我看了很多小说（言情小说，玄幻小说），觉得自己也可以做一下文艺之人，迫使自己在网上注册了笔名，准备写小说，大一时还签约一本，但是都未完成就放弃了。&emsp;&emsp;人注定是要专注的做一件事才能真正的成，因为不专注所以没能坚持住也是正常。前一阵，我幻想了我以后想要的生活，在我有一些存款了的情况下，回到老家，陪着爸爸也是对自己的解放，种一点地，种一点菜，生活可以朴素，精神但是很充足，我可以伴着音乐，写点我想写的文字，就算没有什么想写的那我可以看些我想看的书，那种应该算是隐士的生活了。&emsp;&emsp;我不知道有没有那个机会实现我的梦想，我其实不怕嫁不嫁人这样的事情，但是若是我一辈子都过不上这样的生活我大概是不会觉得人生满足的吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[7.12-7.17学习心得]]></title>
      <url>%2F2016%2F7-12-7-17%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
      <content type="text"><![CDATA[我的絮絮叨叨&emsp;&emsp;本周周一是考试，所以周二就开始了我本科中的最后一个暑假了，然而这个暑假应该不算轻松的，因为要复习找工作啦，所以每周记录一下我的复习心得。&emsp;&emsp;这一周提高了些学习习惯，但是也没有达到一种投入的程度。而且对计划并不能每天完成，以致于周末的写博客推到了今天（另一周的周二）才完成。一是对任务的安排，二是对自己承诺的未完成的任务没有愧疚感的推时间。&emsp;&emsp;希望以后自己改正！！！ 概述所谓概述就是本周的复习目录 RecyclerView 单线程的断点续传 线程池 多线程的断点续传 RecyclerView&emsp;&emsp;一直有听说这个控件，终于自己动手去学了一下。这个控件自定义程度比ListView超出了大概不止一倍。其实这对我来说就是用起来感觉更麻烦了。 最基本要设置四个属性： setLayoutManager:有三个，线性，网格，瀑布流 setAdapter:这个Adapter不是继承BaseAdapter,而是继承的RecyclerView.Adapter setItemAnimator：这个是设置动画，可以用平移或者渐变什么的慢慢琢磨，一般用DefaultItemAnimator应该是默认的。 addItemDecoration：添加分割线，这个线性布局，网格布局应该是不一样的，画的东西不一样。如果只想用颜色分开的话，我建议不要采用这种方式，slider什么的可以设置的。 遇到的小问题&emsp;&emsp;我最开始创建项目就遇到了一个问题，那就是引入包的问题，最开始还以为是support.v7包里的一个类，直接引用却发现没有这个类，我内心那会儿大概是崩溃的，没有这个类我还玩儿啥啊。后面百度了发现那是得单独引用还得跟v7的包版本一致，然后是下面这样的：12compile 'com.android.support:appcompat-v7:23.2.1'compile 'com.android.support:recyclerview-v7:23.2.1' 未完成的一些&emsp;&emsp;里面效果还有很多，下拉刷新，空页面等效果没有实现，这些可能得自己找个时间把它完成才行了。 单线程的断点续传&emsp;&emsp;其实就是下载文件，可以开始，暂停，暂停之后再开始。与第一个单独的控件学习不同，这里面涉及了挺多的知识点的。 开启子线程来链接网络 如何下载文件 数据库操作 广播发送与接收 服务与Activity之间的交流 &emsp;&emsp;关于开启子线程里链接网络。因为主线程里面是禁止进行耗时操作的，所以链接网络放到子线程里面。想要传递的参数可以使用构造函数new的时候传递，利用Handler进行回传。尽量不要使用类变量直接线程和包含线程这个主类公用。&emsp;&emsp;创建两个实体类，文件信息和线程信息。线程信息主要是保存在数据库中，文件信息得是作为参数传递到服务，传递到初始化线程，还要传递到下载任务类。&emsp;&emsp;下载文件这个事情其实说起来很简单，创建一个文件，然后打开网络的输出流，将输出流输出到Byte数据（inputStream.read(buffer)），再把这个数组写到文件里（raf.write(buffer, 0, len)），就行了。但是要使用RandomAccessFile（raf = new RandomAccessFile(file, “rwd”)）来实现随机写入的功能，因为你要续传是从上次停止写的那里开始继续写。&emsp;&emsp;数据库操作，其实数据库操作我以前的习惯真的太差了，在JAVAEE里面我有使用接口的习惯，但是在Android里面这个习惯被我忘了，听了课之后才了解接口这个方法挺好的。Dao里面定义接口，Impl里面实现接口。&emsp;&emsp;广播的发送接收很简单，sendBroadcast就行，在Intent里面放入你的参数，在Activity里注册广播，IntentFilter来添加过滤决定接收哪些广播，再注册一下（registerReceiver(mReceiver, filter)）。1234mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123;&#125; &emsp;&emsp;开启服务用Intent添加参数，然后startService(intent)就开启成功了。Service里面用onStartCommand方法接收Intent带的参数就OK，然后再需要与Activity交流的时候发送广播就可以。有一点，Service也像Acitivity一样，要注册在manifests文件里面，自己也可以作为Context来传递。&emsp;&emsp;这个的学习，不仅仅是代码，更多的是分配怎么做一个东西，规划好类之间的通讯，然后再按照注释写步骤一步一步完成，比东做一点，西碰一点更有激励性，完成一步测试一步更是减少了出错的可能性。还要提高写注释的能力。 线程池&emsp;&emsp;线程池只是学习了Java自有的线程池，并没有自己着手写一个线程池的想法，所以学习得很简单。线程池分为四类： ExecutorService cacheThreadPool = Executors.newCachedThreadPool(); ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); 第一种是一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，没有数量限制。第二种是一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。例中只给了3个线程，但假如一样的任务有十个，这个会三个三个为组合完成任务。第三种是一个定长线程池，支持定时及周期性任务执行。括号里面是线程数目。第四种是一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 多线程的断点续传&emsp;&emsp;这个和单线程的断点续传很多都类似，我用了RecyclerView来改造了下页面，变成了多任务的（申明：单线程多线程都可以多任务的，只是大概得等）。&emsp;&emsp;使用了线程池，将任务放到了缓存线程池里面执行(单线程池大概适合单线程下载的时候)。修改了页面显示，修改了下载完成的标志，每个线程完都要检查是不是这个任务的所有的下载完了。还有对页面的刷新，500ms发送一次三个线程会刷新提高三倍，所以修改了页面刷新的代码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[和自己做朋友]]></title>
      <url>%2F2016%2F%E5%92%8C%E8%87%AA%E5%B7%B1%E5%81%9A%E6%9C%8B%E5%8F%8B%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;今天是寻常的一天，也是不寻常的一天。 &emsp;&emsp;像往常一般，7点过的闹钟把我闹醒。但是，我迷迷糊糊的意识到我今天并不用去实验室，倒头打算再睡一个回笼觉。 &emsp;&emsp;打开手机望一眼（完全是惯性，我相信很多手机控都有，不为了看什么，就只是为了放个心），有两个高中同学的消息。一个表示她要去荣昌了（去培训学校做兼职），另一个表示他要出发了（骑自行车去新校区，我在他们新校区附近）。嘱咐了熊同学路上小心，钱包放好，然后表示要睡回笼觉；又跟肖同学扯了个谎，说今天实验室有事，不能陪他去交大，然后放心开始睡觉。 &emsp;&emsp;醒来是肖同学的QQ消息，表示车子爆胎了，正在修理，我表示同情，让他回去，但他愿意继续骑行过来，我平常对这样不放弃的精神表示十万分的赞赏，但今天我并不乐意他来，主要是因为我没钱了，没钱出门别人请吃饭我都觉得不太安生。他执意，我的内心也开始了天人交战：&emsp;&emsp;“要不下午就去吧，大不了找人借点钱就出门了，反正也不一定会用！”&emsp;&emsp;“这不是用不用的问题，自己把钱用光了还借着用，借着还是这样的事，不能去借，要么空手去，要么不去！” &emsp;&emsp;最终我还是没去，下午睡午觉愣生生睡到了4点过。他到交大就3点过了，然后朋友们也没等他，这一天他的经历大概是算要有多凄凉就有多凄凉。他给我是这样说的：再不来我就回去了……太累了，车子踏板螺丝松了，很小一件事，但这边推着它走了1个小时，才终于找到一家可以把它拧紧的修车店。我真真切切的从他的话中感到疲累大概还有伤心，一方面我为自己不去的理由感到脸红，但更让我脸红的是大概好几周前我怂恿了他来找我们耍。他来了，我却怂了。我真正怂的原因应该不仅仅于此的，因为我们这边一般这样的聚会都是高中的都去，但是梅青松和邓伟都拒绝了他，我一个女生，其实也觉得挺尴尬的。我的自私暴露无遗，因为我害怕我自己尴尬，所以留他一个人尴尬，大概他那没有人知道的内心在我说了我不能去的时候是正在哭泣的。 &emsp;&emsp;大概是今天，我才感觉我是真正的失去我高中的很多情谊了。从最开始的一学期聚好几次，到现在一学期都不聊一次，我确实是能感受到这些变化的，但是我也无力挽回，我没有兴趣将时间花在网络聊天上，见面能见面的又少，越来越疏远也是无可避免。 &emsp;&emsp;每天都是平常的一天，每天也都是特殊的一天。我做着平常都在做的事情，没有去尽情的挥霍着我的激情，也没有睡一整天过去；今天的感想昨天从未有过，即使主题相同，但我也坚定今天比昨天更深刻了一些，更别说我昨天想都没有想得事情，就在今天却有了自己的思考。 &emsp;&emsp;同学在大学各有风姿，有的是学霸，收获恋爱或友谊，我只是最平常的度过，最平常的朋友，最平常的成绩。不能想象我以前也曾成绩顶尖（在我们那个班级），朋友成群，也有过我认为的暗恋。 &emsp;&emsp;一个人长相普通，成就普通，家庭普通，这样的人只能被沦为背景，在电影电视中称为群众演员。可以漠视这个人，但千万不能认为这个人就是木头人，你不知道他经历了什么，或者他什么也没经历，那他也是他心目中特别的一个，他也会为看了一本书而思考全人类的未来，也会看到地上的垃圾而担忧环境并作出反应。 &emsp;&emsp;作为普通人，我的忙碌，我的学习都只是最普通的一环，即使是我最亲密的朋友，最亲近的家人也没有兴趣多去了解；但作为我自己，我知道我今天看了几页书，书里的人的话或许哪里又触动了我，这些，我无须向他人诉说，那是特别的自己才能了解。 &emsp;&emsp;和自己做最亲近的朋友，即使是普通的一天，也是特别的一天；即使是最普通的普通人也是最特别的人。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的博客的搭建过程]]></title>
      <url>%2F2016%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[正文前的唠叨一名程序猿，没有个人博客说来惭愧，之前觉得搭建起来太麻烦就算惭愧也那么过了。今天看鸿洋大神的微信公众号推荐了博客搭建，方法看起来挺简单的，那我还能忍？ 至于为什么用hexo，用git……我懒得叙述了，反正就是他们了。 唠叨结束，下面开始正文 总体概述我个人昨天一天搭建博客的过程。走了比较多的弯路。其实过程总共也就分为以下几步： github注册，创建项目 安装git 安装node.js 安装hexo 配置hexo，访问你的博客 hexo文件目录 关于网站文件配置_config.yml的更多 写一篇文章 换主题 结束语 github注册，创建项目好奇github是什么，git是什么自己百度去。 注册地址：github创建项目：项目名是你的Username.github.io然后点击：setting 然后往下滑动到点击：lunch automatic page generator再然后就是一步一步往下就可以了 安装git这里不详细写了，网上下载git客户端，然后配置SSH因为这个教程基本不用git的命令，有兴趣的自己去学。安装和基本操作 安装node.jsnode.js的安装也是十分简单，甚至连环境变量都不需要，下载客户端，然后基本就可以了。以下也是一个教程：安装node.js 安装hexo终于到正题了，我都等不及了。以下是参考Chillax’s Blog 来的，基本博客的结构也跟他差不多，因为我就是大概照着他弄的呀，哈哈你问我有了他的你为麻子还要写？我乐意，不然我弄个人博客干嘛？ 言归正传，通过hexo不用写html页面,基本是用markdown写作，的常用命令 12345678910111213 hexo g #生成静态文件 hexo d #发布到github hexo s #发布在本地，localhost:4000 hexo n #新建一篇文章``` bash安装过程中如果报错：ERROR Deployer not found : github 运行下面几行： ``` bash npm install hexo-deployer-git --save hexo g hexo d 下面开始安装，选择一个地方，右键，打开git bash1npm install hexo-cli -g 然后开始部署你的博客了哈，决定好你的博客位置了之后，建立一个文件夹，随便取名(不要中文哟，不然我也不知道会发生什么)。例如我：F:\OwnPage\hexo\进入文件夹之后，再次打开git bash:依次输入命令12hexo init #下载搭建网站需要的文件npm install #这个时候显示出node.js的好处了，下载依赖包 哈哈，这个时候我们已经基本成功啦。我们在本地看一下：12hexo ghexo s 按提示打开localhost:4000，你就可以看见一个漂亮的博客网站了，没错，它就是你的了。 配置hexo，访问你的博客刚刚的成果已经让你很开心了吧，当时我也是的，但这只是本地预览，接下来会有更爽的。还记得我们第一步创建的项目吧，我们来得到他的一个地址：git@github.com……因为ssh协议似乎会快点，http的有时候还会不行。接下来打开你的网站文件夹，有个_config.yml（我表示第一次见这个后缀，但应该和xml相差不大吧），只是每个冒号后要有一个空格才能起作用，用文本编辑软件打开，记住不要用记事本，乱成一团。在最后这里： 12deploy: type: 改成：1234deploy: type: git repository: git@github.com:MonkeyLLuffy/MonkeyLLuffy.github.io.githuangjunhui.github.io.git #你的项目仓库的地址 branch: master 如果没配置SSHkey,以上会出问题的哟。接下来把它发送到你的github仓库里去:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 hexo g hexo d```接下来我们就可以通过：http://username.github.io访问你的博客了。最开始可能有延迟，但十分钟都没有，甚至404，那么没有错，你的过程错啦……错了不要惊慌，再来一次又不费劲。## 关于网站文件配置_config.yml的更多 ##``` bash # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site 这下面的几项配置都很简单，你看我的博客就知道分别是什么意思 title: Chillax blog #博客名 subtitle: Goals determine what you are going to be #副标题 description: Goals determine what you are going to be #用于搜索，没有直观表现 author: huangjunhui #作者 language: zh-CN #语言 timezone: #时区，此处不填写，hexo会以你目前电脑的时区为默认值 # URL 暂不配置，使用默认值 ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: https://opiece.me #域名，没有就不填 root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory 暂不配置，使用默认值 source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing 文章布局等，使用默认值 new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true tab_replace: # Category &amp; Tag 暂不配置，使用默认值 default_category: uncategorized category_map: tag_map: # Date / Time format 时间格式，使用默认值 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 10 #每页显示的文章数，0表示不分页 pagination_dir: page # Extensions 插件配置，暂时不配置 ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ plugins: - hexo-generator-feed theme: light #使用的主题，即：\themes文件夹下的主题文件夹名 feed: #之后配置rss会用，使用如下配置即可 type: atom path: atom.xml limit: 20 # Deployment 用于部署到github，之前已经配置过 ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: git@github.com:MonkeyLLuffy/MonkeyLLuffy.github.io.githuangjunhui.github.io.git branch: master ```## 写一篇文章 ##接下来就是新建一篇文章啦：``` bash hexo n &quot;第一篇博客&quot;```就会在、source/_post里面新增一个“第一篇博客.md”文件，然后用markdown打开文件开始编辑你的文件。每个主题会有不同的头部，但是到时候换主题可以查主题的文档照着做。``` title: my new post #可以改成中文的，如“新文章” date: 2015-04-08 22:56:29 #发表日期，一般不改动--- title: Hello World categories: 测试博客 tags: - Testing - Another Tag #文章标签 --- #这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上 &lt;!--more--&gt;#在&lt;!--more--&gt;之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 写完之后，hexo的命令，生成静态文件，本地预览（可以不要）,发布到git123hexo ghexo shexo d 换主题整个教程刚刚就基本结束了，但是我们都追求特别，默认的主题肯定不能满足你们，所以基本讲下怎么换主题。以Next主题为例：首先：找到他的gitHub地址：https://github.com/iissnan/hexo-theme-next然后git bash将这个主题clone下来：1git clone https://github.com/iissnan/hexo-theme-next.git 等克隆完了将这个文件夹放到博客文件夹的Themes目录下克隆速度慢得要死，这个时候我们不要闲着，看看他的ReadMe文件：这个文件里，有个链接：NEXT使用文档，打开它具体步骤不再赘述，照着文档一步一步做，你将会看到一个不一样的你的博客。 本来这一大篇都是跟教我的那个差不多，问我为什么不详写这个步骤了？我手痛！！，自己查文档去问：这个主题这样换好了，下一次看到好看的主题想换怎么办，想换就换呗，不拦着你，千万要找到文档再换哟，不然，呵呵呵呵呵呵，结果难料 结束语真正的第一篇博客到此完工，打着复习的旗号在宿舍写博客也是棒棒哒。撒花完结！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大家好，我是刘群的博客]]></title>
      <url>%2F2015%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[希望大家喜欢我的博客，经常来哟android wofjsddn dhfvdhhs dsjvdgh hsjishsnsus esrgtf wodejianfe]]></content>
    </entry>

    
  
  
</search>
