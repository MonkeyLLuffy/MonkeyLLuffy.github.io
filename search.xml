<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[我不是我觉得最亲近的人的最亲近的人]]></title>
      <url>%2F2017%2F%E6%88%91%E4%B8%8D%E6%98%AF%E6%88%91%E8%A7%89%E5%BE%97%E6%9C%80%E4%BA%B2%E8%BF%91%E7%9A%84%E4%BA%BA%E7%9A%84%E6%9C%80%E4%BA%B2%E8%BF%91%E7%9A%84%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[以前在看小说的时候，最是喜欢看男主喜欢上了女主，而女主却是感觉一般般。 有时候朋友之间也是如此，你把她当最好的朋友，然而你其实只是和别人一样而已，她不会因为你的喜好有所忌讳，说得遮羞一点叫不体贴，说得真实一点其实就是泯然众人，甚至还比不上别人。 这种努力有用吗？ 我也不知道，只是努力太久了也没什么差别的时候，还是算了吧，并不需要太多亲近的朋友，反正整个大学就那么浑浑噩噩的过了，最后一两年交的朋友有什么要紧呢？ 反正从大一的时候就最亲近的朋友不也没把你当最亲近的么？时间是最残酷的东西，会教你看清所有，看清所谓的朋友这种关系，看清人与人为什么而连结在一起？ 昨晚跑步的时候我一直在想，我是否强求了别人？我为什么要负气暴走？ 大概我觉得我真的不需要太亲近的人，越亲近就越有占有欲。如果当做最普通的室友的话，其实就会好很多吧，对整个宿舍的人都好。 然后什么叫最普通的室友关系呢？ 做饭严格执勤 上下班碰巧就一起走，不碰巧也不必等 减少肢体接触 减少思想交流 但要怎么不着痕迹的疏远呢？ 有意识的一个人走一排，不和别人排着走，不会有肢体接触 晚上睡觉的时候靠边上睡 在聊关于内心的时候不要说话，拿着手机自己玩，不听不说]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JFinal学习之——Demo1]]></title>
      <url>%2F2017%2FJFinal%E5%AD%A6%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94Demo1%2F</url>
      <content type="text"><![CDATA[正文之前许久没有学习新知识了，之前是做安卓的，对java后端其实也没那么了解，只是算是会用，今天任务差不多做完了，在下班之后学习JFinal新框架。 百度百科以及官网首页的那些优点我就不说了。直接开启代码人的第一课，配置第一个Demo; 正文目录： 新建项目 配置web.xml 第一个Controller 配置Config类 运行 新建项目myeclipse中新建一个web Project项目，没有自动生成web.xml文件的点击两次next之后勾选生成web.xml; 将jfinal-3.0-bin-with-src.jar放入lib文件夹下。 第一个Controller新建的controller一定要继承Controller类，然后index方法里面的内容可以省略方法名就可以访问。 12345678910111213141516public class HelloController extends Controller&#123; public void index() &#123;// renderText("Hello JFinal world"); this.render("/index.jsp"); &#125; public void sayHello() &#123; String userName = this.getPara("userName"); String sayHello = "Hello " + userName + "，welcome to JFinal world."; System.out.println(sayHello); this.setAttr("sayHello", sayHello); this.render("/hello.jsp"); &#125;&#125; index.jsp:1 配置Config类me.add(“hello”,HelloController.class)这句的意思就是把HelloController映射为hello。 me.setViewType(ViewType.JSP);这个不设置的话会被当做普通文本来输出； 12345678910111213141516171819202122232425262728293031323334353637383940414243public class DemoConfig extends JFinalConfig&#123; @Override public void configConstant(Constants me) &#123; // TODO Auto-generated method stub me.setDevMode(true); me.setEncoding(&quot;utf-8&quot;); me.setViewType(ViewType.JSP); &#125; @Override public void configRoute(Routes me) &#123; // TODO Auto-generated method stub me.add(&quot;hello&quot;,HelloController.class); &#125; @Override public void configEngine(Engine me) &#123; // TODO Auto-generated method stub &#125; @Override public void configPlugin(Plugins me) &#123; // TODO Auto-generated method stub &#125; @Override public void configInterceptor(Interceptors me) &#123; // TODO Auto-generated method stub &#125; @Override public void configHandler(Handlers me) &#123; // TODO Auto-generated method stub me.add(new ContextPathHandler(&quot;basePath&quot;)); &#125;&#125; 配置web.xmlweb.xml中的要把之前的Config类配置进去： 12345678910111213&lt;filter&gt; &lt;filter-name&gt;jfinal&lt;/filter-name&gt; &lt;filter-class&gt;com.jfinal.core.JFinalFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;configClass&lt;/param-name&gt; &lt;param-value&gt;demo.DemoConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;jfinal&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 运行放入tomcat中运行即可。 总结学习的时候，有人说直接给我一个项目看着学得快点，然而并没有直接给我；还有人说不要花时间学，要用的时候再去学就行。 我不喜欢在我学东西的时候有这些言论，所以一直学东西就是悄悄的学。 不管怎么，学习都是自己的东西，等东西不够的时候去学，那我何不一切了然于胸，等用的时候得心应手呢？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何用一个辅助键值对map将一个Map转为另一个Map]]></title>
      <url>%2F2017%2F%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E4%B8%AA%E8%BE%85%E5%8A%A9%E9%94%AE%E5%80%BC%E5%AF%B9map%E5%B0%86%E4%B8%80%E4%B8%AAMap%E8%BD%AC%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AAMap%2F</url>
      <content type="text"><![CDATA[在拉单的时候遇到这么一种情况，我们拉取的一个Map里面，好多的建和值，但基本和我们的键值对应不上，这个时候必须一个一个转换，显得代码很长，很不利于阅读； 然后我们组长就跟我提是不是能写一个工具类来做一个统一的转换； 暂且我只考虑Map与Map有嵌套，不考虑List的嵌套： 整个代码的流程如下： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 package com.ewin.util;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;/** * @author liuqun * 把不同Map里面的值用辅助键值对Map转移到一个固定的map中 */public class LaDanUtil &#123; /** * 方法简述： * @param keyMap * @param data * @param resultMap * @param parentKey * 时间：2017-3-7 * 作者：刘群 */ public static void deal(Map keyMap,Map data,Map resultMap,String parentKey) &#123; Iterable&lt;String&gt; keyIterable = keyMap.keySet(); for(String key:keyIterable)&#123; //data.get(key);这个值是List类型 //data.get(key);这个值是Map类型,循环这个map的key:dataMap-key,然后获取KeyMap中的dataMap+key Object obj = data.get(key); if (obj instanceof Map) &#123; //map中的map Map datakeyMap = (Map) data.get(key); Map newKeyMap = new HashMap(); for(String filterKey:keyIterable)&#123; if (filterKey.startsWith(key+"-")) &#123; newKeyMap.put(filterKey, keyMap.get(filterKey)); &#125; &#125; Iterable&lt;String&gt; datakeyIterable = keyMap.keySet(); //map中的map的key for(String datakey:datakeyIterable) &#123; deal(newKeyMap,datakeyMap,resultMap,key+"-");// resultMap.put(key+"-"+datakey, datakeyMap.get(datakey)); &#125; &#125; else &#123; resultMap.put(keyMap.get(key), data.get(key)); &#125; &#125; &#125; public static void main(String[] args) &#123; Map keyMap = new HashMap(); Map data = new HashMap(); Map resultMap = new HashMap(); keyMap.put("ID", "BILL_NO"); keyMap.put("Name", "BILL_NAME"); keyMap.put("contact", null); keyMap.put("contact-RECEIVE_ID", "RECEIVE_ID"); keyMap.put("contact-RECEIVE_Name", "RECEIVE_Name"); keyMap.put("contact-addr",null); keyMap.put("contact-addr-province","RECEIVE_Prov"); keyMap.put("contact-addr-city","RECEIVE_City"); data.put("ID", "11111111"); data.put("Name", "张三"); Map map1 = new HashMap(); map1.put("RECEIVE_ID", "222222222"); map1.put("RECEIVE_Name", "李四"); Map map2 = new HashMap(); map2.put("province", "浙江"); map2.put("city", "杭州"); map1.put("addr", map2); data.put("contact", map1); String parentKey = ""; deal(keyMap,data,resultMap,parentKey); System.out.println(resultMap); &#125;&#125; 输出的结果为： 12 &#123;RECEIVE_Prov=浙江, BILL_NAME=张三, RECEIVE_City=杭州, RECEIVE_Name=李四, BILL_NO=11111111, RECEIVE_ID=222222222&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sql优先级]]></title>
      <url>%2F2017%2Fsql%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
      <content type="text"><![CDATA[年前的时候就被分配改了一个bug，导致出库交运出现“第一目的公司错误，请重新导入”，一步一步发现是sql语句没有写完善，然后组长跟我说是因为没有对类型进行筛选为公司。然后就辣么酸爽的升级了3次都没成功。 升级第一版本之后sql语句的方法是这样的： public static String isCompanyInfo(Map newMap) { StringBuffer sql = new StringBuffer(); sql.append("select O.OFFICE_NAME MATCHING_COMPANY, O.OFFICE_ID COMPANYID"); sql.append(" from P_ORGANIZATION O "); sql.append(" where O.ABBREVIATION = '" + newMap.get("COMPANYINFO") + "'"); sql.append(" OR O.OFFICE_NAME = '" + newMap.get("COMPANYINFO") + "' "); sql.append(" and O.B_ENABLE = 1 "); sql.append(" and O.TYPE_CODE = 0 "); logger.info(sql.toString()); return sql.toString(); } 这个应该的结果是【简写或者全名为某某公司enable为1，TYPE_CODE为0】，但结果查出来的结果是【只要简写为某某公司的】和【全称是某某公司并且enable为1，TYPE_CODE为0】的所有数据。 当然，很多优先级情况都是可以避免的，只要自己记得加括号，不管需不需要，加上就最优先级了。 这是因为AND的优先级比OR的优先级高一些，所以在OR的那个地方被截成了两个条件。通过这个问题来学习SQL操作符。 优先级不同的情况下，优先级高的并且在同一层的会先结合在一起，然后再去连接优先级低的。所以想要跨优先级操作比如先OR再AND,就要加个括号了。 (BINARY,COLLATE) &gt; (!) &gt; (-,~) &gt; (^) &gt; (*,/,DIV,%,MOD) &gt; (+,-) &gt; (&lt;&lt;,&gt;&gt;)&gt; (&amp;) &gt; (|) &gt; (=,&lt;=&gt;,&gt;=,&lt;=,&lt;,&lt;&gt;,!=,IS,LIKE,REGEXP,IN) &gt; (BETWEEN,CASE,WHEN,THEN,ELSE) &gt; (NOT) &gt; ( &amp;&amp;,AND ) &gt; ( ||,OR,XOR ) &gt; ( := ) 操作符优先级由低到高，排列在同一行的操作符具有相同的优先级。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开年勿忘]]></title>
      <url>%2F2017%2F%E5%BC%80%E5%B9%B4%E5%8B%BF%E5%BF%98%2F</url>
      <content type="text"><![CDATA[晟邦物流接口 easyPM上自己接任务 评级职业规划]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring配置解析]]></title>
      <url>%2F2017%2Fspring%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[spring框架用了起码两年了，但是之前一直研究的是安卓那方面，对后台技术就没有做很多了解。现在仅以这篇博客顺便记录学习的过程。目录：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[log4j配置解析]]></title>
      <url>%2F2017%2Flog4j%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[这两日有些无聊，然后又搭了一遍SSM框架，就是spring+spring mvc+mybatis框架，上次搭过一次，与上次不同，这次不是通过一个教程按部就班，而是一点一点的自己构建的。 可能是因为另外学了spring的缘故，然后稍微对整个框架也有了些了解。 这篇文章不是为了搭建框架，而是为了log4j的配置； 这篇文章的目录如下： log4j概述 我的配置例子 配置信息分析 结语 其他相关链接 log4j概述Log4j中有三个主要的组件，它们分别是 Logger、Appender和Layout。 Log4j 允许开发人员定义多个Logger，每个Logger拥有自己的名字，Logger之间通过名字来表明隶属关系。有一个Logger称为Root，它永远 存在，且不能通过名字检索或引用，可以通过Logger.getRootLogger()方法获得，其它Logger通过 Logger.getLogger(String name)方法。 Appender则是用来指明将所有的log信息存放到什么地方，Log4j中支持多种appender，如 console、files、GUI components、NT Event Loggers等，一个Logger可以拥有多个Appender，也就是你既可以将Log信息输出到屏幕，同时存储到一个文件中。 Layout的作用是控制Log信息的输出方式，也就是格式化输出的信息。Log4j中将要输出的Log信息定义了5种级别，依次为DEBUG、INFO、WARN、ERROR和FATAL，当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码，这点实在是方便啊。 我的配置例子1234567891011### set log levels ###log4j.rootLogger =INFO,stdout ### export Console ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.errlog4j.appender.stdout.layout=org.apache.log4j.SimpleLayout#config own packagelog4j.logger.test.springmvc.dao = DEBUG 配置信息分析log4j.rootLoggerlog4j.rootLogger = [ level ] , appenderName, appenderName, … level 是日志记录的优先级,Log4j建议只使用四个级别，优 先级从高到低分别是ERROR、WARN、INFO、DEBUG。 appenderName就是指B日志信息输出到哪个地方。您可以同时指定多个输出目的地。 log4j.appender语法为：12345log4j.appender.appenderName = appender log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.option = valueN 配置日志信息输出目的地Appender,Log4j提供的appender有以下几种： org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 1234[main] INFO com.toogen.log4j.HelloLog4JToogen - This is a info message. [main] WARN com.toogen.log4j.HelloLog4JToogen - This is a warn message. [main] ERROR com.toogen.log4j.HelloLog4JToogen - This is a error message..... 使用log4j.appender.stdout.Target作为输出,可选择普通输出或者作为错误信息输出 log4j.appender.stdout.Target=System.out,意味着控制台输出标准信息 log4j.appender.stdout.Target=System.err输出错误信息 log4j.appender.appenderName.layout org.apache.log4j.HTMLLayout（以HTML表格形式布局） org.apache.log4j.PatternLayout（可以灵活地指定布局模式） org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） PatternLayout采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： %m 输出代码中指定的消息设置方式：12log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - &lt;%m&gt;%n %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n” %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) log4j.logger设置package输出级别,可以设置不同package的日志输出级别，语法为：123log4j.logger.packageName=levellog4j.logger.test.springmvc.dao = DEBUG 其中，packageName为实际的包名，level为日志级别与根rootLogger的类似，只是这个只是设置这个包里面的日志显示的级别。就像案例中test.springmvc.dao包里的DEBUG级别以上都能打印 结语毕竟不是一个API文件，更多的属性运用到的时候百度起来也很容易，到时候补充。平时要多总结，多记录，不然有时候稍稍忘掉就全都忘掉了。 其他相关链接log4j2 使用详解 log4j的使用详细解析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[王伟--81192]]></title>
      <url>%2F2017%2F%E7%8E%8B%E4%BC%9F-81192%2F</url>
      <content type="text"><![CDATA[偶然听音乐，在评论区看见这样一段对话： 81192，这里是辽宁舰，前方空域已清空，我舰将派552.553号双机编队接替你执行海岸巡航任务，15年了，该回家了，81192收到请回答，完毕！ 呼叫81192，这里是海航552.553双机编队，我编队奉命接替你执行海岸巡航任务，请返航，81192收到请回答，完毕！ 81192收到，我已无法返航，你们继续前进！重复，你们继续前进！ 81192并不是王伟的座机，但这已经成为一种保卫国家的精神象征。 我不知道我为什么要流眼泪，机子并没有美机的重，明知不可为而为之是为不智，家中尚有妻儿的他，说下‘我已无法返航’这句话内心在想什么，生命的最后都奉献给了国家。这种家国情怀，可能现在只在军队这样的地方才显得十分明显，我们这样普普通通的学生或者白领或者工人，几乎连国际形势也没关注过，我并不是说这类人不爱国，我们看抗日神剧的时候会不自觉的讨厌日本人，我们看见台独会排斥，我们会在国家有喜事时献上祝福，而我们的国家没让我们这样的工人学生感觉到祖国的危险，我们被保护得太好了，偶尔我也会想，有没有一个时候我能给祖国长点脸，或者有没有一个时候，我能给祖国做点什么。 81192，你在哪里？请立即返航！大家在等你]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记2017年第一周]]></title>
      <url>%2F2017%2F%E8%AE%B02017%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%91%A8%2F</url>
      <content type="text"><![CDATA[2017年的第一周，丢了我的手机，而且组长没有给我安排什么事情，然后我几乎就是自己学习或者说自己玩。 老实来说，这一周没做什么事情，也没学习什么，就是对着新手机玩一玩，看一看小说。我不喜欢这样过，我觉得很无聊。其实我喜欢饱满的工作安排，像前一段时间那样，时不时加个班，虽然辛苦点，但是很充实。 组长现在是太忙了，没空管我们，但是我自己一个人学习其实也是可以有事情做的，这一周没有安排就好好学习spring吧。android也是好久没碰了，慢慢的熟悉顺便把宿舍那个APP写了吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex_java学习]]></title>
      <url>%2F2016%2Fflex-java%2F</url>
      <content type="text"><![CDATA[进入bug项目组，组长说要我们做个小测试，用flex做一个列表显示省市的。后台代码本身并没有什么难度，但是因为是使用flex来做前端，这是完全没接触过的语言，心里有点发憷，但还是硬着头皮研究学习做了一个demo. 学flex对于学过java的人来说没什么难度，对于学过android的人来说更没什么难度；唯一不是很了解的是他的API，然而我们组长很贴心的教我使用myeclipse中的基础使用工具，然后感觉根本不需要API了，哈哈哈，组长万岁！ 首先是我的demo,一个简单的省市的代码,当然，从代码里就可以看出，很多功能并没有实现，只是做了简单的列表展示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;mx:Module xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%" xmlns:ns1="views.common.*" creationComplete="init()"&gt; &lt;mx:Style source="city.css"/&gt; &lt;mx:Script&gt; &lt;![CDATA[ import mx.controls.Alert; import mx.rpc.events.ResultEvent; import mx.rpc.events.FaultEvent; import mx.events.CloseEvent; import mx.collections.ArrayCollection; import com.common.ActionAlert; import com.common.PubFunction; import mx.rpc.http.HTTPService; import com.adobe.serialization.json.JSON; import mx.modules.ModuleLoader; private var objUserInfo:Object=&#123;&#125;; private var loginObj:Object=&#123;&#125;; //可绑定变量 [Bindable] private var serverResponse:String=""; //可绑定变量 [Bindable] public var provinceDataArray:ArrayCollection=new ArrayCollection(); //初始化UI权限 private function init():void &#123; //获取登录用户信息 objUserInfo=this.parentApplication.userLogInInfo; sear(); &#125; private function sear():void &#123; loginObj.USER_NAME=objUserInfo.USER.USER_CODE; loginObj.PASSWORD=objUserInfo.USER.USER_PWD; var srv:HTTPService=new HTTPService(); var params:Object=&#123;&#125;; var obj:Object=new Object(); obj["PROVINCE_NAME"]="重庆"; srv.method="POST"; srv.resultFormat="text"; srv.url="http://localhost:8080/A1_BILL/City/getPrivinceList.do"; params.USER_NAME=loginObj.USER_NAME; params.PASSWORD=loginObj.PASSWORD; params["JSONDATA"]=JSON.encode(obj); srv.send(params); //事件绑定 srv.addEventListener(ResultEvent.RESULT, successHandler); srv.addEventListener(FaultEvent.FAULT, errorHandler); &#125; private function successHandler(evt:ResultEvent):void &#123; var srv:HTTPService=evt.target as HTTPService; var resultObj=JSON.decode(srv.lastResult.toString()); var returnValue=resultObj.returnValue; //刷新角色列表 结果成功或失败情况 if (resultObj.returnType == "ERROR") &#123; ActionAlert.errorInfo("刷新列表失败"); return; &#125; provinceDataArray=new ArrayCollection(returnValue); &#125; private function errorHandler(event:FaultEvent):void &#123; serverResponse=event.message.toString(); ActionAlert.errorInfo("加载列表失败"); trace(event.message); &#125; ]]&gt; &lt;/mx:Script&gt; &lt;mx:VBox left="2" right="2" top="30" bottom="2" width="100%" height="100%"&gt; &lt;mx:HBox width="100%" height="5%"&gt; &lt;mx:ApplicationControlBar styleName="ModAppCtrlBar" dock="true" width="100%" height="100%" color="#000000"&gt; &lt;mx:HBox width="100%" horizontalAlign="right"&gt; &lt;ns1:title_menu id="title_menu" listFlag="true" listLength = "&#123;this.provinceDataArray.length&#125;" barColor="#FA3E3E"/&gt; &lt;/mx:HBox&gt; &lt;/mx:ApplicationControlBar&gt; &lt;/mx:HBox&gt; &lt;mx:HBox width="100%" height="5%"&gt; &lt;mx:VBox height="100%" width="15%" verticalAlign="middle"&gt; &lt;mx:FormItem label="城市" width="100%" fontWeight="normal" horizontalCenter="center"&gt; &lt;mx:TextInput width="100%" id="edtUserCode"/&gt; &lt;/mx:FormItem&gt; &lt;/mx:VBox&gt; &lt;mx:VBox height="100%" width="15%" verticalAlign="middle"&gt; &lt;mx:FormItem label="省" width="100%" fontWeight="normal"&gt; &lt;mx:TextInput width="100%" id="edtUserName"/&gt; &lt;/mx:FormItem&gt; &lt;/mx:VBox&gt; &lt;mx:HBox height="100%" width="15%" verticalAlign="middle"&gt; &lt;mx:Button label="检索" id="btnSearch" click="sear()"/&gt; &lt;mx:Button label="重置" id="btnReset" click="returnReset()"/&gt; &lt;ns1:site_str_search id="siteid"/&gt; &lt;/mx:HBox&gt; &lt;/mx:HBox&gt; &lt;mx:VBox height="100%" width="100%"&gt; &lt;mx:DataGrid id="gdProvince" dataProvider="&#123;provinceDataArray&#125;" width="100%" height="100%"&gt; &lt;mx:columns&gt; &lt;mx:DataGridColumn headerText="编号" dataField="PROVINCE_ID"/&gt; &lt;mx:DataGridColumn headerText="名字" dataField="PROVINCE_NAME"/&gt; &lt;mx:DataGridColumn headerText="拼音" dataField="PROVINCE_PINYIN" editable="false"/&gt; &lt;mx:DataGridColumn headerText="简称" dataField="PROVINCE_SHORT" editable="false"/&gt; &lt;/mx:columns&gt; &lt;/mx:DataGrid&gt; &lt;/mx:VBox&gt; &lt;/mx:VBox&gt;&lt;/mx:Module&gt; 在网络链接的模块 123456789101112131415var srv:HTTPService=new HTTPService();var params:Object=&#123;&#125;;var obj:Object=new Object();obj["PROVINCE_NAME"]="重庆";srv.method="POST";srv.resultFormat="text";srv.url="http://localhost:8080/A1_BILL/City/getPrivinceList.do";params.USER_NAME=loginObj.USER_NAME;params.PASSWORD=loginObj.PASSWORD;params["JSONDATA"]=JSON.encode(obj);srv.send(params);//事件绑定srv.addEventListener(ResultEvent.RESULT, successHandler);srv.addEventListener(FaultEvent.FAULT, errorHandler); 这里面的网络模块与android的网络链接几乎一模一样，实例化，配置地址，配置参数，然后回调，成功或是失败的函数，然后对成功之后或者失败之后进行对应的处理； actionScript对于mxml就像js对于html，然而actionScript是一种介于java和js的语言，java通过import,js通过引入js文件；里面的很多控件像是包装了的easyUi一样，自动装载json数据，在dataGrid中，自动解析json数据，都不需要像之前html一样一点一点拼接。 而其他的代码因为和android太像，根本没什么好说的，更多的就是对控件的熟悉了。 开发的界面如图，与VS开发C#类似的：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于实习项目（合同管理系统）感想]]></title>
      <url>%2F2016%2F%E5%85%B3%E4%BA%8E%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%90%88%E5%90%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89%E6%84%9F%E6%83%B3%2F</url>
      <content type="text"><![CDATA[来上海已经是一个月有余了，在这一个月中有不开心的时候，有想离开的时候，但终究还是坚持下来，成就感还是棒棒的。这一个月对我来说最值得一提的应该是前后整个周期大概20天的这个合同管理系统了。 对于我来说，这个系统就像是我的亲女儿一样，从项目的选定，项目的需求，产品的设计，最终的实现我都有参与。以前在实验室不是没有参与过项目，但是参与度这么高的，让我这么有使命感的还是第一个。 这个项目是作为测试项目还是实际项目，到现在也不是很清楚，但是我们都尽了我们的全力做了我们能做的事情。 前期带着产品运营们走上正轨的那些时间没什么好说的，从开始准备做开发工作的时候，我没有正确的估量到每个人的实力，导致路遥的工作量不饱满，而李开拓的工作因为有难度，导致她根本不会。【tip:正确估量每个人的实力】 准备工作完成得差不多了，中间去浙江出差了一趟，然后回来继续做项目，这时已经要开始设计数据库开始开发了。这一段时间就一直都比较的被动，我已经没办法放心把任务交给李开拓了，大家一起设计了数据库，然后我进行任务的分配，我这时候大概对路遥也了解了，但是要怎么才能让开拓觉得我不是不相信他呢，这就是作为组长的难点了。 才分配任务没多久，李开拓受伤了，然后任务交到了路遥和我的头上。 由于我给自己弄了挺多任务，还有就是李思浩和李洁都还不成熟。导致我事情也比较多，中间经过了两个通宵，终于在展示的时候没有出现大问题。 但是因为李思浩没有准备好，我们组的评分很低。我有自信我们的系统，但是很多时候并不只依靠产品本身就能获得认可。我们的产品没有获得认可是没准备好。 现在是12-30号，已经是过了评比快一个月的时间，我们的系统也试用了好久，也会正式上线。这是比较好的一点。其后又发现了很多的bug也逐步的完善，但还是不健壮。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记一个周六2016年12月3日]]></title>
      <url>%2F2016%2F%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%91%A8%E5%85%AD2016%E5%B9%B412%E6%9C%883%E6%97%A5%2F</url>
      <content type="text"><![CDATA[尽早做了一个梦，很甜蜜很少女的梦，在这个梦里，有个我认不得的少年，他温文尔雅，似乎有着宠溺的眼神，有着包容的心态，有着纵容的行为，我似乎能感觉到他看我的眼神是充满着爱的，似乎我做什么都可以的那种眼神。 早上醒来之后，又想快进入那个梦，但是又害怕梦的风格急转直下，不敢继续睡。 本来是个挺开心的梦，但写着写着又忍不住说到我自己的现状，我不能相信似乎世界上有爱这种东西，因为我本人是如此的冷漠，在内心中一次又一次的计算。 说起来，现在是几乎快要吃饭的中午，我感觉很恶心，也可以说是伤心，因为这种伤心让我感觉很恶心。 原因大概在于一盘饺子吧，我不喜欢别人用我吃饭的饭碗，秋贪图便宜买了几毛钱一个的塑料碗，但是拿我吃饭的碗来做调料碗，我感觉十分不开心。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[遇到的问题]]></title>
      <url>%2F2016%2F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[2016-11-06 GridView的Adapter怎么设置？（GridAdapter继承BaseAdapter,最普通的adapter,还可以试试SimpleAdapter） GridView怎么获取坐标？（得到每个item的宽和高，然后getX和getY，最后通过除法得到X,Y的坐标） 连连看怎么保证绝对有解的？(1.最简单就是一次创建两个,图标,这样可以同时检查他们是否可消去,保证游戏有解.2.) 连连看的难度设置（关卡） 刷新页面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大冰作品]]></title>
      <url>%2F2016%2F%E5%A4%A7%E5%86%B0%E4%BD%9C%E5%93%81%2F</url>
      <content type="text"><![CDATA[从一个人的文字中，其实最能够了解一个人，要是几十万几百万的字都撒谎的话也太难了。 他不是正统的文学人士，他的江湖气息很浓重，身份也是很多重的。 从几本书的文字中可以看到，他对主持这个身份颇不以为然，但让一众读者不理解的是为什么他还要维持这个身份？我猜想了几种可能，也行他希望不要过着一种生活（他说过最多在丽江也只呆15天），若是少了一重身份，也就意味着他的生活相对来说更单调了；也许是他虽然对那个圈子不以为然，但是他对主持这个职业还是喜欢的。 现在很多人骑行拉萨，或者青藏地旅行，我今年坐了几趟青藏线的火车，听到的都是骑行路上的事情，提西藏的反而很少，从他们的只言片语中，几乎都是说各种坑爹的事情。从大冰的大片的文字中，我能感觉到他对拉萨的深深的怀念。 现在有句话叫“因为一个人，爱上一座城”，但我想很多事情不是那么简单的，在一个地方呆得久了，似乎这个地方也成为了一个朋友，一个永远不会离开的朋友。我想，很多老年人的家乡情结应该也是这样吧。 在他笔下更加浓墨重彩描写的是丽江，丽江这个地方哦，被称为艳遇之都，大冰一遍又一遍的说，丽江并不是只有艳遇，而酒吧街的酒吧并不是真正的丽江特色酒吧，在他的故事里，路平、大军、大树都开了酒吧，在我们心中，泡酒吧的孩子都不是好孩子，但是在大冰的小屋里只有啤酒，只有民谣，只有吉他和手鼓，其他的什么艳遇都与它无关。 我还是一个实用主义者，每次看到书中的浪漫主义者一遍一遍犯傻的时候，我都想如果是我怎么怎么，但终究只是如果。我终究还是是个实用主义者，甚至连看书的目的我都不知道是否单纯。 这个世上还是需要很多傻子的，看着看着我甚至是羡慕这些傻子的，连大冰都是羡慕的吧，因为傻，才能纯粹的热爱，因为傻，在被爱或者爱的时候都能百分百的付出，大军卖唱超过150就给妻子买一条裙子，直到衣柜装不下也继续买，她的妻子甚至是在炫耀幸福的让大冰去交大军不要买了，或者买点其他也行，她为他放弃学业，一心跟着他，傻不傻？我认为傻透了，明明可以完成学业之后再爱，但是她是那么义无反顾，最终得到的爱人人羡慕。 这些傻子啊，都是得到了傻福的人。我最终也还是做不到傻傻的过的吧，就算是蠢笨如我，也还是实用主义者。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[first job]]></title>
      <url>%2F2016%2Ffirst-job%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[找工作之后]]></title>
      <url>%2F2016%2F%E6%89%BE%E5%B7%A5%E4%BD%9C%E4%B9%8B%E5%90%8E%2F</url>
      <content type="text"><![CDATA[离找工作开始已经两个月，其实这里面还是得到不少教训。但至少除了拒绝了thoughtworks的面试稍微有点遗憾，其他的真的没什么遗憾了。确实我复习的力度不过，虽说认真看书但也是走马观花，看得不够深入是一回事，看了之后没有融入自己的思考也是一个重要的原因。 不得不说的是，自己到现在为止只有一个offer，弄得自己失去了斗志，书不想看，代码没怎么写，整天就看着动漫，然后心里一片茫然，我记得刚开始的时候，我对自己说，不要管别人，跟着自己的节奏就行。但讲真，我确实是被别人的节奏影响着的。BAT一个不想放过，但一个都没有过，然后慢慢的笔试成绩变好之后，面试也一个不想放过，这种就是完全的广撒网捞鱼，所以到现在一条大鱼都没钓到。 到这会儿，我想问自己，我是想得到明年的大鱼，还是一条鱼都不想放过呢？明年的湖里还会不会有大鱼呢？ 现在是10月22号，我到底该如何做呢？ 恭喜我，我又茫然了，本来以为是已经得到答案才来写博客，但我发现自己终究还是不甘心，所以我要放弃和刘鑫她们一起去上海还是放弃找工作然后安心准备明年的春招呢？ 写在2016-12-30 现在我在上海，在上海递拎宝实习中。有时候找工作跟真正工作真是完全不同的体验，当时信誓旦旦的一定要做安卓（在中国航信面试中问我是否一定做安卓，不惜再面试一次都说的要），但在这里实习时，不是安卓也做了。 其实只要能学到东西，做什么都无所谓，毕竟我不可能过这种生活，做这种工作一辈子，毕竟不是做学生了，以后具体会是什么样，谁都不知道了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读《黑白》有感]]></title>
      <url>%2F2016%2F%E8%AF%BB%E3%80%8A%E9%BB%91%E7%99%BD%E3%80%8B%E6%9C%89%E6%84%9F%2F</url>
      <content type="text"><![CDATA[《黑白》这本书从情节上来看，是讲述陶羊子的从一个小孩，然后爱上围棋并逐步成为棋王的故事。他自小失去双亲，对白有着一种执着，当他把白棋下得极好，收到总督府上照拂的时候被他的老乡齐天勤一举打败并且把他送入他的人生第一个底端，然后他的舅舅也出事了……随后还有几次的大起大落，当他的人生最终归于平静的时候，他还是爱着棋，尽管中间有恨过棋，但最终还是爱的。 当然，一般人不会有这般境遇的。 我大概也喜欢上下围棋了吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[再见，成都]]></title>
      <url>%2F2016%2F%E5%86%8D%E8%A7%81%EF%BC%8C%E6%88%90%E9%83%BD%2F</url>
      <content type="text"><![CDATA[找工作已经接近一个月，从9月5号开始做京东的第一个笔试开始。这最开始的20天（24号以前），基本没有接到任何的面试电话，我知道是我太弱了，原因什么的我已经不想分析了，因为了然于心。 最开始到成都，住在刘鑫的朋友（小兰）家里，在青羊区512成飞小区，这里是成飞集团的地盘，最开始那几天几乎没出过他们的势力范围。其实这个地方还比较好，离得不远的地方有地铁。在这里住的几天，我们买了盆子，买了垃圾桶，买了电饭煲。小兰家里有网络，有电磁炉……很方便，很想好好谢谢她。 这一段日子，回想起来一片模糊，除了复习，除了做笔试，除了做饭吃饭，除了看了一部进击的巨人，我几乎已经想不起来我爱做了什么事情。 在成都，才知道重庆好得让我想念。这里的三轮让我很不习惯，他们不惧任何交通规则，除了穿绿色衣服的交通管制能让他们收敛下；这些三轮有时候会让你觉得很方便，但那天那个阿姨大晚上不认识路带着我乱走，而且还没送我到最终的目的地；但那天早上有个三轮也很让我感谢，那天是去西南财大笔试的一天，自前一天晚上被一个阿姨开的三轮在路上丢下了之后我心里十分的不情愿，但是为了不迟到还是坐的三轮去，这个大叔路上偶尔和我聊聊天，答应送我到财经大学东门5块钱，没出门在异乡的人不会知道一两块钱对你有什么意义。即使就是免了我两块钱，我还是十分感谢。以致于我笔试发挥好得出奇。 面试的详情，我后面再总结。我记得那是18号，微店的宣讲会加笔试，在四川大学江安校区，这个地方离我们住的地方很远，我们三点钟出门，先去项俊超家里拿东西然后再去，打滴滴，走路，坐公交车，打印简历，一路觉得很远很远，终于到达之后（向俊超的伞一下子就被吹坏了……路边卖的真让人的有点不放心呐），有个美女带我们走到了楼下（PS：他们学校真的太大了），晚上回来的时候，饿极了，找个门出去，结果发现校门都关了，下着大雨我们居然是从一个小栏里爬出去的，等到了打的滴滴车上，我觉得我半边都打湿了，但是还是十分的兴奋，因为第一次参加现场笔试。回家做饭吃了已经10点过了。 第二天又接着要去成都电子科大参加经纬中国的联合招聘，是挺多的创业公司，笔试过了就能直接选三家进行面试。路途很遥远，那天放弃了乐视和完美世界的笔试，坐了将近2个小时的车到达了目的地，然后又花了好长时间去找地方（PS：电子科大真的好大啊）；回去的时候比较急，因为想要参加完美世界的笔试，我真贪心呐，我这么说自己。可是啊，不把笔试做了那就没机会参加面试的，可是回来还是晚了，在下了公交等滴滴的时候，我们买了几个馒头那吃，我太多年没觉得吃馒头都是那么幸福的事情了。那时候觉得自己既凄凉又搞；；；；；；；；；笑；；；；；；；；。然后又去买了泡面和速冻饺子晚饭吃得很开心。 这住别人家的时候不觉得什么，后面自己住旅馆的时候才知道生活还可以更糟，然后发现一个人住旅馆才是最遭的。 24号我们回重庆了，因为猪八戒的面试，可是待了一天我又回成都来了，因为小米和越秀集团的面试。 一个人住旅馆真的糟糕透了，因为一个人住，所以要买最最便宜的，最便宜的倒也不是很差，只是觉得很没有安全感。 昨天面试失败，我身体上的疲惫一下子爆发出来，坐过了站都没发现，即使是现在的我，也是极为疲惫，但是前路还很迷茫，我暂时还不能放弃，我只能继续加油。 借用灰太狼的一句话，成都，我还会再回来的，再见！ 写在2016-12-30 没过多久之后，我又去了一趟成都，那是YY的面试，那天上午面试了递拎宝之后坐高铁过去，然后还笔试thoughtworks(思特沃克中国),然后还视频面试了一次今日头条。我其实面试真的挺多了，但没有抓住机会。成都，我回来了又去，但终究什么都没抓住。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[短板]]></title>
      <url>%2F2016%2F%E7%9F%AD%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[硬件加速：什么叫硬件加速？它的原理是什么？ 同步锁和互斥锁。各自分别是什么？在java中怎么使用的？要怎么考虑相关的？ 单例模式的两种模式的优缺点？在考虑多线程时使用哪一个？（饿汉式和懒汉式） 按层遍历二叉树]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用笔试题]]></title>
      <url>%2F2016%2F%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
      <content type="text"><![CDATA[进程间通信：方式一：访问其他应用程序的ActivityActivity既可以在进程内（同一个应用程序）访问，也可以跨进程访问。Activity的跨进程访问与进程内访问略有不同。虽然它们都需要Intent对象，但跨进程访问并不需要指定Context对象和Activity的 Class对象，而需要指定的是要访问的Activity所对应的Action（一个字符串）。有些Activity还需要指定一个Uri（通过 Intent构造方法的第2个参数指定）。 方式二：Content Provider Android应用程序可以使用文件或SqlLite数据库来存储数据。Content Provider提供了一种在多个应用程序之间数据共享的方式（跨进程共享数据）。应用程序可以利用Content Provider完成下面的工作： 查询数据 修改数据 添加数据 删除数据 方式三：广播（Broadcast） 在应用程序中发送广播比较简单。只需要调用sendBroadcast方法即可。该方法需要一个Intent对象。通过Intent对象可以发送需要广播的数据。发送广播并不需要在AndroidManifest.xml文件中注册，但接收广播必须在AndroidManifest.xml文件中注册 receiver（或者动态注册）。 方式四：AIDL服务 服务（Service）是android系统中非常重要的组件。android系统中的Service主要有两个作用：后台运行和跨进程通讯。AIDL的全称是Android Interface Definition Language，也就是说，AIDL实际上是一种接口定义语言。通过这种语言定义接口后，Eclipse插件（ODT）会自动生成相应的Java代码接 口代码。下面来看一下编写一个AIDL服务的基本步骤。 在Eclipse工程的package目录中建立一个扩展名为aidl的文件。package目录就是Java类所在的目录。该文件的语法类似于Java代码。aidl文件中定义的是AIDL服务的接口。这个接口需要在调用AIDL服务的程序中访问。 如果aidl文件的内容是正确的，Eclipse插件会自动生成一个Java接口文件（*.java）。 建立一个服务类（Service的子类）。 实现由aidl文件生成的Java接口。 在AndroidManifest.xml文件中配置AIDL服务，尤其要注意的是，标签的android:name属性值就是客户端要引用该服务的ID，也就是Intent类构造方法的参数值。 Android Service与Activity之间通信的几种方式方式一：通过Binder对象Activity调用bindService (Intent service, ServiceConnection conn, int flags)方法，得到Service对象的一个引用，这样Activity可以直接调用到Service中的方法，如果要主动通知Activity，我们可以利用回调方法。 方式二：通过broadcast(广播)的形式Service向Activity发送消息，可以使用广播，当然Activity要注册相应的接收器。比如Service要向多个Activity发送同样的消息的话，用这种方法就更好。 Activity Service Fragment生命周期Activity Service Fragment Android中view和surfaceview的区别使用的SurfaceView的时候，一般情况下要对其进行创建，销毁，改变时的情况进行监视，这就要用到 SurfaceHolder.Callback. 对于Surface相关的，Android底层还提供了GPU加速功能，所以一般实时性很强的应用中主要使用SurfaceView而不是直接从View构建，同时后来做android 3d OpenGL中的GLSurfaceView也是从该类实现。 SurfaceView和View最本质的区别在于，surfaceView是在一个新起的单独线程中可以重新绘制画面而View必须在UI的主线程中更新画面。 那么在UI的主线程中更新画面 可能会引发问题，比如你更新画面的时间过长，那么你的主UI线程会被你正在画的函数阻塞。那么将无法响应按键，触屏等消息。 当使用surfaceView 由于是在新的线程中更新画面所以不会阻塞你的UI主线程。但这也带来了另外一个问题，就是事件同步。比如你触屏了一下，你需要surfaceView中thread处理，一般就需要有一个event queue的设计来保存touch event，这会稍稍复杂一点，因为涉及到线程同步。 所以基于以上，根据游戏特点，一般分成两类。 1 被动更新画面的。比如棋类，这种用view就好了。因为画面的更新是依赖于 onTouch 来更新，可以直接使用 invalidate。 因为这种情况下，这一次Touch和下一次的Touch需要的时间比较长些，不会产生影响。 2 主动更新。比如一个人在一直跑动。这就需要一个单独的thread不停的重绘人的状态，避免阻塞main UI thread。所以显然view不合适，需要surfaceView来控制。 3.Android中的SurfaceView类就是双缓冲机制。因此，开发游戏时尽量使用SurfaceView而不要使用View，这样的话效率较高，而且SurfaceView的功能也更加完善。 拓扑排序什么是拓扑排序 回溯基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。步骤用回溯算法解决问题的一般步骤为：一、定义一个解空间，它包含问题的解。二、利用适于搜索的方法组织解空间。三、利用深度优先法搜索解空间。四、利用限界函数避免移动到不可能产生解的子空间。问题的解空间通常是在搜索问题的解的过程中动态产生的，这是回溯算法的一个重要特性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class WolfQueen &#123; /** * 一共有多少个皇后（此时设置为8皇后在8X8棋盘，可以修改此值来设置N皇后问题） */ int max = 8; /** * 该数组保存结果，第一个皇后摆在array[0]列，第二个摆在array[1]列 */ int[] array = new int[max]; public static void main(String[] args) &#123; new WolfQueen().check(0); &#125; /** * n代表当前是第几个皇后 * @param n * 皇后n在array[n]列 */ private void check(int n) &#123; //终止条件是最后一行已经摆完，由于每摆一步都会校验是否有冲突，所以只要最后一行摆完，说明已经得到了一个正确解 if (n == max) &#123; print(); return; &#125; //从第一列开始放值，然后判断是否和本行本列本斜线有冲突，如果OK，就进入下一行的逻辑 for (int i = 0; i &lt; max; i++) &#123; array[n] = i; if (judge(n)) &#123; check(n + 1); &#125; &#125; &#125; private boolean judge(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123; return false; &#125; &#125; return true; &#125; private void print() &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + 1 + " "); &#125; System.out.println(); &#125;&#125; 最小生成树参见贪婪算法的Prime算法和Kruscal算法： Prime算法的思想是不断找出边缘中最短的； Kruscal算法的思想是排序所有边，然后将没有形成回路的最小边加入树中，知道加n-1条边。Prime 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static int unReach = 1000;public static int n = 4;public static void main(String[] args) &#123; int[][] G = &#123; &#123; 0, 4, 15, 10 &#125;, &#123; 4, 0, 10, unReach &#125;, &#123; 15, 10, 0, unReach &#125;, &#123; 10, unReach, unReach, 0 &#125; &#125;; boolean[] visit = new boolean[n]; int sum = 0; int[] dist = new int[n]; // 清空生成树，任取一个顶点加入生成树 initVisit(visit); int index = 0; visit[index] = true; for (int i = 0; i &lt; n; i++) &#123; dist[i] = G[index][i]; &#125; for (int i = 1; i &lt; visit.length; i++) &#123; int min = unReach;// 在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树 for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; (min &gt; dist[j])) &#123; min = dist[j]; index = j; &#125; &#125; visit[index] = true; sum += min; // 重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树 for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; dist[j] &gt; G[index][j]) &#123; dist[j] = G[index][j]; &#125; &#125; &#125; System.out.println(sum);&#125;private static void initVisit(boolean[] visit) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; visit.length; i++) &#123; visit[i] = false; &#125;&#125; kruscal: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/** * @author LiuQun * 中心是快速求并法。用一个有根树来表示每一个子集，树中的节点包含子集中的元素； * 根中的元素就被当做该子集的代表树；树中的边从子女指向他们的父母 * makeset():创建一颗单节点的树 * union(x,y):把Y树的根附加到X上（并把Y树删除） * find(x):从包含x的节点开始找到树的根 * */public class Kruskal &#123; public static int n = 5;// 顶点个数 public static int edgeNum = 7;// 总边数 public static int father[] = new int[128];// public static int rank[] = new int[128];//树的等级（层数），优化算法用的，层数小的加在层数大的下 public static void main(String[] args) &#123; // 边的数组 Edge[] edges = new Edge[edgeNum]; edges[0] = new Edge(0, 1, 5); edges[1] = new Edge(1, 2, 3); edges[2] = new Edge(1, 3, 3); edges[3] = new Edge(3, 4, 8); edges[4] = new Edge(1, 4, 7); edges[5] = new Edge(4, 2, 3); edges[6] = new Edge(0, 2, 4); Edge[] result = new Edge[edgeNum]; int count = 0; // 按照权重排序树的边 srotEdge(edges); printEdge(edges); make_set(); // 将图遍历一次，找出权值最小的边，（条件：此次找出的边不能和已加入最小生成树集合的边构成环）， // 若符合条件，则加入最小生成树的集合中。不符合条件则继续遍历图，寻找下一个最小权值的边。 int sum = 0; for (int i = 0; i &lt; n; i++) &#123; // tree中无回路，使用不相交子集和并查算法 if (find_set(edges[i].getFirst()) != find_set(edges[i].getSecond())) &#123; union(edges[i].first, edges[i].second); sum += edges[i].value; result[count++] = edges[i]; &#125; &#125; System.out.println(sum); printEdge(result); &#125; //把每个元素初始化为一个集合 private static void make_set() &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; n; i++) &#123; father[i] = i; rank[i] = 1; &#125; return; &#125; // 采用直接插入排序 private static void srotEdge(Edge[] edges) &#123; // TODO Auto-generated method stub for (int i = 1; i &lt; edges.length; i++) &#123; if (edges[i].value &lt; edges[i - 1].value) &#123; int j = i - 1; Edge temp = edges[i]; while (j &gt; -1 &amp;&amp; temp.value &lt; edges[j].value) &#123; edges[j + 1] = edges[j]; j--; &#125; edges[j + 1] = temp; &#125; &#125; &#125; /** * 从包含x的节点开始找到树的根 * * @param x * 顶点 * @return */ public static int find_set(int x) &#123; if (x != father[x]) &#123; father[x] = find_set(father[x]); &#125; return father[x]; &#125; /** * 合并x,y所在的两个集合：利用Find_Set找到其中两棵树的根， 并将一棵树的根指向另一棵树的根。 * * @param first * x * @param second * y */ private static void union(int first, int second) &#123; // TODO Auto-generated method stub first = find_set(first); second = find_set(second); if (first == second) &#123; return; &#125; if (rank[first] &lt; rank[second]) &#123; father[first] = find_set(second); &#125; else &#123; if (rank[first] == rank[second]) &#123; rank[first]++; &#125; father[second] = find_set(first); &#125; return; &#125; public static void printEdge(Edge[] edge) &#123; for (int i = 0; i &lt; edge.length; i++) &#123; if (edge[i] != null) System.out.println(edge[i].toString()); &#125; &#125; static class Edge implements Comparable// 两点之间的加权边 &#123; private int first, second;// 表示一条边的两个节点 private int value;// 权值 public Edge(int first, int second, int value) &#123; this.first = first; this.second = second; this.value = value; &#125; public int getFirst() &#123; return first; &#125; public int getSecond() &#123; return second; &#125; public int getValue() &#123; return value; &#125; @Override public int compareTo(Object arg0) &#123; return value &gt; ((Edge) arg0).value ? 0 : -1; &#125; @Override public String toString() &#123; return "Bian[first=" + first + ",second=" + second + ",value=" + value + "]"; &#125; &#125;&#125; Android涉及到的设计模式1、适配器模式：ListView或GridView的Adapter简介：不同的数据提供者使用一个适配器来向一个相同的客户提供服务。 2、建造者模式：AlertDialog.Builder简介：可以分步地构造每一部分。 3、命令模式：Handler.post后Handler.handleMessage简介：把请求封装成一个对象发送出去，方便定制、排队、取消。 4、享元模式：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。简介：运用共享技术有效地支持大量细粒度的对象。 5、迭代器模式：如通过Hashtable.elements方法可以得到一个Enumeration，然后通过这个Enumeration访问Hashtable中的数据，而不用关心Hashtable中的数据存放方式。简介：提供一个方法顺序访问数据集合中的所有数据而又不暴露对象的内部表示。 6、备忘录模式：Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心简介：不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。 7、观察者模式：我们可以通过BaseAdapter.registerDataSetObserver和BaseAdapter.unregisterDataSetObserver两方法来向BaseAdater注册、注销一个DataSetObserver。这个过程中，DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。事件通知也是观察者模式简介：一个对象发生改变时，所有信赖于它的对象自动做相应改变。 8、原型模式：比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了简介：在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。 9、代理模式：类似于ios开发的delegate委托模式，所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。简介：为其他对象提供一种代理以控制对这个对象的访问。 10、状态模式：View.onVisibilityChanged方法，就是提供了一个状态模式的实现，允许在View的visibility发生改变时，引发执行onVisibilityChanged方法中的动作。简介：状态发生改变时，行为改变。 11、策略模式：举例：Java.util.List就是定义了一个增（add）、删（remove）、改（set）、查（indexOf）策略，至于实现这个策略的ArrayList、LinkedList等类，只是在具体实现时采用了不同的算法。但因为它们策略一样，不考虑速度的情况下，使用时完全可以互相替换使用。简介：定义了一系列封装了算法、行为的对象，他们可以相互替换。 12、调解者模式简介：一个对象的某个操作需要调用N个对象的M个方法来完成时，把这些调用过程封装起来，就成了一个调解者举例：如Resource.getDrawable方法的实现逻辑是这样的：创建一个缓存来存放所有已经加载过的，如果getDrawable中传入的id所对应的Drawable以前没有被加载过，那么它就会根据id所对应的资源类型，分别调用XML解析器生成，或者通过读取包中的图片资源文件来创建Drawable。而Resource.getDrawable把涉及到多个对象、多个逻辑的操作封装成一个方法，就实现了一个调解者的角色。 13、抽象工厂模式DAO与Service的使用 硬件加速在Android艺术探索中看到一句话：绝大多数情况下，硬件加速都可以解决莫名其妙的卡顿问题。通过设置android:hardwareAccelerated = “true”即可为Activity开启硬件加速。那么问题来了：什么叫硬件加速？它的原理是什么？ Android从3.0（API Level 11）开始，在绘制View的时候支持硬件加速，充分利用GPU的特性，使得绘制更加平滑，但是会多消耗一些内存。 理解View的绘制模型：invalidate（）重绘 没有硬件加速：步骤如下： Invalidate the hierarchy（注：hierarchy怎么翻译？） Draw the hierarchy 应用程序调用invalidate()更新UI的某一部分，失效(invalidation)消息将会在整个视图层中传递，计算每个需要重绘的区域（即脏区域）。然后Android系统将会重绘所有和脏区域有交集的view。很明显，这种绘图模式存在缺点： 每个绘制操作中会执行不必要的代码。比如如果应用程序调用invalidate()重绘button，而button又位于另一个view之上，即使该view没有变化，也会进行重绘。 可能会掩盖一些应用程序的bug。因为android系统会重绘与脏区域有交集的view，所以view的内容可能会在没有调用invalidate()的情况下重绘。这可能会导致一个view依赖于其它view的失效才得到正确的行为。 有硬件加速： Android系统仍然使用invalidate()和draw()来绘制view，但在处理绘制上有所不同。Android系统记录绘制命令到显示列表，而不是立即执行绘制命令。另一个优化就是Android系统只需记录和更新标记为脏（通过invalidate()）的view。新的绘制模型包含三个步骤： Invalidate the hierarchy 记录和更新显示列表 绘制显示列表 线程和进程的区别联系 进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。 线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 两者都可以提高程序的并发度，提高程序运行效率和响应时间。线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。 根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的： 1、速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。 2、资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。 3、同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阳春白雪与下里巴人]]></title>
      <url>%2F2016%2F%E9%98%B3%E6%98%A5%E7%99%BD%E9%9B%AA%E4%B8%8E%E4%B8%8B%E9%87%8C%E5%B7%B4%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[下午两点的天，白花花的，跟重庆的天应该是一样的吧，但重庆的空气应该没这边这么阴冷。没办法，不论是国家还是个人都得以经济建设为中心。 认识新朋友是很高兴的事情，看了很多与人交往的书，对于我来说大概也就是让我的心变得开朗点儿，让我不那么害怕认识新朋友了。就算是与朋友发生了什么龃龉，我也有信心可以自己调节好（朋友之间的矛盾，大概我也只有干瞪眼旁边看着了）。 到成都认识了一个新朋友，这位朋友很热情很和蔼，以东道主的身份请吃了饭，又邀请到她住的地方吃饭（完全是沾别人光了）。讲真，我不喜欢到别人家厨房去，我也没什么理由。吃了饭，另外两朋友去帮主人洗碗了，但我只是坐着玩手机，那会儿觉得好尴尬啊。 貌似写着写着又快变成日记了……不好不好，言归正传，刚认识一个人，还未成为朋友时，因为不了解，可能觉得这个人是下里巴人的人或是阳春白雪的人。其实都是误解，我天生面瘫脸，表情不丰富，难免觉得难以接近，但我个人觉得就算不是如沐春风那也是热情澎湃啊。 这大概就是距离产生的误解了。 有那么一句话，大家都知道相互是什么样的人。这句话在我看来是十分没有逻辑性而且十分任性的一句话。我或许知道你是什么样的人，你知不知道我什么样的人还另说；而且，就算我知道你是什么样的人，但我没有义务包容你所说的什么样的人。因为你不会说话，我就一直得忍受你各种各样的语气的话，完了还说一句，我以为我们都知道相互是什么样的人，说得我生气就是我自己不够了解你一样。 这便是距离太近产生的误解了。 距离近了，才知道我们既可以下里巴人，也可以阳春白雪。 我一直觉得，不论是男女朋友之间，还是普通朋友之间都是为了更开心，所以才在一起相处，偶尔的龃龉可以调节，我可以问自己，到底是这件微不足道的小事重要，还是你这么朋友重要，但是太多的不开心，我觉得也没什么相处的必要了，因为最初的目的都违背了。 所以不论是最开始看着的阳春白雪下里巴人，到最后，都会剥开还原最真实的你。没有人是完美的，包括你最看重的你自己，朋友包容了我的最难相处的点然后还是喜欢着我，那我怎么能去吹毛求疵？ 看着窗外的柏树（我猜的），听着音乐，做着喜欢做的事情。身边的朋友也是我喜欢的，这样的生活就是完美的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据库]]></title>
      <url>%2F2016%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
      <content type="text"><![CDATA[数据库概述 关系数据库 SQL 数据库概述数据的主要功能：1.数据定义功能；2：数据组织、存储和管理；3：数据操纵功能；4：数据库的事务管理和运行管理；5：数据库的建立和维护功能；6：其他功能。 关系数据库一行即是一个元祖，一列即是一个属性，域为属性的取值范围，分量对应元祖中的一个属性值（一个单元格）； 基本表：实际存在的表，实际存储数据的逻辑表示；查询表：查询结果对应的表；视图：由基本表或者其他视图导出的表，是虚表，不应对应实际存储的数据。 实体完整性：主码不为空，且唯一。参照完整性：外码必须是另一个表的主码，外码值必须在它对应的实体中有对应的主码值。外码可以为空值。用户定义扥完整性：约束条件 SQL]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《第一行代码》]]></title>
      <url>%2F2016%2F%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%2F</url>
      <content type="text"><![CDATA[学习是件愉快的事情。我一直是这么觉得的。因为在学习中所获得的充实感跟在玩乐或者吃完东西的那种满足感完全不同。 昨天状态奇差，我只是在各个网站上做了些笔试题这样，确实难得不知道说什么好，但是莫名有种好刺激的感觉，要是太简单，要在这么多人中被选中也是件难事。 所以今天决定看一本自己相比较更感兴趣的书《第一行代码》，最初乱七八糟的用到哪个控件就看哪个相关的博客，然后有段时间没做项目了就看了小猪（coder-pig）的博客，看了之后觉得自己已经不是初级人员，就没看什么初级的书就奔向了《Android艺术探索》,但是总感觉知识脱节了，有可能是当时看小猪的教程没那么认真，也有可能是因为忘掉了。总之，正好好久没接触Android相关的知识或者代码，重温一下也不错。 申明，在此博客中也仅仅是为了后面懒得翻书，所以仅仅只写了我感兴趣和我确实有些忘了的部分。 启动与关闭活动活动的启动模式：standard,singleTop,singleTask,singleInstance：标准，启动栈顶元素时不重新入栈，任务栈中仅仅存在一个实例，以前有的话，它成为栈顶元素，其他原本在他上面的都出栈，单独一个栈。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络基础]]></title>
      <url>%2F2016%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[物理层###任务### 物理层的任务 信道复用技术 宽带接入技术 物理层的任务数据在计算机中采用并行传输方式，在通信链路中的传输方式一般都是串行传输（处于经济的考虑）。 数据是运送消息的实体，信号是数据的电器或电磁的表现。 基带信号有的频率不能在许多信道中传输，所以需要对基带信号进行调制。这种调制分为两类： 第一类：（基带调制:把数字信号转换为另外一种数字信号）：仅仅对波形进行变换，变换后的信号仍然是基带信号。这种过程也称为编码（归零，不归零，曼切斯特，查分曼切斯特）。 第二类：（带通调制：调频，调相，调幅）：需要使用载波进行调制，即：把基带信号的频率范围搬移到较高的频段，并转为模拟信号。 曼切斯特编码：位中心向上或向下定义为0或1.差分曼切斯特码：位中心处都有跳变，位开始没有跳变代表1，有跳变代表0. 物理层下的传输媒体：数据传输系统中在发送器和接收器之间的物理通路。分为两大类：导引型和非导引型。 导引型传输媒体：电磁波沿着固体媒体（铜线或光纤）传播。 非导引型传输媒体：自由空间，在这里面电磁波的传输称为无线传输。 信道复用宽带接入技术]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构]]></title>
      <url>%2F2016%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[数据：信息的载体，能够被计算机识别、存储、加工，包括整数、实数、字符串、图像、声音等 数据元素：数据的基本单位，也称结点、元素、顶点、记录。一个数据元素可由若干个数据项组成 数据项：是具有独立寒意的最小标识单元，也称字段、域、属性等 数据结构：指数据之间的相互关系，即组织形式，有逻辑结构（一般程序中出现的形式）和物理结构之分（内存中的连续存储形式）；逻辑结构又有线性（非空，仅由一个开始结点和一个终端结点，除首尾结点之外，所有节点均只有一个直接前区和一个直接后继，如一维数组、栈、队列、链表、串等）和非线性之分（一个结点可以有多个直接前区和多个直接后继，如多维数组、广义表、树、图等） 如果两个没有环的链表相交于某个节点，那么在这个节点之后的所有节点都是两个链表所共有的。直接判断两链表的尾节点是否相同即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java编程思想]]></title>
      <url>%2F2016%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F</url>
      <content type="text"><![CDATA[这篇博客全篇都是java的知识点，边看《Java编程思想》边写的，一天两天之内可能无法完成，但是我也肯定会在最近这几天内看完，然后再开始看一些网络知识了。当然我不能照着书全部重新敲一遍，我只是整理我觉得混淆的和以前并不清楚的东西。不全面也是正常了。 目录结构如下： 对象 操作符 控制执行流程 初始化与清理 访问控制权限控制 复用类 多态 接口 内部类 持有对象 通过异常处理处理错误 字符串 类型信息 泛型 数组 容器的深入研究 Java I/O系统 枚举类型 注解 并发 组件 对象对象：将问题空间中的元素及其在解空间中的表示称为对象。也就是说：程序可以通过添加新类型的对象使自身适用于某个特定的问题。对象具有状态，行为和标识。 类：描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。 接口确定了对某一特定对象所能发出的请求。 继承在只重写基类方法与需要添加新方法都是可行，但要根据真实的情况来，区分还是很明显的。 Java完全采用动态分配内存方式，编译器可以确定对象存活的时间，并且可以自动销毁它。这样可以避免暗藏的内存泄漏问题。 在程序中，彼此独立运行的部分称之为线程。 String中每个字符都是16位或者2个字节。null在Java中表示这个引用还没指向某个对象。 当声明一个事物static时，就表示这个域或这个方法不会与包含它的那个类的任何对象实例关联在一起。未创建实例时，也可以直接调用其static的域或方法，而非static关键字的域和方法都必须通过实例化才能引用。多个实例化指向的其实也只是一个static域。 javadoc只能为public,protect成员进行注释。private和包内可访问的注释会被忽略掉。javadoc注释支持嵌入HTML 类名的首字母大写，几个单词组合时不要用下划线隔开，其中每个内部单词的首字母都要大写。 用eclipse导出javadoc为html文件，可以导出整个项目，步骤为：项目右键—&gt;export—&gt;java—&gt;javadoc—&gt;javadoc command为jdk的bin文件的javadoc.exe这个文件，然后选择保存的路径—&gt;finish 就成功了，自动概览整个项目，可以生成目录等。 操作符不能把任何东西赋值给一个常数。 obj1 = obj2;这种叫做别名现象，指向的是同一个引用，改变的值那些都将会相等。方法调用时也是产生了一个别名，改变了方法中的对象，其实改变的是调用方法传入的对象。 前缀递增或者递减都是先执行运算，再进行赋值。而后缀递减或者后缀递增都是先赋值再运算。 在for(int i = 0;i&lt;10;i++)这个语句中，最先初始化i=0，然后判断i&lt;10，执行完之后再进行i++,再判断i&lt;10是否成立来决定是否还要执行循环。 ==和!=适用于所有的基本数据类型，也适用于所有对象，它们比较的是对象的引用是否是同一个。 equals()方法默认的也是比较引用，只有自己覆盖重写之后才会是想要的比较。 短路现象：一旦能够准确无误的确定整个表达式的值，就不会计算表达式的剩余部分了。这种方法可以获得潜在性能的提升。 float类型的常量一定要加f,不然会被认定为double类型，然后就会报错。例如:float aa = 1.2f;(此处不加f时就会报错) 按位操作符用来操作整数基本数据类型中的单个bit,即二进制位。（&amp;，|,^:异或：某一个是1，但不全是1时会输出1,~），&amp;，|,^可与赋值符号连用。 移位操作符的运算对象也是二进制，&lt;&lt;左移，&gt;&gt;（有符号，符号为正高位补0符号为负高位补1），&gt;&gt;&gt;（java特有无符号，无论正负都在高位补0）右移，左移低位补0， 计算机显示二进制是显示的补码，整数就是原码，负数是将数字的反码（如果是正数，则表示方法和原码一样；如果是负数，则保留符号位1，然后将这个数字的原码按照每位取反，则得到这个数字的反码表示形式）加1。 假如a = -1;a是八位的数据。原码为1000 0001，但是计算机中存的是补码，也就是-1 的反码：1111 1111，那么计算机中表示的二进制为：1111 1111。 将a&gt;&gt;&gt;3，就是说以无符号数来右移3位，得到的数为：1111 1，就是说无论有没有符号，将这个补码右移三位就行。 三元操作符：boolean-exp?value0:value1; Math.round();四舍五入取整,参数是float或者double Math.ceil();向上取整 Math.floor();向下取整 控制执行流程while与do-while的区别就是：do-while至少会执行一次。 逗号操作符运用的位置：函数的参数列表用逗号隔开，和for语句中控制表达式for(int j = 0,i = 1=;j&lt;10;j++,i++),用逗号可以定义多个变量，但必须具有相同的类型。 for(int i:arr)是以foreach的方式遍历数组。 初始化与清理为了让方法名相同而形式参数不用的构造器同时存在，所以必须用到方法重载。也可应用于其他方法，且方法同样方便。根据返回值来重载方法是行不通的。在导出类中也可以对基类方法进行重载。 重载接收较小的基本类型（例如参数是int,传入long），如果传入的参数较大，就得通过类型转换来执行窄化转换。如果不这样做就会报错。 this只能在方法内部使用，表示调用那个方法的对象。需要返回对当前对象的引用时，可以直接使用：return this; 通过this对构造函数的调用，只能在构造函数内能调用，调用语句必须是第一句，并且一个构造器内只能调用一个构造函数。 static方法内部不能调用非静态的方法，但是反过来可以。调用static方法时，由于存在this（不需要实例化就可以调用），所以不是通过“向对象发送消息”。 垃圾回收器基本原理就是虚拟机每隔一段时间就会运行一次垃圾回收或是在虚拟机认为需要的时候。主动调用是System.gc()。垃圾回收器运行了当然会收回内在。 两个最基本的java回收算法：复制算法和标记清理算法 复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法 标记清理：一块区域，标记要回收的对象，然后回收，一定会出现碎片，那么引出标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象 两个概念：新生代和年老代 新生代：初始对象，生命周期短的 永久代：长时间存在的对象整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。 P.S： Serial New收集器是针对新生代的收集器，采用的是复制算法 Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理 Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法 Serial Old（串行）收集器，新生代采用复制，老年代采用标记清理 Parallel Old（并行）收集器，针对老年代，标记整理 CMS收集器，基于标记清理 G1收集器：整体上是基于标记清理，局部采用复制 综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。 使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize方法），他们也必须同内存及其回收有关。如果JVM并未面临内存耗尽的情形，它是不会花费时间去执行垃圾回收以恢复内存的。 最好是除了内存之外，不能依赖垃圾回收器做任何事情。如需清理，最好编写自己的清理方法，不要使用finalize()方法 当调用对象太多（我试了调用十万次）时，存储空间满了，会自动调用系统垃圾回收，强制进行终结的代码如下： 12System.gc();//调用系统的垃圾回收 java的所有对象（基本类型除外）都是在堆上分配的方式。每个对象都含有一个引用计数器，当引用的计数值变为0时，立即释放对象。 在类的内部，变量定义的先后顺序决定了初始化的先后顺序，但是变量初始化先于任何方法调用。静态初始化只有在必要的时候才会进行。构造器实际上也是静态方法。 123456789101112131415161718192021222324252627282930313233class Cup&#123; public Cup(int maker) &#123; // TODO Auto-generated constructor stub System.out.println("Cup("+maker+")"); &#125; void f(int maker)&#123; System.out.println("f("+maker+")"); &#125;&#125;class Cups&#123; static Cup cup1; static Cup cup2; static Cup cup4 = new Cup(4); Cup cup3; static&#123; //这个块只调用一次 cup1 = new Cup(1); cup2 = new Cup(2); //cup3不能放到静态块中，因为它不是静态的变量 System.out.println("--------"); &#125;&#125;public class YiWei &#123; public static void main(String[] args) &#123; Cups.cup1.f(1); &#125;&#125; java中指定可变参数实质上是编译器为程序员将参数列表填充为数组。 枚举类型初体验 123456789101112public class YiWei &#123; public static void main(String[] args) &#123; Spiciness howHot = Spiciness.NOT; swtch(howHot)&#123; //可以直接将枚举类型当作常数处理 &#125; &#125; public enum Spiciness&#123; NOT,MILD,MEDIUM,HOT,FLAMING &#125;&#125; 访问控制权限控制java包的命名规则是全部使用小写字母，包括中间的字也是如此。 类既不可以是private的，也不可以是protect。所以类权限只可以是public和包权限。如果不希望其他任何人对类有访问权限，可以对构造器设置权限为private. Java中，关键字package，包的命名模式和关键字import，可以使你对名称完全控制，从而避免命名冲突。 复用类复用类的方法有二：1 组合，2 继承。 toString();方法的调用机制：当编译器需要一个String而你却只有一个对象时，toString()方法就会被调用。 12345678910111213141516171819202122232425262728class Cup&#123; public Cup(int maker) &#123; // TODO Auto-generated constructor stub System.out.println("Cup("+maker+")"); &#125; void f(int maker)&#123; System.out.println("f("+maker+")"); &#125;&#125;class Cups extends Cup&#123; public Cups() &#123; // TODO Auto-generated constructor stub super(0); System.out.println("Cups"); &#125;&#125;public class YiWei extends Cups&#123; public static void main(String[] args) &#123; YiWei yiWei = new YiWei(); &#125;&#125;//输出：Cup(0)// Cups 从上面的输出结果来看，在实例化导出类的构建导出类的对象的时候，在那之前，基类的初始化已经完成了。在继承基类的时候，若是基类没有无参构造器，那么导出类会被编译器强制要求显式调用一个父类的一个构造器。若父类有无参构造器的话，则不会强制要求调用父类构造器，应该编译器隐式调用那么无参构造器。 @override可以防止在不想重载的时候进行了重载。 final修饰的变量必须赋值（在域的定义处或者每个构造器中用表达式对final进行赋值）。final对于基本数值，表示数值恒定不变；对于对象，表示引用恒定不变。无法指向下一块空间。但是对象本身是可以改变的。Java并未提供使对象恒定不变的效果。 带有恒定初始值的final static基本类型全用大写字母命名，并且单词与单词之间用下划线隔开。 final允许在参数列表中使用，表示无法在方法中更改参数引用所指向的对象。 final方法使用的原因有二：一：把方法锁定，不允许任何继承修改它的含义；二是因为效率（已经不需要）。类中所有的private方法都隐式的指定为final,如果试图覆盖一个private方法（隐式指定final），似乎是奏效的，而且编译器不会报错,但显示的final方法会报错。 final类表示不允许继承。 多态向上转型：把对象的引用视为对其基本类型的引用的做法被称作向上转型。 java是通过后期绑定（也叫动态绑定、运行时绑定）的方式，以便在运行的时候能判断对象的类型。 封装通过合并特征和行为来创建新的数据类型。实现隐藏则是通过将细节“私有化”把接口实现分离开来。而多态的作用是消除类型之间的耦合关系，将改变的事物与未变的事物分离开来。 非private，final方法才可以实现覆盖调用，而且只有方法可以是多态。如果一个方法是静态的，那它的行为也不具有多态性。构造方法是隐式的static方法。 构造器中唯一能安全调用的方法是基类的final方法，这些方法不会被覆盖。 接口包含抽象方法的类叫做抽象类。 c++参数列表入栈顺序从右往左，Java的顺序正好相反。 内部类匿名内部类嵌套内部类静态内部类内部类的使用复杂，而且极其容易忘记，内部类可以完成很多不可思议的需求。 持有对象Collection:Map,set,List Set中相同元素只能存储一次，但又不像Map那样以键值对的形式存储。HashSet是最快的元素获取方式，如果强调顺序则可以使用TreeSet(将元素升序存储)或者LinkedHashSet（添加的顺序存储）。TreeSet没有实现Colloction中的所有接口。 Map也是三种Map:HashMap查找最快，TreeMap升序，LinkedHashMap按插入的顺序存。 List分为ArrayList和LinkedList。两者在某些操作的性能不同，而且LinkedList包含的操作也多于ArrayList。 ArrayList:长于随机访问元素，但是在中间进行插入和删除元素比较缓慢。 LinkedList:通过较低的代价在List中间进行插入和删除操作。但是在随机访问方面相对较慢。添加了可以使其用做栈，队列，或双端队列的方法。[element() = getFirst(),offer()：将一个元素插到队尾,peek()：获取栈顶元素,poll(),remove() = removeFirst()] Stack:LinkedList具有能够直接实现栈的所有功能的方法，所以可以直接将LinkedList转换为Stack。[pop():移除并返回栈顶元素，peek(),push(),empty()] Map可以返回他的键的Set，他是值的Collection,或者他的键值对的Set.Map可以通过entrySet()和values()产生Colloction. Queue:队列是一个典型的先进先出的容器。在不需要Collection的方法的情况下，就可以拥有一个可用的Queue.它声明弹出的是等待时间最长的元素。 PriorityQueue:优先队列，它声明下一个弹出的是最需要的元素（最高的优先级）。comparator对象来改变排序（如果想在优先队列中使用自己的类，那么使用者就必须提供自己的Comparator）。 迭代器：遍历选择序列中的对象。通常被称为轻量级对象，创建他的代价小。Java中的Iterator只能单向移动。 ListIterator只能用于List的访问，可以双向移动。 通过异常处理处理错误123456789101112131415161718192021222324252627282930313233343536public class Test &#123;public static void main(String[] args) &#123; String i = null; /*try &#123; if (i == null) &#123; throw new MyException("string is null"); &#125; &#125; catch (MyException e) &#123; // TODO: handle exception e.printStackTrace(System.out);//以控制台输出的方式输出异常信息// for(StackTraceElement element:e.getStackTrace())//输出方法名这些// System.out.println(element.getClassName()+"."+element.getMethodName()+"."+element.getLineNumber()); &#125;*/ f(); System.out.println(4); &#125;static void f()&#123; try &#123; System.out.println(1); throw new MyException("2"); &#125; catch (MyException e) &#123; // TODO: handle exception System.out.println(3); &#125;finally &#123; System.out.println(5); &#125;&#125;&#125;输出：1354//在catch中再次抛出异常不能在外面捕获，应该也有作用域相关的问题。 当覆盖方法的时候，只能抛出基类方法的异常说明列出的那些异常。但这个异常限制对构造方法无用。派生构造器不能捕获基类构造器抛出的异常。一个出现在基类方法说明中的异常，不一定会出现在派生类中。不能通过异常说明来重载方法。 异常抛出之后，异常处理机制将搜寻参数与异常类型匹配的第一个处理程序，然后就不再查找。RuntimeException类型的异常属于错误，将被自动捕获，也称为不受检查异常。 新写一个异常时，抛出这个异常，通过捕获它的父类依然可以捕获到这个异常。catch Exception可以捕获到所有的异常。 所谓的把异常抛到更高层，就是在catch字句中，再次抛出。12345678910try &#123; System.out.println(1); throw new MyException("2"); &#125; catch (MyException e) &#123; // TODO: handle exception System.out.println(3); throw new NullPointerException(); &#125; 字符串String对象是不可变的，String中每一个看起来会修改String值的方法，实际上都是创建了一个新的String。 字符串想加时，编译器自动引入了StringBuilder类。因为它更高效。 append(a+”:”+c)这样的句子，编译器会另外创建一个StringBuilder来处理括号里的字符串操作。 StringBuilder是线程不安全的，StringBuffer线程安全，因此开销也更大。 正则表达式：-？:要找一个数字，可能有个-号在最前面；\d:描述整数，\\:插入一个普通的斜杠；+：一个或多个之前表达式。eg:-？\d+：最前面可能有一个负号，后面跟着一位或者多位数字；[abc]= a|b|c 包含a,b,c的任意字符 [a-zA-Z][abc[ijk]] = a|b|c|i|j|k\s：空白符\S:非空白符\d = [0-9]\D = [^0-9]\w = [a-zA-Z0-9]\W = [^a-zA-Z0-9]XY:X跟在Y的后面X|Y:X或者Y（X）:捕获组\G:一个匹配的结束 Split():将字符串从正则表达式匹配的地方切开。 类型信息事实证明，复习是十分重要的，可以发现很多被忽略掉的事情，例如：昨晚考了一道题，只包含0和1的数，按以前的习惯来讲吧，把数转换为String之后，循环判断这位是不是0或者1，其实还挺麻烦的，但是我想到昨天才看的正则表达式，我觉得这样是不是更简单一点，然后弄了个正则表达式（第一次写不是很熟练，尝试了几下才写出来），少了一层循环（时间复杂度减少，我很自豪，哈哈哈）。 罢了，言归正传。泛型这一大难题又在我眼前。 泛型最常用到是在容器类里面，就是Map,List，Set这样的类里面。例如：12List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 我们也用在自己写的类中：1123456789101112131415161718192021public class Me &lt;T&gt;&#123; T t; public void set(T t) &#123; this.t = t; &#125; public void print()&#123; System.out.println(t); &#125;&#125;//调用public class PuTong &#123; public static void main(String[] args) &#123; Me&lt;String&gt; me = new Me&lt;&gt;(); me.set(&quot;we are Chinese.&quot;); me.print(); &#125;&#125; 当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型，这称为类型参数推断。泛型方法可以存在在不是泛型类中：123456789101112public class PuTong &#123; public static &lt;T&gt; void print(T t) &#123; System.out.println(t); &#125; public static void main(String[] args) &#123; print(1); print("str"); print(0.25f); &#125;&#125; 泛型擦除：在使用泛型时，任何具体的类型信息都被擦除了，唯一知道就是在使用一个对象，在泛型代码内部，无法获得任何有关泛型参数类型的信息。List和List都是相同的类型，这两种形式都被擦除成原生的类型，即List。 边界： :T必须具有类型HasF或是HasF的子类。泛型类型参数将擦除到它的第一个边界。如果是普通的泛型就相当于将它擦除为Object,若是就相当于全部擦除为HasF类。&lt;? super Apple&gt;Apple是下界，可以用Apple的子类加入到类中，但声明最低都要是Apple才行。 泛型数组容器的深入研究Java I/O系统枚举类型注解并发组件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自我评价]]></title>
      <url>%2F2016%2F%E8%87%AA%E6%88%91%E8%AF%84%E4%BB%B7%2F</url>
      <content type="text"><![CDATA[前言：此自我介绍仅仅用于找工作时使用。 &emsp;&emsp;各位面试官，你们好。 &emsp;&emsp;我是刘群，今年21岁，来自重庆理工大学，平时喜欢看书和动漫。 &emsp;&emsp;我想说一下我大学我记忆比较深刻的事情。 &emsp;&emsp;第一件事，大一的时候和同学合伙在学校卖酸奶。当时我负责宣传和销售的部分。除了在我所做的工作所收获的，更收获的对专业的喜爱。室友的男朋友帮我们开发了一个微信订购系统，那时候对自己专业了解不深，觉得这个东西就这么被身边的人做起来了，引起了我对编程的兴趣，现在仍然保有这份兴趣。 &emsp;&emsp;第二件事，进入了我们的iCode团队。在这里我认识了我大学最好的朋友，也参与了人生中第一次真实项目。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统]]></title>
      <url>%2F2016%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[操作系统的复习比较细致，花了一天半边看书边整理框架，把基本的架构和一些我觉得需要注意的写在了框架上，还有一些需要代码实现的。 操作系统框架 基本状态转换 请求分页使用的最近最少未使用算法 操作系统框架 基本状态转换 请求分页使用的最近最少未使用算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 最近最少未使用算法 * * @author LiuQun * */public class LRU &#123; private int theArray[];//内存中的页面 private int back; // 定义队尾 private int currentSize; // 队列中存放元素个数 private int maxSize = 5; // 队列中能存放元素的个数 public LRU() &#123; theArray = new int[maxSize]; back = 0; currentSize = 0; &#125; /** * 挨个入队 * @param a */ public void queue(int sequence[]) &#123; for (int i = 0; i &lt; sequence.length; i++) &#123; enQueue(sequence[i]); &#125; &#125; /** * 将页面加入队列， * @param x 页号 */ public void enQueue(int x) &#123; // 入队 //检查队列中是否已经有了该页，并做另外的处理 beUsed(x); //队列未满的情况下，直接加入新页面（最开始与队列中已存在该页面） if (currentSize &lt; maxSize) &#123; theArray[back] = x; back++; currentSize++; &#125; //队列已满的情况下（队列中没有这个页面并且队列加满），移除第一个页面，其他的往前移动，将队尾的页面为新加入的 else if (currentSize == maxSize) &#123; // 满了 for (int i = 0; i &lt; maxSize - 1; i++) &#123; theArray[i] = theArray[i + 1]; &#125; theArray[maxSize - 1] = x; &#125; //打印队列中的元素 for (int i = 0; i &lt; currentSize; i++) &#123; System.out.print(theArray[i]); &#125; System.out.println(); &#125; /** * 判断是否已存在该页号,若存在，将这页后的页面往前移动，将这个已存在的页面删除 * @param x 页号 */ public void beUsed(int x) &#123; for (int i = 0; i &lt; currentSize; i++) &#123; if (theArray[i] == x) &#123; for (int j = i; j &lt; currentSize - 1; j++) &#123; theArray[j] = theArray[j + 1]; &#125; //当前页面数和队尾坐标都减1 currentSize--; back--; &#125; &#125; &#125; public static void main(String[] args) &#123; LRU lru = new LRU(); int[] sequence = &#123; 1, 2, 3, 4, 2, 1, 5, 6, 2, 1, 2, 3, 7, 6, 3, 2, 1, 2, 3, 6 &#125;; lru.queue(sequence); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于心境的问题]]></title>
      <url>%2F2016%2F%E5%85%B3%E4%BA%8E%E5%BF%83%E5%A2%83%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[有很多时候我都得说，人算不如天算，按照我自己的复习计划，这会儿我应该是高枕无忧才对，但是现在其实大概刚刚把算法复习完。我的网络几乎只复习了很小的一部分，还有Android的知识更是很久没看了，我还说把Parking项目检下来看一遍的也还没开始，我深深意识到我还差得远的。但是我身边的人似乎都开始浮躁了，大概是因为杨艳秋他们要去成都了的原因。到处做面试题不是说不好，但我觉得那样子根本不能好好复习的，这不是高考，刷题就可以，我觉得更多的应该是对知识的掌握吧。 可能是我太天真，我觉得应该是有真材实料才能有公司要的吧，不然的话，再怎么漂亮，我想通过笔试，光明正大的通过面试，就算是我不出色的外表也有公司觉得我值得被选择。 更有主动性地说，我想是我来选择公司而不是公司选择我。 我确实该沉下心好好学习的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查找算法]]></title>
      <url>%2F2016%2F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[贪婪算法]]></title>
      <url>%2F2016%2F%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[贪婪算法通过一系列步骤来构造问题的解，每一步对目前的部分解做一个扩展，直到获得问题的完整解为止。每一步都必须满足以下要求：可行，局部最优，不可取消。分为以下几个： Prime算法 Kruskal算法 Dijskra算法 哈夫曼树及其编码 Prime算法连通图的一颗生成树是包含图的所有顶点的连通无环子图。最小生成树是权重最小的生成树。 把离树近的顶点贪婪的包含进来。 Prime算法通过不断扩张的子树来构造一颗最小生成树。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static int unReach = 1000;public static int n = 4;public static void main(String[] args) &#123; int[][] G = &#123; &#123; 0, 4, 15, 10 &#125;, &#123; 4, 0, 10, unReach &#125;, &#123; 15, 10, 0, unReach &#125;, &#123; 10, unReach, unReach, 0 &#125; &#125;; boolean[] visit = new boolean[n]; int sum = 0; int[] dist = new int[n]; // 清空生成树，任取一个顶点加入生成树 initVisit(visit); int index = 0; visit[index] = true; for (int i = 0; i &lt; n; i++) &#123; dist[i] = G[index][i]; &#125; for (int i = 1; i &lt; visit.length; i++) &#123; int min = unReach;// 在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树 for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; (min &gt; dist[j])) &#123; min = dist[j]; index = j; &#125; &#125; visit[index] = true; sum += min; // 重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树 for (int j = 0; j &lt; n; j++) &#123; if (!visit[j] &amp;&amp; dist[j] &gt; G[index][j]) &#123; dist[j] = G[index][j]; &#125; &#125; &#125; System.out.println(sum);&#125;private static void initVisit(boolean[] visit) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; visit.length; i++) &#123; visit[i] = false; &#125;&#125; Kruskal算法在Prime算法中在树的生成过程中一直都是连通的，但是克鲁斯卡尔算法 在计算过程中却并不一定是连通的。算法开始的时候，会按照权重的非递减顺序对图中的边进行排序。然后从一个空子图开始，它会扫描这个有序列表，并试图将列表中的下一条边加到当前的子图中，这种添加法不应该产生回路，如果产生了回路就从这个边跳过。 克鲁斯卡尔（Kruskal）算法因为只与边相关，则适合求稀疏图的最小生成树。而prime算法因为只与顶点有关，所以适合求稠密图的最小生成树。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/** * @author LiuQun * 中心是快速求并法。用一个有根树来表示每一个子集，树中的节点包含子集中的元素； * 根中的元素就被当做该子集的代表树；树中的边从子女指向他们的父母 * makeset():创建一颗单节点的树 * union(x,y):把Y树的根附加到X上（并把Y树删除） * find(x):从包含x的节点开始找到树的根 * */public class Kruskal &#123; public static int n = 5;// 顶点个数 public static int edgeNum = 7;// 总边数 public static int father[] = new int[128];// public static int rank[] = new int[128];//树的等级（层数），优化算法用的，层数小的加在层数大的下 public static void main(String[] args) &#123; // 边的数组 Edge[] edges = new Edge[edgeNum]; edges[0] = new Edge(0, 1, 5); edges[1] = new Edge(1, 2, 3); edges[2] = new Edge(1, 3, 3); edges[3] = new Edge(3, 4, 8); edges[4] = new Edge(1, 4, 7); edges[5] = new Edge(4, 2, 3); edges[6] = new Edge(0, 2, 4); Edge[] result = new Edge[edgeNum]; int count = 0; // 按照权重排序树的边 srotEdge(edges); printEdge(edges); make_set(); // 将图遍历一次，找出权值最小的边，（条件：此次找出的边不能和已加入最小生成树集合的边构成环）， // 若符合条件，则加入最小生成树的集合中。不符合条件则继续遍历图，寻找下一个最小权值的边。 int sum = 0; for (int i = 0; i &lt; n; i++) &#123; // tree中无回路，使用不相交子集和并查算法 if (find_set(edges[i].getFirst()) != find_set(edges[i].getSecond())) &#123; union(edges[i].first, edges[i].second); sum += edges[i].value; result[count++] = edges[i]; &#125; &#125; System.out.println(sum); printEdge(result); &#125; //把每个元素初始化为一个集合 private static void make_set() &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; n; i++) &#123; father[i] = i; rank[i] = 1; &#125; return; &#125; // 采用直接插入排序 private static void srotEdge(Edge[] edges) &#123; // TODO Auto-generated method stub for (int i = 1; i &lt; edges.length; i++) &#123; if (edges[i].value &lt; edges[i - 1].value) &#123; int j = i - 1; Edge temp = edges[i]; while (j &gt; -1 &amp;&amp; temp.value &lt; edges[j].value) &#123; edges[j + 1] = edges[j]; j--; &#125; edges[j + 1] = temp; &#125; &#125; &#125; /** * 从包含x的节点开始找到树的根 * * @param x * 顶点 * @return */ public static int find_set(int x) &#123; if (x != father[x]) &#123; father[x] = find_set(father[x]); &#125; return father[x]; &#125; /** * 合并x,y所在的两个集合：利用Find_Set找到其中两棵树的根， 并将一棵树的根指向另一棵树的根。 * * @param first * x * @param second * y */ private static void union(int first, int second) &#123; // TODO Auto-generated method stub first = find_set(first); second = find_set(second); if (first == second) &#123; return; &#125; if (rank[first] &lt; rank[second]) &#123; father[first] = find_set(second); &#125; else &#123; if (rank[first] == rank[second]) &#123; rank[first]++; &#125; father[second] = find_set(first); &#125; return; &#125; public static void printEdge(Edge[] edge) &#123; for (int i = 0; i &lt; edge.length; i++) &#123; if (edge[i] != null) System.out.println(edge[i].toString()); &#125; &#125; static class Edge implements Comparable// 两点之间的加权边 &#123; private int first, second;// 表示一条边的两个节点 private int value;// 权值 public Edge(int first, int second, int value) &#123; this.first = first; this.second = second; this.value = value; &#125; public int getFirst() &#123; return first; &#125; public int getSecond() &#123; return second; &#125; public int getValue() &#123; return value; &#125; @Override public int compareTo(Object arg0) &#123; return value &gt; ((Edge) arg0).value ? 0 : -1; &#125; @Override public String toString() &#123; return "Bian[first=" + first + ",second=" + second + ",value=" + value + "]"; &#125; &#125;&#125; Dijskra算法Dijskra（戴克斯特拉）算法是单起点最短路径问题：指的是从一个起点到其他所有顶点的一系列最短路径。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class Dijkstra &#123; public static final int M = -1; static int[][] map = &#123; &#123; 0, 7, 9, M, M, 14 &#125;, &#123; 7, 0, 10, 15, M, M &#125;, &#123; 9, 10, 0, 11, M, 2 &#125;, &#123; M, 15, 11, 0, 6, M &#125;, &#123; M, M, M, 6, 0, 9 &#125;, &#123; 14, M, 2, M, 9, 0 &#125; &#125;; static int n = map.length; // 顶点个数 static int[] shortest = new int[n]; // 存放从start到其他各点的最短路径 static boolean[] visited = new boolean[n]; // 标记当前该顶点的最短路径是否已经求出，true表示已求出 public static void main(String[] args) &#123; int orig = 0; int[] shortPath = dijkstra_alg(orig); if (shortPath == null) &#123; return; &#125; for (int i = 0; i &lt; shortPath.length; i++) &#123; System.out.println("从" + (orig + 1) + "出发到" + (i + 1) + "的最短距离为：" + shortPath[i]); &#125; &#125; public static int[] dijkstra_alg(int orig) &#123; // 初始化，第一个顶点求出 shortest[orig] = 0; visited[orig] = true; for (int count = 0; count != n - 1; count++) // 要加入n-1个顶点 &#123; // 选出一个距离初始顶点最近的未标记顶点 int k = M; int min = M; for (int i = 0; i &lt; n; i++) &#123; if (!visited[i] &amp;&amp; map[orig][i] != M) &#123; if (min == -1 || min &gt; map[orig][i]) &#123; min = map[orig][i]; k = i; &#125; &#125; &#125; // 正确的图生成的矩阵不可能出现K == M的情况 if (k == M) &#123; System.out.println("the input map matrix is wrong!"); return null; &#125; shortest[k] = min; visited[k] = true; // 以k为中间点，修正从原点到未访问各点的距离 for (int i = 0; i &lt; n; i++) &#123; if (!visited[i] &amp;&amp; map[k][i] != M) &#123; int callen = min + map[k][i]; if (map[orig][i] == M || map[orig][i] &gt; callen) &#123; map[orig][i] = callen; &#125; &#125; &#125; &#125; return shortest; &#125;&#125; 哈夫曼树及其编码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[温柔拯救]]></title>
      <url>%2F2016%2F%E6%B8%A9%E6%9F%94%E6%8B%AF%E6%95%91%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;温柔的人真的是很奇妙的，他能让你也不自觉地变得温柔。一个人和温柔的人吵起来的概率起码低于一般人的50%，我喜欢温柔的人，喜欢温柔的声音，喜欢被温柔的对待。 &emsp;&emsp;温柔不是说话小声小气，动作和缓这样的表面信息，而是更注重内心的东西。一个人内心是温柔的话，即使他的外表粗犷，他说话声音洪亮也是温柔的。他能让你感觉到内心的善良，并且与之同样的会不自觉的变得温柔。 &emsp;&emsp;手冢外表是冰冷的，但即使是我第一次见着他的时候也没觉得他就是冷漠的人，之后不自觉的让人感觉到温柔，大概这也是这个角色这么遭人喜爱的原因了。所以温柔不是外表，不是声音，而是内心。内心的温柔会不自觉的表现在你的外貌，声音上，会让你的脸色变得温和，会让声音变得温柔。 &emsp;&emsp;我以前其实觉得我是温柔的人（即使我的外表看起来并不温柔），但是我会不自觉的开伤人自尊的玩笑，不自觉的有些低俗而粗鲁的行为。我想做个温柔而温暖的人，让这个世界多一点温柔，在我温柔待人的时候也能换来别人的温柔以待。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态规划]]></title>
      <url>%2F2016%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
      <content type="text"><![CDATA[动态规划的思想就是每次都是最优，综合到了最终得到的方案也是最优。是比较常用的算法，归结起来是以下这几个： 背包问题 记忆化 币值最大化问题 找零问题 Warshall算法 Floyd算法 最优二叉查找树（未完成） 背包问题有n个物体有重量和价值两个属性，一个能承重一定重量的背包。问怎么选择物体能实现背包里的价值最大化。 假设有5个物体和一个背包。物体的重量分别是2、2、6、5、4，即W[]={0、2、2、6、5、4}，价值分别是6、3、5、4、6，即V[]={0、6、3、5、4、6}。背包承重为10。问怎么选择，能实现背包所背物体价值的最大化。 背包的状态转换方程 f[i,j] = Max{ f[i-1,j-Wi]+Vi( j &gt;= Wi ), f[i-1,j] }f[i,j]表示在前i件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。Pi表示第i件物品的价值。根据规则填表如下：代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public static int backpackWeight= 11;public static int num = 5;public static void main(String[] args) &#123; int weight[] = new int[]&#123;0,2,2,6,5,4&#125;; int value[] = new int[]&#123;0,6,3,5,4,6&#125;; int flag[] = &#123; 0, 0, 0, 0, 0 &#125;; int table[][] = new int[num][backpackWeight]; initTable(table); createTable(table,weight,value); obj_opt(table,flag,weight); showTable(table);&#125;public static void showTable(int[][] table) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; table.length; i++) &#123; for (int j = 0; j &lt; table[i].length; j++) &#123; System.out.print(table[i][j]+"\t"); &#125; System.out.println(); &#125;&#125;//得到选择了哪些物品//我们从右上角（坐标（1,10））开始，看（1,10）与（2,10）的值是不是一样，//一样，则说明物体1没装进去，不一样，则说明物体1装进去了。public static void obj_opt(int[][] table, int[] flag, int[] weight) &#123; // TODO Auto-generated method stub int n = backpackWeight-1; for (int i = 0; i &lt; num; i++) &#123; if ((i != num-1)&amp;&amp;(table[i][n] == table[i+1][n])) &#123; //这里感觉是有问题的 flag[i] = 0; &#125;else &#123; flag[i] = 1; n = n-weight[i+1]; &#125; &#125; System.out.print("选择的："); printArray(flag); System.out.println();&#125;//打印排序数组public static void printArray(int[] arr) &#123; System.out.println(); for(int i = 0;i&lt; arr.length;i++)&#123; System.out.print(arr[i]+"\t"); &#125;&#125;public static void createTable(int[][] table, int[] weight, int[] value) &#123; // TODO Auto-generated method stub //给最后一行赋初值 for (int i = 0; i &lt; backpackWeight; i++) &#123; if (weight[num] &gt; i) &#123;//物品的重量大于背包可承重能力 table[num-1][i] = 0; &#125;else &#123; table[num-1][i] = value[num]; &#125; &#125; //在最后一行的基础上给每行赋值 for (int i = num-1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; backpackWeight; j++) &#123; if (weight[i]&gt;j) &#123;//i物品的重量大于背包重量 table[i-1][j] = table[i][j]; &#125;else if ((value[i]+table[i][j-weight[i]])&gt;table[i][j]) &#123;//i-1和i个物品的价值大于i之前的物品价值 table[i-1][j] = value[i]+table[i][j-weight[i]]; &#125;else &#123; table[i-1][j] = table[i][j]; &#125; &#125; &#125; &#125;public static void initTable(int[][] table) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; table.length; i++) &#123; for (int j = 0; j &lt; table[i].length; j++) &#123; table[i][j] = 0; &#125; &#125; &#125; 记忆化用递归的方式实现动态规划 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * @author LiuQun 对必要的子问题只解决一次就是以记忆化为基础的 用递归方式 */public static int weight[] = new int[] &#123; 0,2, 2, 6, 5, 4 &#125;;public static int value[] = new int[] &#123;0, 6, 3, 5, 4, 6 &#125;;public static int backpackWeight = 11;public static int num = 5;public static int[][] F = new int[num+1][backpackWeight+1];public static void main(String[] args) &#123; initF(F); mfkNapsack(5, 11); showTable(F);&#125;/** * 初始化F数组，行列0时初始化为0，其他事-1 * * @param f */private static void initF(int[][] f) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; f.length; i++) &#123; for (int j = 0; j &lt; f[i].length; j++) &#123; if (j == 0 || i == 0) &#123; f[i][j] = 0; &#125; else &#123; f[i][j] = -1; &#125; &#125; &#125;&#125;/** * 对背包问题实现记忆化 * * @param i * 先考虑的物品数量 * @param j * 剩余可装入物品重量 */public static int mfkNapsack(int i, int j) &#123; // TODO Auto-generated method stub if (i == 0||j == 0) &#123; return 0; &#125; int Value = -1; if (F[i][j] &lt; 0) &#123; if (j &lt; weight[i]) &#123;// 如果可承重量比物品的重量还小，那么就换下个物品 Value = mfkNapsack(i - 1, j); &#125; else &#123; int fir = mfkNapsack(i - 1, j); int sed = value[i] + mfkNapsack(i - 1, j - weight[i]); if (fir &gt; sed) &#123;//不加入这个物品的价值与加入之后的对比看谁最大，用递归方式 Value = fir; &#125; else &#123; Value = sed; &#125; &#125; &#125; F[i][j] = Value; return F[i][j];&#125;public static void showTable(int[][] table) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; table.length; i++) &#123; for (int j = 0; j &lt; table[i].length; j++) &#123; System.out.print(table[i][j]+"\t"); &#125; System.out.println(); &#125;&#125; 币值最大化所谓币值最大化，就是给定一排的n个硬币。选择硬币使得在其原始位置不相邻的条件，所选的硬币总金额最大，代码如下： 12345678910111213141516171819202122/** * 币值最大化的问题（原始位置不相邻的条件下） * @author LiuQun * 包括最后一枚硬币和不包括最后一枚硬币。公式为：max&#123;F（n-2）+c[i],F[n-1]&#125; */public static void main(String[] args) &#123; int[] coin = &#123;5,1,2,10,6,2&#125;; int res[] = new int[coin.length]; res[0] = 0; res[1] = coin[0]; for(int i = 2;i&lt;coin.length;i++)&#123; if (coin[i]+res[i-2]&gt;res[i-1]) &#123; res[i] = coin[i]+res[i-2]; &#125;else&#123; res[i] = res[i-1]; &#125; &#125; printArray(res);&#125; 找零问题所谓找零问题就是给定一定额度的币值数组，然后通过动态规划，找了需要找零的最大面值的剩余的最小，每次都最小，到最后就到达了最少的币值张数（暂时有点遗憾没把找零的钱是哪几张给找出来）。代码如下 123456789101112131415161718192021222324252627282930313233343536373839/* 找零问题 * F[n] = min&#123;F(n-dj)&#125;+1 * @author LiuQun */public static void main(String[] args) &#123; System.out.println("请输入一个整数："); Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] d = &#123;0,1,2,5,10,20,50,100&#125;; System.out.println(changeMaking(d,n)); &#125;public static int changeMaking(int[] d, int n) &#123; // TODO Auto-generated method stub int[] F = new int[n+1]; F[0] = 0;//不找零的时候0张币 int temp = 1000; for(int i = 1;i&lt;=n;i++)&#123;//1到n块的零钱（遍历F数组） temp = 1000; int j = 1;//第一个币值开始算 while (j &lt; d.length &amp;&amp; i &gt;= d[j]) &#123;//币值范围内，且要找零的钱大于这个币值 //如果只需要找零(i-d[j])块,而且这几块要比之前的中转值小，那就换成新的（i-d[j]）【相当于用20找零之后发现有50这样的，就替换了】 if (F[i-d[j]] &lt; temp) &#123; temp = F[i-d[j]]; &#125; j += 1; &#125; //F[i-d[j]]只比F[i]少了一个d[j]的币，所以+1 F[i] = temp+1; &#125; //printArray(F); return F[n]; &#125; Warshall算法有向图G，求图G中每一对顶点间是否连通的问题。代码与详细注释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author LiuQun * 邻接矩阵-----&gt;有向图传递闭包 * 从不允许中间有任何一点到可以允许更多中间点构建临接矩阵 */public class Warshall &#123; public static void main(String[] args) &#123; //邻接矩阵 int R[][] = &#123; &#123;0,1,0,0&#125;, &#123;0,0,0,1&#125;, &#123;0,0,0,0&#125;, &#123;1,0,1,0&#125;&#125;; int n = 4; //①如果一个元素在R(k-1)中是1，那么在R(k)中也是1 //②如果在R[i][j](k-1)中是0，当且仅当第i行k列的元素与第k行j列的元素都为1时，该元素在R(k)中变为1 //关于第二条其实就是一个十字框，除开十字相交的点，两条轴上都有1时，那么以这两1为顶点（已经有三点），长方形的第四点即在下一次也变为1 for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (R[i][j] == 1||(R[i][k]*R[k][j]==1)) &#123; R[i][j] = 1; &#125; &#125; &#125; &#125; showR(R); &#125; public static void showR(int[][] table) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; table.length; i++) &#123; for (int j = 0; j &lt; table[i].length; j++) &#123; System.out.print(table[i][j]+"\t"); &#125; System.out.println(); &#125; &#125;&#125; Floyd算法Floyd算法 又称为插点法，是一种用于寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。通过一个图的权值矩阵求出它的每两点间的最短路径矩阵。 其状态转移方程如下：map[i,j]:=min{map[i,k]+map[k,j],map[i,j]}：指的是i，与j之间的最小距离是i到k与k到j之间距离之和小于i与j直接距离 之前帮同学做了一个建立医疗站的案例也是用的本算法，设置不可到达的点为一个巨大无比的数字，超过那个数字的都认为亮点之间不可到达。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args) &#123; int[][] arr = new int[][] &#123; &#123; 0, 1, unReach, 1, 5 &#125;, &#123; 1, 0, unReach, 4, 2 &#125;, &#123; unReach, unReach, 0, 2, unReach &#125;, &#123; 1, 4, 2, 0, 7 &#125;, &#123; 5, 2, unReach, 7, 0 &#125; &#125;; printArr(arr, length); //初始化距离数组 int[][] dis = new int[length][length]; for (int i = 0; i &lt; length; i++) &#123; for (int j = 0; j &lt; length; j++) &#123; dis[i][j] = arr[i][j]; &#125; &#125; //floyd算法 for (int k = 0; k &lt; length; k++) &#123; for (int i = 0; i &lt; length; i++) &#123; for (int j = 0; j &lt; length; j++) &#123; //i，与j之间的最小距离是i到k与k到j之间距离之和小于i与j直接距离。 if (dis[i][j] &gt; dis[i][k] + dis[k][j]) &#123; //状态公式 dis[i][j] = dis[i][k] + dis[k][j]; &#125; &#125; &#125; &#125; System.out.println("---------结果是----------"); printArr(dis, length);&#125;/** * 方法简述：打印数组，调用可以在控制台输出最近距离的那个矩阵 * @param arr 数组 * @param n 数组长度 */public static void printArr(int[][] arr, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.print(arr[i][j] + "\t"); &#125; System.out.println(); &#125;&#125; 最优二叉查找树]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c++基础学习]]></title>
      <url>%2F2016%2Fc-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[2016-08-11到今天为止只学习了慕课网的基础课程C++远征之起航篇根据这之前的学习总结下： 多了bool类型变量，表示：true,false 输入输出语句 命名空间 代码编写技能 2016-09-04日补充 const字 引用（指针） 函数特性 2016-09-06日补充 封装类 初始化对象 对象的访问 输入输出语句输出 输出语句比较简单，就是cout&lt;&lt;x&lt;&lt;endl; 更详细的不想细说，输出两个变量时：x后面可以继续&lt;&lt;y再输出其他的这样（cout&lt;&lt;x&lt;&lt;y&lt;&lt;endl）。 endl与回车一个意思，可以不要。 输入 cin&gt;&gt;x 然后这个值就已经在x上了。 命名空间namespace是我在c++中见过的比较独特的东西（java，c中都没见过），可以在里面写方法写属性，感觉跟java中静态类有点像，不需要实例化这些：定义：12345namespace myNum //填写命名空间的关键字&#123; int x = 105;&#125; 使用（在一个文件内不需要using myNum）:1234567using namespace std;//标准命名空间，输入输出那些关键字if (myNum::x % 2 == 0) &#123; //改变状态位的值，使其为false isFlag = false; &#125; 代码编写技能我是用VS来编写代码的，新建项目之后，有个解决方案的东西，一个解决方案对应一个项目对应一个main方法，多个文件里都有main方法会报错。还有就是最后一句一定要加上system(“pause”)；不然看不到运行结果 const字① const int a = 3;② int const a = 3;③ int const p = 3;④ const int p = 3;①，②两句完全等价，不能再对a改变赋值,③，④两句完全等价 但是，int * const p = 3与③，④不等价，也可以两处都加const const p这样不能对p改变赋值 const p不能通过p来改变赋值两处都使用const时，不能通过p,p来改变赋值int const a = 3;指针指向const修饰的变量时，应该是const int const p = &a; 123456789//定义常量countconst int count = 3;const int *p = &amp;count;//打印count次字符串Hello C++for (int i = 0; i &lt; count; i++)&#123; cout &lt;&lt; "Hello imooc" &lt;&lt; endl;&#125; 引用普通类型123int a = 3;int &amp;b = a;//b为a的别名 构造类型： 12345678910111213typedef struct &#123; int x; int y;&#125;Coor;void quoteTest() &#123; Coor c; Coor &amp;c1 = c; c1.x = 10; c1.y = 20; cout &lt;&lt; c.x &lt;&lt; c.y &lt;&lt; endl;&#125; 指针类型： 12345int a =10;int *p = &amp;a;int *&amp;q = p;//指针p指向a;q是p的别名,改变*q的值也会改变a的值 在作为函数参数时： 123456789void fun(int &amp;a,int &amp;b)&#123; //交换 int c = a; a = b; b = c;&#125;int x = 10;int y = 20;fun(x,y)； 别名必须对应一个真实的变量：int &amp;b = NULL;这种写法是错的;引用不能单独存在：int &a;这种写法也是错误的。 函数特性可以在参数列表进行设置默认值。但一定要在最右端；在声明的时候加默认值，在定义的时候不加默认值。实参覆盖默认值 ；名称相同，参数可变。 1234567891011121314151617181920212223//三种都可以调用functionTest(10,2,3); functionTest(10, 2);functionTest(10);functionTest(10,2.2,3.3); functionTest(10, 2.2222);functionTest(10.222);void functionTest(int i, int j = 10,int k = 20);void functionTest(int i, int j, int k ) &#123; cout &lt;&lt; i &lt;&lt; j &lt;&lt; k &lt;&lt; endl;&#125;void functionTest(double i, double j = 10,double k = 2.3333); void functionTest(double i, double j, double k ) &#123; cout &lt;&lt; i &lt;&lt; j &lt;&lt; k &lt;&lt; endl;&#125; 内联函数只是一种编译方式，是建议内联函数，要求逻辑必须简单，不能有递归，不能有循环 1234567891011121314151617181920212223242526272829 inline void change(int &amp;b,int &amp;a)&#123; //交换 &#125;``` ## c++内存管理 ##new 关键字申请内存，delete释放内存； new和delete一定要配套使用 ```cpp int *p = new int; *p = 20; delete p; //在堆中申请100个char类型的内存 char *str = new char[100]; //拷贝Hello C++字符串到分配的堆中的内存中 strcpy(str, "Hello imooc"); //打印字符串 cout &lt;&lt; str &lt;&lt; endl; //释放内存 delete[]str; str = NULL; 申请内存有可能不成功；判断是否申请成功：123456int *p = new int（20）;//同时进行初始化if(p == NULL)&#123;//内存分配失败//异常处理&#125; 封装类c++的类是通过关键字class来表示的。对于类里面的属性和方法的访问控制由private,public,protect来控制的(含义与java里面类似)。 一般把public写在前面，private写在后面。具体实例代码如下。 12 初始化对象c++的对象的初始化对象有两种，一种是在栈上初始化，一种是在堆上初始化。 栈上分配的方式不需要new关键字申请内存，相应的也不需要delete来释放内存，用一个‘.’来访问这个对象内部的数据和方法； 堆上分配的方式就是普通java对象实例化的方式，通过new关键字来在堆上申请内存，同时也必须通过delete来释放申请的内存，通过‘-&gt;’来访问对象内部的数据和方法。 具体的实例代码如下： 12 对象的访问与java类似，数据域如果可以直接访问是不科学的，违背了面向对象的原则，所以要进行访问控制。一般来说就是要将所有的数据域（属性）都要设置为private，而根据需求来确定是否需要编写get/set方法。 代码如下： 12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法]]></title>
      <url>%2F2016%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[排序复习排序算法复习了好久，一直进度缓慢，因为有个叫做堆排序的一直拦着我，强迫症真的不理解这个就没办法做下一个……然后就一直卡在这儿，边写博客边把这个算法攻克了去看其他的算法了。八大排序： 冒泡排序 选择排序 快速排序 归并排序 插入排序 希尔排序 堆排序 桶排序/基数排序 冒泡排序冒牌排序从大一学C语言就已经学了，根据排序规则，前面的与后面的比对，违背了规则的就交换位置，代码如下：1234567 for (int i = 0; i &lt; arr.length; i++) &#123; for(int j = i+1;j&lt;arr.length;j++)&#123; if (arr[i]&lt;arr[j]) &#123; swap(arr, i, j); &#125; &#125;&#125; 选择排序也是大一就是学的，每次找出最大或者最小的，然后与已排序到第几位的那个位置交换，可以二元选择，同时找最大和最小，省时间： 1234567891011121314151617181920for (int i = 0; i &lt; arr.length; i++) &#123; int maxIndex = max(arr,i); if ( maxIndex != i) &#123; swap(arr,maxIndex,i); &#125; &#125;//找最大的索引值 public static int max(int[] arr,int start) &#123; int max = arr[start]; int maxIndex = start; for (int i = start; i &lt; arr.length; i++) &#123; if (arr[i]&gt;max) &#123; max = arr[i]; maxIndex = i; &#125; &#125; return maxIndex; &#125; 快速排序快速排序，要找到 中间的那个元素，通过中间的那个元素把元素分为比基准元素大的，比基准元素小的，两头同时用指针，两边都不符合（头（i）比基准大且尾部（j）比基准小）则交换，直到i&gt;j的时候，i就是那个中间元素，就是基准元素应该待的位置：代码如下 1234567891011121314151617181920212223242526272829public static void quickSort(int[] arr,int low,int high) &#123; if (low &lt; high) &#123; int middle = getMiddle(arr,low,high); quickSort(arr, 0, middle-1); quickSort(arr, middle+1, high); &#125; &#125;public static int getMiddle(int[] arr, int low, int high) &#123; // TODO Auto-generated method stub int temp = arr[low]; while (low&lt;high) &#123; //找到后面半截比基准元素还大的元素就停止 while (low&lt;high&amp;&amp;arr[high] &lt;= temp) &#123; high -- ; &#125; //将后面那个大的赋值到基准元素那里 arr[low] = arr[high]; //找到前面半截比基准元素还小的元素就截止 while (low&lt;high &amp;&amp; arr[low] &gt;= temp) &#123; low ++; &#125; //将前面小于基准的元素和后面大于基准的元素置换 arr[high] = arr[low]; &#125; //low就是基准元素应该呆的位置 arr[low] = temp; return low; &#125; 归并排序所谓归并就是两组两组的合并然后排序。需要一个中转的数组。 12345678910111213141516171819202122232425262728293031323334353637public static void mergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex) &#123; // TODO Auto-generated method stub //递归调用mergeSort来对数组进行排序表 int midIndex; if (startIndex &lt; endIndex) &#123; midIndex = (startIndex + endIndex) / 2; mergeSort(sourceArr, tempArr, startIndex, midIndex); mergeSort(sourceArr, tempArr, midIndex+1, endIndex); merge(sourceArr, tempArr, startIndex, midIndex, endIndex); &#125;&#125;/** * 将B,C数组合并到A数组中 */public static void merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex) &#123; // TODO Auto-generated method stub int i = startIndex, j=midIndex+1, k = startIndex; //交叉的 while(i!=midIndex+1 &amp;&amp; j!=endIndex+1) &#123; if(sourceArr[i] &gt;= sourceArr[j]) tempArr[k++] = sourceArr[j++]; else tempArr[k++] = sourceArr[i++]; &#125; //B数组剩下的 while(i != midIndex+1) tempArr[k++] = sourceArr[i++]; //A数组剩下的 while(j != endIndex+1) tempArr[k++] = sourceArr[j++]; //将中转的数组那段的值赋值到原来的数组里 for(i=startIndex; i&lt;=endIndex; i++) sourceArr[i] = tempArr[i];&#125; 插入排序插入排序就是默认第一个都是已经排序了的，然后后面的元素一个一个插入进去： 12345678910111213//默认第一个是有序的，后面再一个一个插入 for (int i = 1; i &lt; arr.length; i++) &#123; if(arr[i] &gt; arr[i-1])&#123; int j = i-1; int temp = arr[i]; while (j&gt;-1&amp;&amp;temp &gt; arr[j]) &#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = temp; &#125; &#125; 希尔排序希尔排序是先将数组分为几组，每一组有d个，然后慢慢的将d减小为1为止是成功排序（d,d/2,d/4……）先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 12345678910111213141516int d = arr.length/2; if (d%2==0) &#123; d = d+1; &#125; while (d&gt;0) &#123; for(int i = 0;i&lt;arr.length-d;i++)&#123; if (arr[i]&gt;arr[i+d]) &#123; swap(arr, i, i+d); &#125; &#125; d = d/2; if (d&gt;0&amp;&amp;d%2==0) &#123; d = d+1; &#125; printArray(arr); &#125; 堆排序堆排序在我看来的话就是把不规则的堆弄成规则的大顶堆或者小顶堆。因为这个东西对我来说比较抽象，所以更详细的写。思想： 数组当做是无序的堆。 将最大的记录和最后一个记录R[n]交换。所以最后一个记录是有序的，之前的R[1……n]都是无序的。 再将R[1……n]中最大的与它最后一个交换。 重复3直到无序区只有一个元素为止。 操作： 建堆（数组本身） 调整堆（成大顶堆）：思想的2，3 堆排序（不必要。既大顶堆调整为小顶堆） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class HeapSort &#123; public static void main(String[] args) &#123; int[] arr = new int[] &#123; 23, 32, 45, 54, 34, 24, 46, 35, 26 &#125;; buildMaxHeapify(arr); heapSort(arr); System.out.println(Arrays.toString(arr)); &#125; //构造大顶堆 private static void buildMaxHeapify(int[] data) &#123; // 没有子节点的才需要创建最大堆，从最后一个的父节点开始 int startIndex = getParentIndex(data.length - 1); // 从尾端开始创建最大堆，每次都是正确的堆 for (int i = startIndex; i &gt;= 0; i--) &#123; maxHeapify(data, data.length, i); &#125; &#125; /** * 将大顶堆调整为小顶堆 * 排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的 * * @paramdata */ private static void heapSort(int[] data) &#123; // 末尾与头交换，交换后调整最大堆 for (int i = data.length - 1; i &gt; 0; i--) &#123; int temp = data[0]; data[0] = data[i]; data[i] = temp; maxHeapify(data, i, 0); &#125; &#125; /** * 创建最大堆 * * @paramdata * @paramheapSize需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了 * @paramindex当前需要创建最大堆的位置 */ private static void maxHeapify(int[] data, int heapSize, int index) &#123; // 当前点与左右子节点比较 int left = getChildLeftIndex(index); int right = getChildRightIndex(index); int largest = index; //index位置的值比他的左孩子小 if (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) &#123; largest = left; &#125; //index位置的值比它右孩子小 if (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) &#123; largest = right; &#125; // 得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要以被调整的那个子孩子重新调整为父节点继续调整 if (largest != index) &#123; int temp = data[index]; data[index] = data[largest]; data[largest] = temp; maxHeapify(data, heapSize, largest); &#125; &#125; /** * 父节点位置 * &gt;&gt;表示右移 15&gt;&gt;2=3,3&gt;&gt;1=1 * &lt;&lt;表示左移 3&lt;&lt;1 = 6,5&lt;&lt;1 = 10 * @paramcurrent * @return */ private static int getParentIndex(int current) &#123; return (current - 1) &gt;&gt; 1; &#125; /** * 左子节点position注意括号，加法优先级更高 * * @paramcurrent * @return */ private static int getChildLeftIndex(int current) &#123; return (current &lt;&lt; 1) + 1; &#125; /** * 右子节点position * * @paramcurrent * @return */ private static int getChildRightIndex(int current) &#123; return (current &lt;&lt; 1) + 2; &#125;&#125; 桶排序/基数排序对于我来说，这个算法比堆排序还陌生，因为感觉听都没听过…… 对于数组：73, 22, 93, 43, 55, 14, 28, 65, 39, 81 首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中 接下来将这些桶子中的数值重新串接起来，成为以下的数列：81, 22, 73, 93, 43, 14, 55, 65, 28, 39 接着再进行一次分配，这次是根据十位数来分配 接下来将这些桶子中的数值重新串接起来，成为以下的数列：14, 22, 28, 39, 43, 55, 65, 73, 81, 93 这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。 代码听起来不难，自己调整写的代码如下： 12345678910111213141516171819202122232425262728293031323334public static void sort(int[] number, int d) //d表示最大的数有多少位&#123; int m = 1; int n = 1; int k = 0; int[][] temp = new int[10][number.length]; int[] order = new int[10];//order[i]表示该位（个，十）时i的数的个数 while (m&lt;=d) &#123; //归相应的桶中 for (int i = 0; i &lt; number.length; i++) &#123; int lsd = (number[i]/n)%10; temp[lsd][order[lsd]] = number[i]; order[lsd]++; &#125; //从桶里读出来 for (int i = 0; i &lt; 10; i++) &#123; if (order[i] != 0) &#123; for (int j = 0; j &lt; order[i]; j++) &#123; number[k] = temp[i][j]; k++; &#125; order[i] = 0;//恢复为0为下一位做准备 &#125; &#125; n *= 10; k = 0;//恢复为0为下一位做准备 m++;&#125; &#125; 总结排序是很常见的算法，除了对堆排序，其他都很容易理解，时间复杂度各不相同。各种排序的稳定性，时间复杂度和空间复杂度总结： 时间复杂度增长情况]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[复习计划]]></title>
      <url>%2F2016%2F%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
      <content type="text"><![CDATA[反省&emsp;&emsp;今天是几月几号我都不想提醒我自己了，老油条大概说的就是我这种人吧。之前的复习还是乱七八糟复习了些算法的排序算法，接下来应该真正的复习了。 复习目标&emsp;&emsp;所谓复习目标，其实我就是归纳复习的科目。 算法分析 网络 计算机操作系统 Linux c++ 第一行代码 Android 艺术探索 复习安排&emsp;&emsp;接下来到找到工作还有大概4周。 c++在手机慕课网上学习，然后每天下午花一小时左右做一些编程练习。 算法分析：排序，最短路径等。这周之内把它复习完。看书和写代码。 计算机操作系统：看书，看Linux的书，还有慕课网Linux。务必在一周之内完成。 网络还是比较重要的东西，但是20号我得到西宁去一趟，中间大概得耽搁5天左右，这几天就专门看网络，在这耽搁的一周内完成。 剩下的都是Android的东西了。基础控件我忘了挺多了。花3天时间整理下基础控件，然后将小猪的菜鸟博客看了，代码实现部分。 完成上面的东西的话，时间的话应该已经是9月左右了，撇开综合课程设计。这之后都是看Android进阶的东西。首先得把Android艺术探索看完，时间应该在1周左右，完成部分代码。 笔试面试&emsp;&emsp;接下来的时间真的就是做笔试题，投简历的时间了。通过做一些笔试题，完善自己。并且在平常也尽量每天花一小时左右做笔试题。&emsp;&emsp;张这么大没怎么参加过面试，我这个人比较容易紧张，我得怎么克服我自己的紧张呢？&emsp;&emsp;感觉越来越紧张，时间越近越沉不住气，虽然我还没好好复习呢。&emsp;&emsp;既然是复习，我就不要沉迷在看书里面。最多只能看5本书，可以买，但是必须得到offer之后才能看。至于漫画，动漫就先暂停吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[观《钱学森》有感]]></title>
      <url>%2F2016%2F%E8%A7%82%E3%80%8A%E9%92%B1%E5%AD%A6%E6%A3%AE%E3%80%8B%E6%9C%89%E6%84%9F%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;既是因为毛中特课程的作业，也是对钱学森先生的敬佩看了这部电影。关于电影技术，演员演技之类的我就不讨论了，因为我是门外汉。我想讨论的就是电影想要传播给我们的东西。 &emsp;&emsp;钱学森先生在美国加州理工大学任终身教授，接到当时的国内北方的联系就下定决心回国，但此时还在理工大学任教。就在之后不久，他被美国政府怀疑与中国共产党有联系，被监狱拘留审问之后决定驱逐钱学森。 &emsp;&emsp;我相信任何一个人都不能无视这种侮辱，这使他回国的愿望更加迫切。钱学森回家之后安排订了最近时间的一个航班，行李都打包运出去了。没有人能想到的是，倡导民主的美国以怀疑他带走美国机密为由撬了他的行李，一点一点进行检查。这一次被拘留更久，甚至要花钱来保释他。 &emsp;&emsp;其间的详情不必赘述，帝国主义的狭隘我能理解，毕竟钱先生是这么这么的重要，但是理解不代表支持，他们完全的违背他们自己所说的民主。在钱学森先生几乎被软禁在美国时，钱学森先生依然潜心著作，完成了《工程控制理论》。偶然的机会，他在报纸上看到陈叔通站在天安门城楼上，身份是全国人大常委会副委员长，他决定给这位父亲的好朋友写信求救。周恩来总理与毛主席不惜用是战俘的美国飞行员来换钱学森先生安全回国，并且周恩来总理在与美国外交谈判上的不断周旋。终于，1955年，在钱学森同志44岁的时候回国了。 &emsp;&emsp;钱学森先生的一位美国朋友问他，“中国没有航空科技，一点都没有，一个杰出的航空科学家回到农耕社会，能做些什么呢？”&emsp;&emsp;钱先生微笑，眼里带着光，“在我的祖国，我做什么都行，如果我想，我可以去种苹果（之前美国军官嘲讽他回国只能够种苹果）。” 然而钱学森先生在中国种的苹果树终于在原子弹，导弹顺利爆炸时结出了丰硕的果实。 &emsp;&emsp;40多年后，冯·卡门先生与钱先生做最后的告别时，说他是‘你已经是世界知名的科学家’，这样的评价钱学森先森当之无愧。 &emsp;&emsp;钱先生的妻子蒋英女士说，“我们国家可以没有一个叫蒋英的歌唱家，但不能没有钱学森的科学家。”爱国不仅仅是钱学森同志，而蒋英女士的奉献才能使得钱先生能在核事业中完全的奉献自己。 &emsp;&emsp;钱学森先生从发达的美国历经艰辛才回到了中国，那时中国的航空技术几乎还在水平线上，这样大的难度钱先生不是不知道，但还是毫不犹豫的接下，只要了两个东西：人和地。钱学森先生面对组织真诚，毫无保留。他是一代人的偶像，就像影片结尾处很多士兵来看他工作时说的：钱教授，在我入伍时我就知道你了。 &emsp;&emsp;他是一代又一代人的偶像，也是他们的老师。 &emsp;&emsp;钱学森教给我们怎么样爱国，怎么样在重任面前转压力为动力，交给我们热爱科学，一位干部对钱学森先生说：“钱院长，这下我服你了”，钱学森回复说，不是服我，是服科学。 &emsp;&emsp;21世纪，科学技术是第一生产力。热爱科学是每个人应具备的素质，如何用自己掌握的科学技术报效祖国使我们应该从钱先生身上学习到的，而且，现在我们还处在学习的阶段，应该更加专注地学习，要学就要学到最极致。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《沧浪之水》与我的幼稚]]></title>
      <url>%2F2016%2F%E3%80%8A%E6%B2%A7%E6%B5%AA%E4%B9%8B%E6%B0%B4%E3%80%8B%E4%B8%8E%E6%88%91%E7%9A%84%E5%B9%BC%E7%A8%9A%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;看《沧浪之水》这本书之前，我有点害怕打开这本书而写了一些类似读前感想的文字，然而作品与我的想象完全不同，展开了一个我完全无法想象的故事。 &emsp;&emsp;沧浪之水清兮，可以濯吾缨；&emsp;&emsp;沧浪之水浊兮，可以濯吾足。 &emsp;&emsp;读完这本书，这一首沧浪之歌在我的心里回荡，我甚至不用去查它的调子，我自己自然有我的调子。 &emsp;&emsp;池大为，他研究生毕业成为卫生厅的一个办事员，也是这个厅第一个研究生。开始他以为是马厅长器重他这个人，后来才清醒过来——他只是一个门面。所有的知识分子都有通病就是把世界都作为自己责任的病，改变世界是它们的梦想（虽然一般都不得实现）。 &emsp;&emsp;在伪装实事求是的马垂章面前，天真的池大为显得太稚嫩，他以为的有话就说就是有话就说，在会议上提出出去花费太大的时候，池大为注定要出局了，或许更早，在池大为看到父亲的《中国历代文化名人素描》时已经注定他的一生要出局太多次。 &emsp;&emsp;在中医学会的那几年，他完成了娶妻生子的重要大事，这也有了促使他改变的力量。是的，到现在为止我都认为是他的妻子，他的儿子在不断的逼他改变。研究生出身的他看不起丁小槐这样奴颜婢膝的人，当丁小槐升到主任搬离筒子楼的时候他还是个小科员。董柳（池大为妻子）逼得池大为一次又一次的拷问自己的内心，因为董柳说她儿子什么都要最好的，凭什么强强（丁小槐的儿子）有的他们一波（池大为的儿子）没有，我能理解她的母爱，几乎没什么理由来指责她。但她借着儿子这一挡箭牌不断的逼迫池大为，那一阶段，我太心疼池大为，我开始怀疑婚姻的意义是什么。 &emsp;&emsp;董柳这个人，一开始说着什么是为儿子要拥有更好的住房，两间房有了，想要住套间，套间有了住三室一厅，最后还是在说不满足要住新建大楼里面三楼朝西那个房，让她放弃几乎都像是在她身上割肉。我几乎断定，一开始董柳便是这样的人，只是当时没有借口给她发作，她会包容池大为的无能，但是当她有了挡箭牌之后，她开始了不断的冲锋陷阵，而这阵地就是她那无能的丈夫。她丈夫感激他的包容，对儿子的爱不断促使他难受，昨晚看到这样一段的时候我几乎抑制不住那种堵住了内心的感觉：&emsp;&emsp;“为了儿子妻子，我得挣扎，我有不可推卸的责任，活着是硬道理，没有比这个硬道理更硬的道理了。”&emsp;&emsp;“世界这么大，留给自己的空间却这么小，人就是这么可怜。”&emsp;&emsp;“双膝弯了又弯又有什么用？哭都找不到理由。” &emsp;&emsp;挣扎了6、7年除了内心难受妻子指责没有一点收获，决心陷入却只要半年就升了一级。 &emsp;&emsp;挣扎过程中，池大为一次又一次告诉自己要改变，让自己安心沉沦：&emsp;&emsp;“我心有不甘，不甘，但别无选择。”&emsp;&emsp;“权和钱，这是世界的主宰，是怎么也绕不过去的硬道理。”&emsp;&emsp;“为此我得改变自己，我并不比谁傻些。”&emsp;&emsp;“牺牲和坚守都是一种说法的时候，牺牲就变得意义暧昧。”&emsp;&emsp;最后的最后，在儿子受伤见过种种之后，一切都变得开朗起来，他开始找缝来当机会。而机会总是留给有准备的人这句话没错，给马垂章的孙女打针这个机会被他们稳稳抓住，打针守了几天之后，给妻子调换工作岗位，回谢马厅长夫人……池大为的职业生涯这时顺风顺水了:科长——副处长——处长——厅长助理——副厅长——厅长。真的有些事情你放下负担之后就来得很快。 &emsp;&emsp;在看书的时候，我替池大为难受，希望他赶快改变，他改变之后我也替他担心，怕他让我失望。 &emsp;&emsp;他与孟姓女子有过一段情，但他理智的掐断了，他明白自己不可能离婚，也是不想耽搁24岁的女子自己寻找幸福，更怕她毁了自己官路，所以他放弃了那女子（虽然那个女子纯粹真心的可能性也小）。当他与这女子产生些感情时，我替他担心，害怕他走上传统官员的腐败之路。 &emsp;&emsp;池大为说：毕竟，我是迟永昶（chang）的儿子。 &emsp;&emsp;他的底线还是有的，不敢接受贪污，不敢包养情妇。希望做个好官，于是，六十万的贿赂退回，虽然他也心动；孟女士被拒绝，虽然他也说过喜欢这个女子；他让小龚去中医学会历练几年，虽然他看重他。 &emsp;&emsp;说到小龚，当年的马厅长是这样想的么？池大为在大会上提意见之后也被派到了中医学会，历史的必然性也有巧合性，若干年后的小龚，会成为有些底线的池大为还是没有底线的丁小槐？ &emsp;&emsp;在同学会上，池大为不断的出局，在与屈姓女子的恋情中出局，在工作中不断的出局。池大为想要证明自己是个能干的人，但是时代不给他机会，于是他扭曲自己找了机会，成了后来的池大为。在成为厅长之后还是想要证明自己，整理小金库，让群众提意见……打算大干一番的时候，他的兵跟他唱反调了，而且他发现如果要这样改，他的利益也会被不断截肢，于是不了了之，做了些细小的改变便罢了。那时候我既心痛他，又开始怀疑这个池大为还是不是之前的池大为？我忘了我自己当时也在多么希望他改变。 &emsp;&emsp;当池大为在父亲坟前将那本《中国历史人物素描》这本书烧了的时候，我似乎意识到池大为真的不是池大为了，也许他会变成与马垂章一模一样的人。这便是中国官场了……&emsp;&emsp;“父亲，现在是我，你的儿子，站在这里。也许，在这个世界上，我是唯一能够理解你的人。虽然我没有以你的方式面对世界。你相信人性的善良，相信时间的公正，把信念和原则置于生命之上。你对世界的理解有着浪漫的崇高，而没有显示的庸人气息。我理解你以知其不可为而为之的姿态，那样从容不迫地走向了牺牲的意义。在我看来，你是大智若愚。……而我，你的儿子，却在大势所趋别无选择的口实之中随波逐流地走上了另一道路。”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[害怕悲剧]]></title>
      <url>%2F2016%2F%E5%AE%B3%E6%80%95%E6%82%B2%E5%89%A7%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;昨晚费劲的在网站的推荐上整理了最近想要看的书，然后我在当当上买了一本《沧浪之水》。这本书推荐者写的是一个医生想要做正直的人，却最终在利益与良心之间找到平衡。我没经历社会，我不知道这里面会是多么的黑暗，我真正在今天可以看的时候我却不敢翻开这本书。 &emsp;&emsp;我害怕看到悲剧，害怕看到人受苦，更痛恨的是自己无法帮到他们。不论是我叔叔和哥哥那样的在工地上的民工，还是泰山挑水工那样的人，或是学校静湖那里推石头的大叔们。他们在烈日下工作，手都被烫起泡，肩膀被打起茧也还是在工作，因为要养活家里人。这样的人生当然不是悲剧，依着自己的劳动获得报酬，只是这样的生活很苦。但是有的人劳动已经很辛苦，但却在某日放假的时候和工友打牌而把钱给输了，导致自己抱怨社会抱怨家人抱怨其他，那这就是悲剧了。 &emsp;&emsp;人生都是一次又一次的选择，选择错了不要紧，但是自己知道选择错了但却坚持一条道走到黑的人，迟早都是悲剧。还有一些人，命运给他们安排了太多的坎坷，不得不成为悲剧。我不敢说什么坚持，什么原则，在那样一个境遇下，我大概更坚持不住就会妥协。 &emsp;&emsp;某些层面来说，书中的悲剧更让人记忆深刻，之前看《无声告白》的时候，那个女孩最终还是死了。这么久我还能清晰的记得这个女孩是怎么一步一步踏上那条路，也能记得她心里的矛盾挣扎。但相反的另外一本同一时段看的一本《孤独小说家》，青田先生最终还是获得了直本奖，但我对他的日常的生活怎么度过，他在第一次错过直本奖的时候压下嫉妒大方祝贺的这些经历记不太清了。 &emsp;&emsp;当然，我相信，让人记忆深刻写悲剧不是作家的目的。 &emsp;&emsp;往往不是发生在自己身上的我们都能淡然面对，但看书的时候我会不自觉的代入，想象受苦的那人是我，只有他们做出了和我自己不一样选择的时候才会意识到我还是我，但是之后就是惭愧，我不如他。有的悲剧是让你在发笑的时候不自觉戛然而止，我害怕这种笑着笑着眼泪就出来的境况；有的悲剧让人在读的时候心都要绷紧了，我害怕在那时候呼吸困难无法解脱的感觉。 &emsp;&emsp;说了这么多，其实书还没看。我想等书看了再写一个读后感。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记大三的最后一堂考试]]></title>
      <url>%2F2016%2F%E8%AE%B0%E5%A4%A7%E4%B8%89%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A0%82%E8%80%83%E8%AF%95%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;毛泽东概论与中国特色社会主义理论。这是最后一门考试的内容，这是一堂开卷的考试，我不知道怎么样才能表达我内心的惆怅，因为这是读书生涯中最后一次坐在教室考试了。我相信这一次考试不仅仅对我，对他们自己应该也是特别的。&emsp;&emsp;一个半小时的考试，我用尽全力的写，写完就要求交卷了，这也只是平常的考试罢了，考完了，我走在去实验室的路上，回想了我这十几年经历的大大小小的考试。或因为很重要所以很紧张，或因为是要排名次所以很认真，或因为没什么关系所以掉以轻心；但是所有的考试都是考完就轻松，而没有哪次考试是觉得这次考试完了就不会再有这样的考试了。 &emsp;&emsp;最后一次的考试完了意味着是准大四的人了（过不过这种问题应该不用说吧），意味着要开始复习找工作了，意味着再过不久就要成为社会人了，没有学校的保护伞，我不知道我会成为什么样的人，但是我很期待。&emsp;&emsp;昨晚和室友（郑阳）聊天，说到梦想这个话题，一个20岁的人没有明确的梦想大概是不可能的。&emsp;&emsp;郑阳说她的梦想以前是做一个女强人，但后面改变了，想做一个有工作，但能很顾着家里的女人，要经常旅行，想做老板娘。梦想这东西没什么好笑的，即使那样，那也是她要为之奋斗的生活。&emsp;&emsp;我的梦想呢？我的梦想是什么呢？&emsp;&emsp;我想到很久以前和爸爸相处的片段（去世七八年，其实忘了很多了）。那是国庆节，领导人在天安门还是车上什么的阅兵，那时候，我说我也想成为阅兵的那个人（记不得是爸爸问的还是我自己说的了）。那大概就是儿时的想法了，随着长大，想法慢慢的变化。&emsp;&emsp;我爸爸过世的时候我读初二，去得太突然，平时生龙活虎的人突然就倒下了，半小时就过世了，那时候我很庆幸我奶奶早几年过世了，不然老了还得经历一场伤心。但我的妈妈那个时候真的太难过了，我第一次看见这个坚强的人一只手撑在强上哭（后面这个人就变得常哭了）。那是我人生中第一次面临这样大的变故，我大概懂了疾病的可怕，先带走了我的奶奶，后面又带走了我的爸爸。那时候我懵懵懂懂的就想当医生了。&emsp;&emsp;高考的失败，我并没有强迫自己读医科。选了一个风马牛不相及的专业，因为内心丰富，而且一个人的生活实在是充满了诉说，那时候我看了很多小说（言情小说，玄幻小说），觉得自己也可以做一下文艺之人，迫使自己在网上注册了笔名，准备写小说，大一时还签约一本，但是都未完成就放弃了。&emsp;&emsp;人注定是要专注的做一件事才能真正的成，因为不专注所以没能坚持住也是正常。前一阵，我幻想了我以后想要的生活，在我有一些存款了的情况下，回到老家，陪着爸爸也是对自己的解放，种一点地，种一点菜，生活可以朴素，精神但是很充足，我可以伴着音乐，写点我想写的文字，就算没有什么想写的那我可以看些我想看的书，那种应该算是隐士的生活了。&emsp;&emsp;我不知道有没有那个机会实现我的梦想，我其实不怕嫁不嫁人这样的事情，但是若是我一辈子都过不上这样的生活我大概是不会觉得人生满足的吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[7.12-7.17学习心得]]></title>
      <url>%2F2016%2F7-12-7-17%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
      <content type="text"><![CDATA[我的絮絮叨叨&emsp;&emsp;本周周一是考试，所以周二就开始了我本科中的最后一个暑假了，然而这个暑假应该不算轻松的，因为要复习找工作啦，所以每周记录一下我的复习心得。&emsp;&emsp;这一周提高了些学习习惯，但是也没有达到一种投入的程度。而且对计划并不能每天完成，以致于周末的写博客推到了今天（另一周的周二）才完成。一是对任务的安排，二是对自己承诺的未完成的任务没有愧疚感的推时间。&emsp;&emsp;希望以后自己改正！！！ 概述所谓概述就是本周的复习目录 RecyclerView 单线程的断点续传 线程池 多线程的断点续传 RecyclerView&emsp;&emsp;一直有听说这个控件，终于自己动手去学了一下。这个控件自定义程度比ListView超出了大概不止一倍。其实这对我来说就是用起来感觉更麻烦了。 最基本要设置四个属性： setLayoutManager:有三个，线性，网格，瀑布流 setAdapter:这个Adapter不是继承BaseAdapter,而是继承的RecyclerView.Adapter setItemAnimator：这个是设置动画，可以用平移或者渐变什么的慢慢琢磨，一般用DefaultItemAnimator应该是默认的。 addItemDecoration：添加分割线，这个线性布局，网格布局应该是不一样的，画的东西不一样。如果只想用颜色分开的话，我建议不要采用这种方式，slider什么的可以设置的。 遇到的小问题&emsp;&emsp;我最开始创建项目就遇到了一个问题，那就是引入包的问题，最开始还以为是support.v7包里的一个类，直接引用却发现没有这个类，我内心那会儿大概是崩溃的，没有这个类我还玩儿啥啊。后面百度了发现那是得单独引用还得跟v7的包版本一致，然后是下面这样的：12compile 'com.android.support:appcompat-v7:23.2.1'compile 'com.android.support:recyclerview-v7:23.2.1' 未完成的一些&emsp;&emsp;里面效果还有很多，下拉刷新，空页面等效果没有实现，这些可能得自己找个时间把它完成才行了。 单线程的断点续传&emsp;&emsp;其实就是下载文件，可以开始，暂停，暂停之后再开始。与第一个单独的控件学习不同，这里面涉及了挺多的知识点的。 开启子线程来链接网络 如何下载文件 数据库操作 广播发送与接收 服务与Activity之间的交流 &emsp;&emsp;关于开启子线程里链接网络。因为主线程里面是禁止进行耗时操作的，所以链接网络放到子线程里面。想要传递的参数可以使用构造函数new的时候传递，利用Handler进行回传。尽量不要使用类变量直接线程和包含线程这个主类公用。&emsp;&emsp;创建两个实体类，文件信息和线程信息。线程信息主要是保存在数据库中，文件信息得是作为参数传递到服务，传递到初始化线程，还要传递到下载任务类。&emsp;&emsp;下载文件这个事情其实说起来很简单，创建一个文件，然后打开网络的输出流，将输出流输出到Byte数据（inputStream.read(buffer)），再把这个数组写到文件里（raf.write(buffer, 0, len)），就行了。但是要使用RandomAccessFile（raf = new RandomAccessFile(file, “rwd”)）来实现随机写入的功能，因为你要续传是从上次停止写的那里开始继续写。&emsp;&emsp;数据库操作，其实数据库操作我以前的习惯真的太差了，在JAVAEE里面我有使用接口的习惯，但是在Android里面这个习惯被我忘了，听了课之后才了解接口这个方法挺好的。Dao里面定义接口，Impl里面实现接口。&emsp;&emsp;广播的发送接收很简单，sendBroadcast就行，在Intent里面放入你的参数，在Activity里注册广播，IntentFilter来添加过滤决定接收哪些广播，再注册一下（registerReceiver(mReceiver, filter)）。1234mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123;&#125; &emsp;&emsp;开启服务用Intent添加参数，然后startService(intent)就开启成功了。Service里面用onStartCommand方法接收Intent带的参数就OK，然后再需要与Activity交流的时候发送广播就可以。有一点，Service也像Acitivity一样，要注册在manifests文件里面，自己也可以作为Context来传递。&emsp;&emsp;这个的学习，不仅仅是代码，更多的是分配怎么做一个东西，规划好类之间的通讯，然后再按照注释写步骤一步一步完成，比东做一点，西碰一点更有激励性，完成一步测试一步更是减少了出错的可能性。还要提高写注释的能力。 线程池&emsp;&emsp;线程池只是学习了Java自有的线程池，并没有自己着手写一个线程池的想法，所以学习得很简单。线程池分为四类： ExecutorService cacheThreadPool = Executors.newCachedThreadPool(); ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); 第一种是一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，没有数量限制。第二种是一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。例中只给了3个线程，但假如一样的任务有十个，这个会三个三个为组合完成任务。第三种是一个定长线程池，支持定时及周期性任务执行。括号里面是线程数目。第四种是一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 多线程的断点续传&emsp;&emsp;这个和单线程的断点续传很多都类似，我用了RecyclerView来改造了下页面，变成了多任务的（申明：单线程多线程都可以多任务的，只是大概得等）。&emsp;&emsp;使用了线程池，将任务放到了缓存线程池里面执行(单线程池大概适合单线程下载的时候)。修改了页面显示，修改了下载完成的标志，每个线程完都要检查是不是这个任务的所有的下载完了。还有对页面的刷新，500ms发送一次三个线程会刷新提高三倍，所以修改了页面刷新的代码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[和自己做朋友]]></title>
      <url>%2F2016%2F%E5%92%8C%E8%87%AA%E5%B7%B1%E5%81%9A%E6%9C%8B%E5%8F%8B%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;今天是寻常的一天，也是不寻常的一天。 &emsp;&emsp;像往常一般，7点过的闹钟把我闹醒。但是，我迷迷糊糊的意识到我今天并不用去实验室，倒头打算再睡一个回笼觉。 &emsp;&emsp;打开手机望一眼（完全是惯性，我相信很多手机控都有，不为了看什么，就只是为了放个心），有两个高中同学的消息。一个表示她要去荣昌了（去培训学校做兼职），另一个表示他要出发了（骑自行车去新校区，我在他们新校区附近）。嘱咐了熊同学路上小心，钱包放好，然后表示要睡回笼觉；又跟肖同学扯了个谎，说今天实验室有事，不能陪他去交大，然后放心开始睡觉。 &emsp;&emsp;醒来是肖同学的QQ消息，表示车子爆胎了，正在修理，我表示同情，让他回去，但他愿意继续骑行过来，我平常对这样不放弃的精神表示十万分的赞赏，但今天我并不乐意他来，主要是因为我没钱了，没钱出门别人请吃饭我都觉得不太安生。他执意，我的内心也开始了天人交战：&emsp;&emsp;“要不下午就去吧，大不了找人借点钱就出门了，反正也不一定会用！”&emsp;&emsp;“这不是用不用的问题，自己把钱用光了还借着用，借着还是这样的事，不能去借，要么空手去，要么不去！” &emsp;&emsp;最终我还是没去，下午睡午觉愣生生睡到了4点过。他到交大就3点过了，然后朋友们也没等他，这一天他的经历大概是算要有多凄凉就有多凄凉。他给我是这样说的：再不来我就回去了……太累了，车子踏板螺丝松了，很小一件事，但这边推着它走了1个小时，才终于找到一家可以把它拧紧的修车店。我真真切切的从他的话中感到疲累大概还有伤心，一方面我为自己不去的理由感到脸红，但更让我脸红的是大概好几周前我怂恿了他来找我们耍。他来了，我却怂了。我真正怂的原因应该不仅仅于此的，因为我们这边一般这样的聚会都是高中的都去，但是梅青松和邓伟都拒绝了他，我一个女生，其实也觉得挺尴尬的。我的自私暴露无遗，因为我害怕我自己尴尬，所以留他一个人尴尬，大概他那没有人知道的内心在我说了我不能去的时候是正在哭泣的。 &emsp;&emsp;大概是今天，我才感觉我是真正的失去我高中的很多情谊了。从最开始的一学期聚好几次，到现在一学期都不聊一次，我确实是能感受到这些变化的，但是我也无力挽回，我没有兴趣将时间花在网络聊天上，见面能见面的又少，越来越疏远也是无可避免。 &emsp;&emsp;每天都是平常的一天，每天也都是特殊的一天。我做着平常都在做的事情，没有去尽情的挥霍着我的激情，也没有睡一整天过去；今天的感想昨天从未有过，即使主题相同，但我也坚定今天比昨天更深刻了一些，更别说我昨天想都没有想得事情，就在今天却有了自己的思考。 &emsp;&emsp;同学在大学各有风姿，有的是学霸，收获恋爱或友谊，我只是最平常的度过，最平常的朋友，最平常的成绩。不能想象我以前也曾成绩顶尖（在我们那个班级），朋友成群，也有过我认为的暗恋。 &emsp;&emsp;一个人长相普通，成就普通，家庭普通，这样的人只能被沦为背景，在电影电视中称为群众演员。可以漠视这个人，但千万不能认为这个人就是木头人，你不知道他经历了什么，或者他什么也没经历，那他也是他心目中特别的一个，他也会为看了一本书而思考全人类的未来，也会看到地上的垃圾而担忧环境并作出反应。 &emsp;&emsp;作为普通人，我的忙碌，我的学习都只是最普通的一环，即使是我最亲密的朋友，最亲近的家人也没有兴趣多去了解；但作为我自己，我知道我今天看了几页书，书里的人的话或许哪里又触动了我，这些，我无须向他人诉说，那是特别的自己才能了解。 &emsp;&emsp;和自己做最亲近的朋友，即使是普通的一天，也是特别的一天；即使是最普通的普通人也是最特别的人。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的博客的搭建过程]]></title>
      <url>%2F2016%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[正文前的唠叨一名程序猿，没有个人博客说来惭愧，之前觉得搭建起来太麻烦就算惭愧也那么过了。今天看鸿洋大神的微信公众号推荐了博客搭建，方法看起来挺简单的，那我还能忍？ 至于为什么用hexo，用git……我懒得叙述了，反正就是他们了。 唠叨结束，下面开始正文 总体概述我个人昨天一天搭建博客的过程。走了比较多的弯路。其实过程总共也就分为以下几步： github注册，创建项目 安装git 安装node.js 安装hexo 配置hexo，访问你的博客 hexo文件目录 关于网站文件配置_config.yml的更多 写一篇文章 换主题 结束语 github注册，创建项目好奇github是什么，git是什么自己百度去。 注册地址：github创建项目：项目名是你的Username.github.io然后点击：setting 然后往下滑动到点击：lunch automatic page generator再然后就是一步一步往下就可以了 安装git这里不详细写了，网上下载git客户端，然后配置SSH因为这个教程基本不用git的命令，有兴趣的自己去学。安装和基本操作 安装node.jsnode.js的安装也是十分简单，甚至连环境变量都不需要，下载客户端，然后基本就可以了。以下也是一个教程：安装node.js 安装hexo终于到正题了，我都等不及了。以下是参考Chillax’s Blog 来的，基本博客的结构也跟他差不多，因为我就是大概照着他弄的呀，哈哈你问我有了他的你为麻子还要写？我乐意，不然我弄个人博客干嘛？ 言归正传，通过hexo不用写html页面,基本是用markdown写作，的常用命令 12345678910111213 hexo g #生成静态文件 hexo d #发布到github hexo s #发布在本地，localhost:4000 hexo n #新建一篇文章``` bash安装过程中如果报错：ERROR Deployer not found : github 运行下面几行： ``` bash npm install hexo-deployer-git --save hexo g hexo d 下面开始安装，选择一个地方，右键，打开git bash1npm install hexo-cli -g 然后开始部署你的博客了哈，决定好你的博客位置了之后，建立一个文件夹，随便取名(不要中文哟，不然我也不知道会发生什么)。例如我：F:\OwnPage\hexo\进入文件夹之后，再次打开git bash:依次输入命令12hexo init #下载搭建网站需要的文件npm install #这个时候显示出node.js的好处了，下载依赖包 哈哈，这个时候我们已经基本成功啦。我们在本地看一下：12hexo ghexo s 按提示打开localhost:4000，你就可以看见一个漂亮的博客网站了，没错，它就是你的了。 配置hexo，访问你的博客刚刚的成果已经让你很开心了吧，当时我也是的，但这只是本地预览，接下来会有更爽的。还记得我们第一步创建的项目吧，我们来得到他的一个地址：git@github.com……因为ssh协议似乎会快点，http的有时候还会不行。接下来打开你的网站文件夹，有个_config.yml（我表示第一次见这个后缀，但应该和xml相差不大吧），只是每个冒号后要有一个空格才能起作用，用文本编辑软件打开，记住不要用记事本，乱成一团。在最后这里： 12deploy: type: 改成：1234deploy: type: git repository: git@github.com:MonkeyLLuffy/MonkeyLLuffy.github.io.githuangjunhui.github.io.git #你的项目仓库的地址 branch: master 如果没配置SSHkey,以上会出问题的哟。接下来把它发送到你的github仓库里去:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 hexo g hexo d```接下来我们就可以通过：http://username.github.io访问你的博客了。最开始可能有延迟，但十分钟都没有，甚至404，那么没有错，你的过程错啦……错了不要惊慌，再来一次又不费劲。## 关于网站文件配置_config.yml的更多 ##``` bash # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site 这下面的几项配置都很简单，你看我的博客就知道分别是什么意思 title: Chillax blog #博客名 subtitle: Goals determine what you are going to be #副标题 description: Goals determine what you are going to be #用于搜索，没有直观表现 author: huangjunhui #作者 language: zh-CN #语言 timezone: #时区，此处不填写，hexo会以你目前电脑的时区为默认值 # URL 暂不配置，使用默认值 ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: https://opiece.me #域名，没有就不填 root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory 暂不配置，使用默认值 source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing 文章布局等，使用默认值 new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true tab_replace: # Category &amp; Tag 暂不配置，使用默认值 default_category: uncategorized category_map: tag_map: # Date / Time format 时间格式，使用默认值 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 10 #每页显示的文章数，0表示不分页 pagination_dir: page # Extensions 插件配置，暂时不配置 ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ plugins: - hexo-generator-feed theme: light #使用的主题，即：\themes文件夹下的主题文件夹名 feed: #之后配置rss会用，使用如下配置即可 type: atom path: atom.xml limit: 20 # Deployment 用于部署到github，之前已经配置过 ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: git@github.com:MonkeyLLuffy/MonkeyLLuffy.github.io.githuangjunhui.github.io.git branch: master ```## 写一篇文章 ##接下来就是新建一篇文章啦：``` bash hexo n &quot;第一篇博客&quot;```就会在、source/_post里面新增一个“第一篇博客.md”文件，然后用markdown打开文件开始编辑你的文件。每个主题会有不同的头部，但是到时候换主题可以查主题的文档照着做。``` title: my new post #可以改成中文的，如“新文章” date: 2015-04-08 22:56:29 #发表日期，一般不改动--- title: Hello World categories: 测试博客 tags: - Testing - Another Tag #文章标签 --- #这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上 &lt;!--more--&gt;#在&lt;!--more--&gt;之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 写完之后，hexo的命令，生成静态文件，本地预览（可以不要）,发布到git123hexo ghexo shexo d 换主题整个教程刚刚就基本结束了，但是我们都追求特别，默认的主题肯定不能满足你们，所以基本讲下怎么换主题。以Next主题为例：首先：找到他的gitHub地址：https://github.com/iissnan/hexo-theme-next然后git bash将这个主题clone下来：1git clone https://github.com/iissnan/hexo-theme-next.git 等克隆完了将这个文件夹放到博客文件夹的Themes目录下克隆速度慢得要死，这个时候我们不要闲着，看看他的ReadMe文件：这个文件里，有个链接：NEXT使用文档，打开它具体步骤不再赘述，照着文档一步一步做，你将会看到一个不一样的你的博客。 本来这一大篇都是跟教我的那个差不多，问我为什么不详写这个步骤了？我手痛！！，自己查文档去问：这个主题这样换好了，下一次看到好看的主题想换怎么办，想换就换呗，不拦着你，千万要找到文档再换哟，不然，呵呵呵呵呵呵，结果难料 结束语真正的第一篇博客到此完工，打着复习的旗号在宿舍写博客也是棒棒哒。撒花完结！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大家好，我是刘群的博客]]></title>
      <url>%2F2015%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[希望大家喜欢我的博客，经常来哟android wofjsddn dhfvdhhs dsjvdgh hsjishsnsus esrgtf wodejianfe]]></content>
    </entry>

    
  
  
</search>
